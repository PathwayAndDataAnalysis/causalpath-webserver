{"version":3,"sources":["/Users/durupina/CWC/causalpath-webserver/node_modules/browser-pack/_prelude.js","/Users/durupina/CWC/causalpath-webserver/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/arraydiff/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/browserchannel/dist/bcsocket-uncompressed.js","/Users/durupina/CWC/causalpath-webserver/node_modules/deep-is/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby-templates/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby-templates/lib/contexts.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby-templates/lib/expressions.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby-templates/lib/operatorFns.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby-templates/lib/templates.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/App.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/Controller.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/Derby.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/Dom.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/Page.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/_views.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/components.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/documentListeners.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/eventmodel.js","/Users/durupina/CWC/causalpath-webserver/node_modules/derby/lib/textDiff.js","/Users/durupina/CWC/causalpath-webserver/node_modules/events/events.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-json0/lib/bootstrapTransform.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-json0/lib/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-json0/lib/json0.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-json0/lib/text0.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-text-tp2/lib/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-text-tp2/lib/text-tp2.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-text/lib/api.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-text/lib/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/ot-text/lib/text.js","/Users/durupina/CWC/causalpath-webserver/node_modules/path-browserify/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/process/browser.js","/Users/durupina/CWC/causalpath-webserver/node_modules/punycode/punycode.js","/Users/durupina/CWC/causalpath-webserver/node_modules/qs/lib/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/qs/lib/parse.js","/Users/durupina/CWC/causalpath-webserver/node_modules/qs/lib/stringify.js","/Users/durupina/CWC/causalpath-webserver/node_modules/qs/lib/utils.js","/Users/durupina/CWC/causalpath-webserver/node_modules/querystring-es3/decode.js","/Users/durupina/CWC/causalpath-webserver/node_modules/querystring-es3/encode.js","/Users/durupina/CWC/causalpath-webserver/node_modules/querystring-es3/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/qunitjs/qunit/qunit.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer-bundle/node_modules/browserify/node_modules/url/url.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer-highway/lib/browser.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Channel.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/Doc.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/LocalDoc.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/Model.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/Query.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/RemoteDoc.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/collections.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/connection.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/contexts.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/defaultFns.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/events.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/filter.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/fn.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/mutators.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/paths.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/ref.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/refList.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/setDiff.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/subscriptions.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Model/unbundle.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/Racer.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/racer/lib/util.js","/Users/durupina/CWC/causalpath-webserver/node_modules/saddle/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/serialize-object/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/client/connection.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/client/doc.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/client/emitter.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/client/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/client/query.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/client/textarea.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/types/index.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/types/text-api.js","/Users/durupina/CWC/causalpath-webserver/node_modules/share/lib/types/text-tp2-api.js","/Users/durupina/CWC/causalpath-webserver/node_modules/tracks/lib/History.js","/Users/durupina/CWC/causalpath-webserver/node_modules/tracks/lib/browser.js","/Users/durupina/CWC/causalpath-webserver/node_modules/tracks/lib/router.js","/Users/durupina/CWC/causalpath-webserver/node_modules/tracks/vendor/express/router/route.js","/Users/durupina/CWC/causalpath-webserver/node_modules/tracks/vendor/express/utils.js","/Users/durupina/CWC/causalpath-webserver/node_modules/uuid/rng-browser.js","/Users/durupina/CWC/causalpath-webserver/node_modules/uuid/uuid.js","/Users/durupina/CWC/causalpath-webserver/public/src/cgf-visualizer/cgf-cy.js","/Users/durupina/CWC/causalpath-webserver/public/src/model/modelManager.js","/Users/durupina/CWC/causalpath-webserver/test/testOptions.js","/Users/durupina/CWC/causalpath-webserver/test/testsGraphCreation.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnsFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACplBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzjBA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1VA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACziBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChQA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACr1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACteA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9sCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (__filename,__dirname){\n/*\n *\tModel initialization\n *  Event handlers of model updates\n *\tAuthor: Funda Durupinar Babur<f.durupinar@gmail.com>\n */\nvar app = module.exports = require('derby').createApp('cwc', __filename);\n\n\napp.loadViews(__dirname + '/views');\n//app.loadStyles(__dirname + '/styles');\n//app.serverUse(module, 'derby-stylus');\n\n\nvar testMode = false;\n\nvar docReady = false;\n\nvar socket;\n\napp.modelManager = null;\n\nvar cgfCy;\n\n\nvar graphChoiceEnum = {\n    JSON: 1, ANALYSIS: 2, DEMO: 3\n};\n\nvar graphChoice;\n\napp.get('/', function (page, model, params) {\n    function getId() {\n        return model.id();\n    }\n\n    function idIsReserved() {\n        var ret = model.get('documents.' + docId) != undefined;\n        return ret;\n    }\n\n    var docId = getId();\n\n    while (idIsReserved()) {\n        docId = getId();\n    }\n\n     if( testMode ){ // use qunit testing doc if we're testing so we don't disrupt real docs\n         docId = 'qunit';\n     }\n\n    return page.redirect('/' + docId);\n});\n\n\napp.get('/:docId', function (page, model, arg, next) {\n    var messagesQuery, room;\n    room = arg.docId;\n\n\n    var docPath = 'documents.' + arg.docId;\n\n    model.subscribe(docPath, 'cgfText', function(err){\n        if (err) {\n            return next(err);\n        }\n        model.setNull(docPath, { // create the empty new doc if it doesn't already exist\n            id: arg.docId\n\n        });\n        // create a reference to the document\n        model.ref('_page.doc', 'documents.' + arg.docId);\n\n    });\n\n    model.subscribe(docPath, 'cy', function(err){\n        if (err) {\n            return next(err);\n        }\n\n    });\n\n\n    model.set('_page.room', room);\n\n\n    page.render();\n\n});\n\n\n\napp.proto.create = function (model) {\n\n    docReady = true;\n    cgfCy = require('./public/src/cgf-visualizer/cgf-cy.js');\n\n\n    socket = io();\n\n    var id = model.get('_session.userId');\n    var name = model.get('users.' + id +'.name');\n\n    this.modelManager = require('./public/src/model/modelManager.js')(model, model.get('_page.room'), model.get('_session.userId'),name );\n\n    if(testMode)\n        this.runUnitTests();\n\n\n};\n\n\napp.proto.runLayout = function(){\n    if(docReady)\n        cgfCy.runLayout();\n}\n\n\n/***\n * Reload the graph\n * Called after changing topology grouping\n */\napp.proto.reloadGraph = function(){\n\n    cy.destroy();\n    var cgfText = this.model.get('_page.doc.cgfText');\n    this.createCyGraphFromCgf(JSON.parse(cgfText));\n}\n\n/***\n * Load demo graph from demoJson.js\n */\napp.proto.loadDemoGraph = function(){\n\n    graphChoice = graphChoiceEnum.DEMO;\n    this.model.set('_page.doc.cgfText', JSON.stringify(demoJson));\n    this.createCyGraphFromCgf(demoJson);\n\n}\n\n/***\n * Load graph file in json format\n */\napp.proto.loadGraphFile = function(){\n\n    var self = this;\n\n    graphChoice = graphChoiceEnum.JSON;\n\n    var reader = new FileReader();\n\n    var extension = $(\"#graph-file-input\")[0].files[0].name.split('.').pop().toLowerCase();\n\n    reader.onload = function (e) {\n\n        self.model.set('_page.doc.cgfText', this.result);\n        self.createCyGraphFromCgf(JSON.parse(this.result));\n\n    };\n    //TODO: move graph-file-input to an argument\n    reader.readAsText($(\"#graph-file-input\")[0].files[0]);\n}\n\n\n/***\n * Take the input files and transfer them to the server in analysisDir and run shell command\n * Produces graph from analysis results\n */\napp.proto.loadAnalysisDir = function(){\n\n    var self = this;\n    graphChoice = graphChoiceEnum.ANALYSIS;\n    var fileCnt = $('#analysis-directory-input')[0].files.length;\n    var fileContents = [];\n    var notyView = noty({type:\"information\", layout: \"bottom\",text: \"Reading files...Please wait.\"});\n\n    var room = this.model.get('_page.room');\n    notyView.setText( \"Reading files...Please wait.\");\n\n\n    //Sending a zip file\n    if(fileCnt == 1 &&  $('#analysis-directory-input')[0].files[0].name.split('.').pop().toLowerCase() == \"zip\"){\n\n        var file = $('#analysis-directory-input')[0].files[0];\n\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n            fileContents.push({name: file.name, content: e.target.result});\n            notyView.setText( \"Analyzing results...Please wait.\");\n            socket.emit('analysisZip', e.target.result, room, function(json){\n                self.createCyGraphFromCgf(JSON.parse(json), function(){\n                    notyView.close();\n                });\n\n                self.model.set('_page.doc.cgfText', json);\n                notyView.close();\n            });\n        }\n\n        reader.readAsBinaryString(file);\n\n    }\n    else{\n\n\n        var p1 = new Promise(function (resolve, reject) {\n            for (var i = 0; i < fileCnt; i++) {\n                (function (file) {\n\n                    //Send these files to server\n                    var reader = new FileReader();\n\n                    reader.onload = function (e) {\n                        fileContents.push({name: file.name, content: e.target.result});\n                        if(fileContents.length >= fileCnt)\n                            resolve(\"success\");\n                    }\n\n                    reader.readAsText($(\"#analysis-directory-input\")[0].files[i]);\n                })($('#analysis-directory-input')[0].files[i]);\n            }\n        });\n\n        p1.then(function (content) {\n\n            notyView.setText( \"Analyzing results...Please wait.\");\n            var room = self.model.get('_page.room'); //each room will have its own folder\n            socket.emit('analysisDir', fileContents, room, function(data){\n\n                if(data.indexOf(\"Error\") == 0){\n                    notyView.close();\n                    notyView = noty({type:\"error\", layout: \"bottom\",timeout: 4500, text: (\"Error in input files.\")});\n\n                }\n                else {\n\n                    self.createCyGraphFromCgf(JSON.parse(data), function () {\n                        notyView.close();\n                    });\n\n                    self.model.set('_page.doc.cgfText', data);\n                }\n            });\n\n\n        }), function (xhr, status, error) {\n            api.set('content.text', \"Error retrieving data: \" + error);\n\n        }\n    }\n\n}\n\n\n/***\n * Create cytoscape graph from cgfJson\n * @param cgfJson\n */\napp.proto.createCyGraphFromCgf = function(cgfJson, callback){\n\n    var noTopologyGrouping = this.model.get('_page.doc.noTopologyGrouping');\n\n\n    if(cgfJson == null){\n        var cgfText = this.model.get('_page.doc.cgfText');\n        cgfJson = JSON.parse(cgfText);\n    }\n\n\n    if(cgfJson) {\n        this.modelManager.initModelFromJson(cgfJson);\n\n\n        if (docReady){\n\n            try{\n\n                cy.destroy();\n\n            }\n            catch(error){\n                //console.log(error + \" Cytoscape not created yet.\");\n            }\n        } //cytoscape is loaded\n\n\n\n        this.showGraphContainer();\n\n\n        var notyView = noty({type: \"information\", layout: \"bottom\",  text: \"Drawing graph...Please wait.\"});\n\n\n        var cgfContainer = new cgfCy.createContainer($('#graph-container'),  !noTopologyGrouping, this.modelManager, function () {\n\n\n            if(graphChoice != graphChoiceEnum.JSON) //As json object is not associated with any analysis data\n             $('#download-div').show();\n\n            notyView.close();\n\n            if (callback) callback();\n        });\n    }\n\n}\n\n/***\n * Hides input selection menu and opens graph container\n */\napp.proto.showGraphContainer = function(){\n    $('#info-div').hide();\n    $('#input-container').hide();\n    $('#download-div').hide(); //this only appears after analysis is performed\n    $('#graph-options-container').show();\n    $('#graph-container').show();\n}\n\n/***\n * Initialization of the input selection menu\n */\napp.proto.showInputContainer = function(){\n    $('#info-div').show();\n    $('#input-container').show();\n    $('#graph-options-container').hide();\n    $('#graph-container').hide();\n}\n\n\n\n/***\n *Download and save results in <room>.zip\n */\napp.proto.downloadResults = function(){\n\n    var room = this.model.get('_page.room'); //each room will have its own folder\n\n    if(graphChoice == graphChoiceEnum.DEMO)\n        room = \"demo\"; //directly download\n\n    var notyView = noty({type:\"information\", layout: \"bottom\",text: \"Compressing files...Please wait.\"});\n\n    socket.emit('downloadRequest', room, function(fileContent){\n        console.log(\"Zip file received.\");\n\n        var blob = base64ToZipBlob(fileContent);\n\n        saveAs(blob, (room + \".zip\"));\n\n        notyView.close();\n\n\n    });\n\n}\n/***\n * Local function to convert binary-to-text encoded data into binary zip file\n * @param data\n * @returns {*}\n */\nfunction base64ToZipBlob(data){\n\n    var byteCharacters = atob(data);\n    var byteNumbers = new Array(byteCharacters.length);\n    for (var i = 0; i < byteCharacters.length; i++) {\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\n    }\n\n    var byteArray = new Uint8Array(byteNumbers);\n\n    var blob = new Blob([byteArray], { type: \"application/zip\"});\n\n    return blob;\n\n}\n\n\n/***\n * Run unit tests\n */\napp.proto.runUnitTests = function(){\n\n    require(\"./test/testsGraphCreation.js\")();\n    require(\"./test/testOptions.js\")(); //to print out results\n\n}\n\n}).call(this,\"/index.js\",\"/\")","module.exports = arrayDiff;\n\n// Based on some rough benchmarking, this algorithm is about O(2n) worst case,\n// and it can compute diffs on random arrays of length 1024 in about 34ms,\n// though just a few changes on an array of length 1024 takes about 0.5ms\n\narrayDiff.InsertDiff = InsertDiff;\narrayDiff.RemoveDiff = RemoveDiff;\narrayDiff.MoveDiff = MoveDiff;\n\nfunction InsertDiff(index, values) {\n  this.index = index;\n  this.values = values;\n}\nInsertDiff.prototype.type = 'insert';\nInsertDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    values: this.values\n  };\n};\n\nfunction RemoveDiff(index, howMany) {\n  this.index = index;\n  this.howMany = howMany;\n}\nRemoveDiff.prototype.type = 'remove';\nRemoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    howMany: this.howMany\n  };\n};\n\nfunction MoveDiff(from, to, howMany) {\n  this.from = from;\n  this.to = to;\n  this.howMany = howMany;\n}\nMoveDiff.prototype.type = 'move';\nMoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    from: this.from,\n    to: this.to,\n    howMany: this.howMany\n  };\n};\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n\nfunction arrayDiff(before, after, equalFn) {\n  if (!equalFn) equalFn = strictEqual;\n\n  // Find all items in both the before and after array, and represent them\n  // as moves. Many of these \"moves\" may end up being discarded in the last\n  // pass if they are from an index to the same index, but we don't know this\n  // up front, since we haven't yet offset the indices.\n  //\n  // Also keep a map of all the indices accounted for in the before and after\n  // arrays. These maps are used next to create insert and remove diffs.\n  var beforeLength = before.length;\n  var afterLength = after.length;\n  var moves = [];\n  var beforeMarked = {};\n  var afterMarked = {};\n  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {\n    var beforeItem = before[beforeIndex];\n    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {\n      if (afterMarked[afterIndex]) continue;\n      if (!equalFn(beforeItem, after[afterIndex])) continue;\n      var from = beforeIndex;\n      var to = afterIndex;\n      var howMany = 0;\n      do {\n        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;\n        howMany++;\n      } while (\n        beforeIndex < beforeLength &&\n        afterIndex < afterLength &&\n        equalFn(before[beforeIndex], after[afterIndex]) &&\n        !afterMarked[afterIndex]\n      );\n      moves.push(new MoveDiff(from, to, howMany));\n      beforeIndex--;\n      break;\n    }\n  }\n\n  // Create a remove for all of the items in the before array that were\n  // not marked as being matched in the after array as well\n  var removes = [];\n  for (beforeIndex = 0; beforeIndex < beforeLength;) {\n    if (beforeMarked[beforeIndex]) {\n      beforeIndex++;\n      continue;\n    }\n    var index = beforeIndex;\n    var howMany = 0;\n    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {\n      howMany++;\n    }\n    removes.push(new RemoveDiff(index, howMany));\n  }\n\n  // Create an insert for all of the items in the after array that were\n  // not marked as being matched in the before array as well\n  var inserts = [];\n  for (var afterIndex = 0; afterIndex < afterLength;) {\n    if (afterMarked[afterIndex]) {\n      afterIndex++;\n      continue;\n    }\n    var index = afterIndex;\n    var howMany = 0;\n    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {\n      howMany++;\n    }\n    var values = after.slice(index, index + howMany);\n    inserts.push(new InsertDiff(index, values));\n  }\n\n  var insertsLength = inserts.length;\n  var removesLength = removes.length;\n  var movesLength = moves.length;\n  var i, j;\n\n  // Offset subsequent removes and moves by removes\n  var count = 0;\n  for (i = 0; i < removesLength; i++) {\n    var remove = removes[i];\n    remove.index -= count;\n    count += remove.howMany;\n    for (j = 0; j < movesLength; j++) {\n      var move = moves[j];\n      if (move.from >= remove.index) move.from -= remove.howMany;\n    }\n  }\n\n  // Offset moves by inserts\n  for (i = insertsLength; i--;) {\n    var insert = inserts[i];\n    var howMany = insert.values.length;\n    for (j = movesLength; j--;) {\n      var move = moves[j];\n      if (move.to >= insert.index) move.to -= howMany;\n    }\n  }\n\n  // Offset the to of moves by later moves\n  for (i = movesLength; i-- > 1;) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    for (j = i; j--;) {\n      var earlier = moves[j];\n      if (earlier.to >= move.to) earlier.to -= move.howMany;\n      if (earlier.to >= move.from) earlier.to += move.howMany;\n    }\n  }\n\n  // Only output moves that end up having an effect after offsetting\n  var outputMoves = [];\n\n  // Offset the from of moves by earlier moves\n  for (i = 0; i < movesLength; i++) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    outputMoves.push(move);\n    for (j = i + 1; j < movesLength; j++) {\n      var later = moves[j];\n      if (later.from >= move.from) later.from -= move.howMany;\n      if (later.from >= move.to) later.from += move.howMany;\n    }\n  }\n\n  return removes.concat(outputMoves, inserts);\n}\n","(function(){\nvar f, aa = aa || {}, l = this;\nfunction ba(a) {\n  a = a.split(\".\");\n  for (var b = l, c;c = a.shift();) {\n    if (null != b[c]) {\n      b = b[c];\n    } else {\n      return null;\n    }\n  }\n  return b;\n}\nfunction ca() {\n}\nfunction da(a) {\n  var b = typeof a;\n  if (\"object\" == b) {\n    if (a) {\n      if (a instanceof Array) {\n        return \"array\";\n      }\n      if (a instanceof Object) {\n        return b;\n      }\n      var c = Object.prototype.toString.call(a);\n      if (\"[object Window]\" == c) {\n        return \"object\";\n      }\n      if (\"[object Array]\" == c || \"number\" == typeof a.length && \"undefined\" != typeof a.splice && \"undefined\" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable(\"splice\")) {\n        return \"array\";\n      }\n      if (\"[object Function]\" == c || \"undefined\" != typeof a.call && \"undefined\" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable(\"call\")) {\n        return \"function\";\n      }\n    } else {\n      return \"null\";\n    }\n  } else {\n    if (\"function\" == b && \"undefined\" == typeof a.call) {\n      return \"object\";\n    }\n  }\n  return b;\n}\nfunction m(a) {\n  return \"array\" == da(a);\n}\nfunction ea(a) {\n  var b = da(a);\n  return \"array\" == b || \"object\" == b && \"number\" == typeof a.length;\n}\nfunction n(a) {\n  return \"string\" == typeof a;\n}\nfunction fa(a) {\n  return \"function\" == da(a);\n}\nvar ga = \"closure_uid_\" + (1E9 * Math.random() >>> 0), ha = 0;\nfunction ia(a, b, c) {\n  return a.call.apply(a.bind, arguments);\n}\nfunction ja(a, b, c) {\n  if (!a) {\n    throw Error();\n  }\n  if (2 < arguments.length) {\n    var d = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      var c = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(c, d);\n      return a.apply(b, c);\n    };\n  }\n  return function() {\n    return a.apply(b, arguments);\n  };\n}\nfunction p(a, b, c) {\n  p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? ia : ja;\n  return p.apply(null, arguments);\n}\nvar q = Date.now || function() {\n  return+new Date;\n};\nfunction s(a, b) {\n  function c() {\n  }\n  c.prototype = b.prototype;\n  a.pa = b.prototype;\n  a.prototype = new c;\n  a.Hc = function(a, c, g) {\n    var h = Array.prototype.slice.call(arguments, 2);\n    return b.prototype[c].apply(a, h);\n  };\n}\n;function ka(a, b) {\n  for (var c = a.split(\"%s\"), d = \"\", e = Array.prototype.slice.call(arguments, 1);e.length && 1 < c.length;) {\n    d += c.shift() + e.shift();\n  }\n  return d + c.join(\"%s\");\n}\nfunction la(a) {\n  if (!ma.test(a)) {\n    return a;\n  }\n  -1 != a.indexOf(\"&\") && (a = a.replace(na, \"&amp;\"));\n  -1 != a.indexOf(\"<\") && (a = a.replace(oa, \"&lt;\"));\n  -1 != a.indexOf(\">\") && (a = a.replace(pa, \"&gt;\"));\n  -1 != a.indexOf('\"') && (a = a.replace(qa, \"&quot;\"));\n  -1 != a.indexOf(\"'\") && (a = a.replace(ra, \"&#39;\"));\n  return a;\n}\nvar na = /&/g, oa = /</g, pa = />/g, qa = /\"/g, ra = /'/g, ma = /[&<>\"']/;\nfunction sa() {\n  return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ q()).toString(36);\n}\nfunction ta(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n;var x, ua, va, wa;\nfunction xa() {\n  return l.navigator ? l.navigator.userAgent : null;\n}\nwa = va = ua = x = !1;\nvar ya;\nif (ya = xa()) {\n  var za = l.navigator;\n  x = 0 == ya.lastIndexOf(\"Opera\", 0);\n  ua = !x && (-1 != ya.indexOf(\"MSIE\") || -1 != ya.indexOf(\"Trident\"));\n  va = !x && -1 != ya.indexOf(\"WebKit\");\n  wa = !x && !va && !ua && \"Gecko\" == za.product;\n}\nvar Aa = x, y = ua, Ba = wa, z = va;\nfunction Ca() {\n  var a = l.document;\n  return a ? a.documentMode : void 0;\n}\nvar Da;\na: {\n  var Ea = \"\", Fa;\n  if (Aa && l.opera) {\n    var Ga = l.opera.version, Ea = \"function\" == typeof Ga ? Ga() : Ga\n  } else {\n    if (Ba ? Fa = /rv\\:([^\\);]+)(\\)|;)/ : y ? Fa = /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/ : z && (Fa = /WebKit\\/(\\S+)/), Fa) {\n      var Ha = Fa.exec(xa()), Ea = Ha ? Ha[1] : \"\"\n    }\n  }\n  if (y) {\n    var Ia = Ca();\n    if (Ia > parseFloat(Ea)) {\n      Da = String(Ia);\n      break a;\n    }\n  }\n  Da = Ea;\n}\nvar Ja = {};\nfunction A(a) {\n  var b;\n  if (!(b = Ja[a])) {\n    b = 0;\n    for (var c = String(Da).replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\").split(\".\"), d = String(a).replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\").split(\".\"), e = Math.max(c.length, d.length), g = 0;0 == b && g < e;g++) {\n      var h = c[g] || \"\", k = d[g] || \"\", u = RegExp(\"(\\\\d*)(\\\\D*)\", \"g\"), K = RegExp(\"(\\\\d*)(\\\\D*)\", \"g\");\n      do {\n        var v = u.exec(h) || [\"\", \"\", \"\"], r = K.exec(k) || [\"\", \"\", \"\"];\n        if (0 == v[0].length && 0 == r[0].length) {\n          break;\n        }\n        b = ta(0 == v[1].length ? 0 : parseInt(v[1], 10), 0 == r[1].length ? 0 : parseInt(r[1], 10)) || ta(0 == v[2].length, 0 == r[2].length) || ta(v[2], r[2]);\n      } while (0 == b);\n    }\n    b = Ja[a] = 0 <= b;\n  }\n  return b;\n}\nvar La = l.document, Ma = La && y ? Ca() || (\"CSS1Compat\" == La.compatMode ? parseInt(Da, 10) : 5) : void 0;\nfunction Na(a) {\n  Error.captureStackTrace ? Error.captureStackTrace(this, Na) : this.stack = Error().stack || \"\";\n  a && (this.message = String(a));\n}\ns(Na, Error);\nNa.prototype.name = \"CustomError\";\nfunction Oa(a, b) {\n  b.unshift(a);\n  Na.call(this, ka.apply(null, b));\n  b.shift();\n}\ns(Oa, Na);\nOa.prototype.name = \"AssertionError\";\nfunction Pa(a, b) {\n  throw new Oa(\"Failure\" + (a ? \": \" + a : \"\"), Array.prototype.slice.call(arguments, 1));\n}\n;var Qa = RegExp(\"^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\\\?([^#]*))?(?:#(.*))?$\");\nfunction Ra(a) {\n  if (Sa) {\n    Sa = !1;\n    var b = l.location;\n    if (b) {\n      var c = b.href;\n      if (c && (c = (c = Ra(c)[3] || null) && decodeURIComponent(c)) && c != b.hostname) {\n        throw Sa = !0, Error();\n      }\n    }\n  }\n  return a.match(Qa);\n}\nvar Sa = z;\nfunction Ta(a) {\n  var b = [], c = 0, d;\n  for (d in a) {\n    b[c++] = a[d];\n  }\n  return b;\n}\nfunction Ua(a) {\n  var b = [], c = 0, d;\n  for (d in a) {\n    b[c++] = d;\n  }\n  return b;\n}\nvar Va = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\nfunction Wa(a, b) {\n  for (var c, d, e = 1;e < arguments.length;e++) {\n    d = arguments[e];\n    for (c in d) {\n      a[c] = d[c];\n    }\n    for (var g = 0;g < Va.length;g++) {\n      c = Va[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);\n    }\n  }\n}\n;var B = Array.prototype, Xa = B.indexOf ? function(a, b, c) {\n  return B.indexOf.call(a, b, c);\n} : function(a, b, c) {\n  c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;\n  if (n(a)) {\n    return n(b) && 1 == b.length ? a.indexOf(b, c) : -1;\n  }\n  for (;c < a.length;c++) {\n    if (c in a && a[c] === b) {\n      return c;\n    }\n  }\n  return-1;\n}, Ya = B.forEach ? function(a, b, c) {\n  B.forEach.call(a, b, c);\n} : function(a, b, c) {\n  for (var d = a.length, e = n(a) ? a.split(\"\") : a, g = 0;g < d;g++) {\n    g in e && b.call(c, e[g], g, a);\n  }\n};\nfunction Za(a) {\n  var b;\n  a: {\n    b = $a;\n    for (var c = a.length, d = n(a) ? a.split(\"\") : a, e = 0;e < c;e++) {\n      if (e in d && b.call(void 0, d[e], e, a)) {\n        b = e;\n        break a;\n      }\n    }\n    b = -1;\n  }\n  return 0 > b ? null : n(a) ? a.charAt(b) : a[b];\n}\nfunction ab(a) {\n  return B.concat.apply(B, arguments);\n}\nfunction bb(a) {\n  var b = a.length;\n  if (0 < b) {\n    for (var c = Array(b), d = 0;d < b;d++) {\n      c[d] = a[d];\n    }\n    return c;\n  }\n  return[];\n}\n;function cb(a, b) {\n  this.O = {};\n  this.j = [];\n  this.o = 0;\n  var c = arguments.length;\n  if (1 < c) {\n    if (c % 2) {\n      throw Error(\"Uneven number of arguments\");\n    }\n    for (var d = 0;d < c;d += 2) {\n      this.set(arguments[d], arguments[d + 1]);\n    }\n  } else {\n    if (a) {\n      a instanceof cb ? (c = a.ca(), d = a.N()) : (c = Ua(a), d = Ta(a));\n      for (var e = 0;e < c.length;e++) {\n        this.set(c[e], d[e]);\n      }\n    }\n  }\n}\nf = cb.prototype;\nf.N = function() {\n  db(this);\n  for (var a = [], b = 0;b < this.j.length;b++) {\n    a.push(this.O[this.j[b]]);\n  }\n  return a;\n};\nf.ca = function() {\n  db(this);\n  return this.j.concat();\n};\nf.wa = function(a) {\n  return C(this.O, a);\n};\nf.remove = function(a) {\n  return C(this.O, a) ? (delete this.O[a], this.o--, this.j.length > 2 * this.o && db(this), !0) : !1;\n};\nfunction db(a) {\n  if (a.o != a.j.length) {\n    for (var b = 0, c = 0;b < a.j.length;) {\n      var d = a.j[b];\n      C(a.O, d) && (a.j[c++] = d);\n      b++;\n    }\n    a.j.length = c;\n  }\n  if (a.o != a.j.length) {\n    for (var e = {}, c = b = 0;b < a.j.length;) {\n      d = a.j[b], C(e, d) || (a.j[c++] = d, e[d] = 1), b++;\n    }\n    a.j.length = c;\n  }\n}\nf.get = function(a, b) {\n  return C(this.O, a) ? this.O[a] : b;\n};\nf.set = function(a, b) {\n  C(this.O, a) || (this.o++, this.j.push(a));\n  this.O[a] = b;\n};\nf.n = function() {\n  return new cb(this);\n};\nfunction C(a, b) {\n  return Object.prototype.hasOwnProperty.call(a, b);\n}\n;function eb(a) {\n  if (\"function\" == typeof a.N) {\n    return a.N();\n  }\n  if (n(a)) {\n    return a.split(\"\");\n  }\n  if (ea(a)) {\n    for (var b = [], c = a.length, d = 0;d < c;d++) {\n      b.push(a[d]);\n    }\n    return b;\n  }\n  return Ta(a);\n}\nfunction D(a, b, c) {\n  if (\"function\" == typeof a.forEach) {\n    a.forEach(b, c);\n  } else {\n    if (ea(a) || n(a)) {\n      Ya(a, b, c);\n    } else {\n      var d;\n      if (\"function\" == typeof a.ca) {\n        d = a.ca();\n      } else {\n        if (\"function\" != typeof a.N) {\n          if (ea(a) || n(a)) {\n            d = [];\n            for (var e = a.length, g = 0;g < e;g++) {\n              d.push(g);\n            }\n          } else {\n            d = Ua(a);\n          }\n        } else {\n          d = void 0;\n        }\n      }\n      for (var e = eb(a), g = e.length, h = 0;h < g;h++) {\n        b.call(c, e[h], d && d[h], a);\n      }\n    }\n  }\n}\n;function E(a, b) {\n  var c;\n  if (a instanceof E) {\n    this.D = void 0 !== b ? b : a.D, fb(this, a.oa), c = a.eb, F(this), this.eb = c, gb(this, a.ja), hb(this, a.Ca), ib(this, a.I), jb(this, a.R.n()), c = a.Na, F(this), this.Na = c;\n  } else {\n    if (a && (c = Ra(String(a)))) {\n      this.D = !!b;\n      fb(this, c[1] || \"\", !0);\n      var d = c[2] || \"\";\n      F(this);\n      this.eb = d ? decodeURIComponent(d) : \"\";\n      gb(this, c[3] || \"\", !0);\n      hb(this, c[4]);\n      ib(this, c[5] || \"\", !0);\n      jb(this, c[6] || \"\", !0);\n      c = c[7] || \"\";\n      F(this);\n      this.Na = c ? decodeURIComponent(c) : \"\";\n    } else {\n      this.D = !!b, this.R = new kb(null, 0, this.D);\n    }\n  }\n}\nf = E.prototype;\nf.oa = \"\";\nf.eb = \"\";\nf.ja = \"\";\nf.Ca = null;\nf.I = \"\";\nf.Na = \"\";\nf.oc = !1;\nf.D = !1;\nf.toString = function() {\n  var a = [], b = this.oa;\n  b && a.push(lb(b, mb), \":\");\n  if (b = this.ja) {\n    a.push(\"//\");\n    var c = this.eb;\n    c && a.push(lb(c, mb), \"@\");\n    a.push(encodeURIComponent(String(b)));\n    b = this.Ca;\n    null != b && a.push(\":\", String(b));\n  }\n  if (b = this.I) {\n    this.ja && \"/\" != b.charAt(0) && a.push(\"/\"), a.push(lb(b, \"/\" == b.charAt(0) ? nb : ob));\n  }\n  (b = this.R.toString()) && a.push(\"?\", b);\n  (b = this.Na) && a.push(\"#\", lb(b, pb));\n  return a.join(\"\");\n};\nf.n = function() {\n  return new E(this);\n};\nfunction fb(a, b, c) {\n  F(a);\n  a.oa = c ? b ? decodeURIComponent(b) : \"\" : b;\n  a.oa && (a.oa = a.oa.replace(/:$/, \"\"));\n}\nfunction gb(a, b, c) {\n  F(a);\n  a.ja = c ? b ? decodeURIComponent(b) : \"\" : b;\n}\nfunction hb(a, b) {\n  F(a);\n  if (b) {\n    b = Number(b);\n    if (isNaN(b) || 0 > b) {\n      throw Error(\"Bad port number \" + b);\n    }\n    a.Ca = b;\n  } else {\n    a.Ca = null;\n  }\n}\nfunction ib(a, b, c) {\n  F(a);\n  a.I = c ? b ? decodeURIComponent(b) : \"\" : b;\n}\nfunction jb(a, b, c) {\n  F(a);\n  b instanceof kb ? (a.R = b, a.R.ub(a.D)) : (c || (b = lb(b, qb)), a.R = new kb(b, 0, a.D));\n}\nfunction G(a, b, c) {\n  F(a);\n  a.R.set(b, c);\n}\nfunction rb(a, b, c) {\n  F(a);\n  m(c) || (c = [String(c)]);\n  sb(a.R, b, c);\n}\nfunction H(a) {\n  F(a);\n  G(a, \"zx\", sa());\n  return a;\n}\nfunction F(a) {\n  if (a.oc) {\n    throw Error(\"Tried to modify a read-only Uri\");\n  }\n}\nf.ub = function(a) {\n  this.D = a;\n  this.R && this.R.ub(a);\n  return this;\n};\nfunction tb(a) {\n  return a instanceof E ? a.n() : new E(a, void 0);\n}\nfunction ub(a, b, c, d) {\n  var e = new E(null, void 0);\n  a && fb(e, a);\n  b && gb(e, b);\n  c && hb(e, c);\n  d && ib(e, d);\n  return e;\n}\nfunction lb(a, b) {\n  return n(a) ? encodeURI(a).replace(b, vb) : null;\n}\nfunction vb(a) {\n  a = a.charCodeAt(0);\n  return \"%\" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);\n}\nvar mb = /[#\\/\\?@]/g, ob = /[\\#\\?:]/g, nb = /[\\#\\?]/g, qb = /[\\#\\?@]/g, pb = /#/g;\nfunction kb(a, b, c) {\n  this.C = a || null;\n  this.D = !!c;\n}\nfunction I(a) {\n  if (!a.h && (a.h = new cb, a.o = 0, a.C)) {\n    for (var b = a.C.split(\"&\"), c = 0;c < b.length;c++) {\n      var d = b[c].indexOf(\"=\"), e = null, g = null;\n      0 <= d ? (e = b[c].substring(0, d), g = b[c].substring(d + 1)) : e = b[c];\n      e = decodeURIComponent(e.replace(/\\+/g, \" \"));\n      e = J(a, e);\n      a.add(e, g ? decodeURIComponent(g.replace(/\\+/g, \" \")) : \"\");\n    }\n  }\n}\nf = kb.prototype;\nf.h = null;\nf.o = null;\nf.add = function(a, b) {\n  I(this);\n  this.C = null;\n  a = J(this, a);\n  var c = this.h.get(a);\n  c || this.h.set(a, c = []);\n  c.push(b);\n  this.o++;\n  return this;\n};\nf.remove = function(a) {\n  I(this);\n  a = J(this, a);\n  return this.h.wa(a) ? (this.C = null, this.o -= this.h.get(a).length, this.h.remove(a)) : !1;\n};\nf.wa = function(a) {\n  I(this);\n  a = J(this, a);\n  return this.h.wa(a);\n};\nf.ca = function() {\n  I(this);\n  for (var a = this.h.N(), b = this.h.ca(), c = [], d = 0;d < b.length;d++) {\n    for (var e = a[d], g = 0;g < e.length;g++) {\n      c.push(b[d]);\n    }\n  }\n  return c;\n};\nf.N = function(a) {\n  I(this);\n  var b = [];\n  if (n(a)) {\n    this.wa(a) && (b = ab(b, this.h.get(J(this, a))));\n  } else {\n    a = this.h.N();\n    for (var c = 0;c < a.length;c++) {\n      b = ab(b, a[c]);\n    }\n  }\n  return b;\n};\nf.set = function(a, b) {\n  I(this);\n  this.C = null;\n  a = J(this, a);\n  this.wa(a) && (this.o -= this.h.get(a).length);\n  this.h.set(a, [b]);\n  this.o++;\n  return this;\n};\nf.get = function(a, b) {\n  var c = a ? this.N(a) : [];\n  return 0 < c.length ? String(c[0]) : b;\n};\nfunction sb(a, b, c) {\n  a.remove(b);\n  0 < c.length && (a.C = null, a.h.set(J(a, b), bb(c)), a.o += c.length);\n}\nf.toString = function() {\n  if (this.C) {\n    return this.C;\n  }\n  if (!this.h) {\n    return \"\";\n  }\n  for (var a = [], b = this.h.ca(), c = 0;c < b.length;c++) {\n    for (var d = b[c], e = encodeURIComponent(String(d)), d = this.N(d), g = 0;g < d.length;g++) {\n      var h = e;\n      \"\" !== d[g] && (h += \"=\" + encodeURIComponent(String(d[g])));\n      a.push(h);\n    }\n  }\n  return this.C = a.join(\"&\");\n};\nf.n = function() {\n  var a = new kb;\n  a.C = this.C;\n  this.h && (a.h = this.h.n(), a.o = this.o);\n  return a;\n};\nfunction J(a, b) {\n  var c = String(b);\n  a.D && (c = c.toLowerCase());\n  return c;\n}\nf.ub = function(a) {\n  a && !this.D && (I(this), this.C = null, D(this.h, function(a, c) {\n    var d = c.toLowerCase();\n    c != d && (this.remove(c), sb(this, d, a));\n  }, this));\n  this.D = a;\n};\nfunction wb(a) {\n  a = String(a);\n  if (/^\\s*$/.test(a) ? 0 : /^[\\],:{}\\s\\u2028\\u2029]*$/.test(a.replace(/\\\\[\"\\\\\\/bfnrtu]/g, \"@\").replace(/\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\").replace(/(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g, \"\"))) {\n    try {\n      return eval(\"(\" + a + \")\");\n    } catch (b) {\n    }\n  }\n  throw Error(\"Invalid JSON string: \" + a);\n}\nfunction xb(a) {\n  return eval(\"(\" + a + \")\");\n}\nfunction yb(a) {\n  var b = [];\n  zb(new Ab, a, b);\n  return b.join(\"\");\n}\nfunction Ab() {\n  this.Ya = void 0;\n}\nfunction zb(a, b, c) {\n  switch(typeof b) {\n    case \"string\":\n      Bb(b, c);\n      break;\n    case \"number\":\n      c.push(isFinite(b) && !isNaN(b) ? b : \"null\");\n      break;\n    case \"boolean\":\n      c.push(b);\n      break;\n    case \"undefined\":\n      c.push(\"null\");\n      break;\n    case \"object\":\n      if (null == b) {\n        c.push(\"null\");\n        break;\n      }\n      if (m(b)) {\n        var d = b.length;\n        c.push(\"[\");\n        for (var e = \"\", g = 0;g < d;g++) {\n          c.push(e), e = b[g], zb(a, a.Ya ? a.Ya.call(b, String(g), e) : e, c), e = \",\";\n        }\n        c.push(\"]\");\n        break;\n      }\n      c.push(\"{\");\n      d = \"\";\n      for (g in b) {\n        Object.prototype.hasOwnProperty.call(b, g) && (e = b[g], \"function\" != typeof e && (c.push(d), Bb(g, c), c.push(\":\"), zb(a, a.Ya ? a.Ya.call(b, g, e) : e, c), d = \",\"));\n      }\n      c.push(\"}\");\n      break;\n    case \"function\":\n      break;\n    default:\n      throw Error(\"Unknown type: \" + typeof b);;\n  }\n}\nvar Cb = {'\"':'\\\\\"', \"\\\\\":\"\\\\\\\\\", \"/\":\"\\\\/\", \"\\b\":\"\\\\b\", \"\\f\":\"\\\\f\", \"\\n\":\"\\\\n\", \"\\r\":\"\\\\r\", \"\\t\":\"\\\\t\", \"\\x0B\":\"\\\\u000b\"}, Db = /\\uffff/.test(\"\\uffff\") ? /[\\\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g : /[\\\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\nfunction Bb(a, b) {\n  b.push('\"', a.replace(Db, function(a) {\n    if (a in Cb) {\n      return Cb[a];\n    }\n    var b = a.charCodeAt(0), e = \"\\\\u\";\n    16 > b ? e += \"000\" : 256 > b ? e += \"00\" : 4096 > b && (e += \"0\");\n    return Cb[a] = e + b.toString(16);\n  }), '\"');\n}\n;function Eb(a) {\n  return Fb(a || arguments.callee.caller, []);\n}\nfunction Fb(a, b) {\n  var c = [];\n  if (0 <= Xa(b, a)) {\n    c.push(\"[...circular reference...]\");\n  } else {\n    if (a && 50 > b.length) {\n      c.push(Gb(a) + \"(\");\n      for (var d = a.arguments, e = 0;e < d.length;e++) {\n        0 < e && c.push(\", \");\n        var g;\n        g = d[e];\n        switch(typeof g) {\n          case \"object\":\n            g = g ? \"object\" : \"null\";\n            break;\n          case \"string\":\n            break;\n          case \"number\":\n            g = String(g);\n            break;\n          case \"boolean\":\n            g = g ? \"true\" : \"false\";\n            break;\n          case \"function\":\n            g = (g = Gb(g)) ? g : \"[fn]\";\n            break;\n          default:\n            g = typeof g;\n        }\n        40 < g.length && (g = g.substr(0, 40) + \"...\");\n        c.push(g);\n      }\n      b.push(a);\n      c.push(\")\\n\");\n      try {\n        c.push(Fb(a.caller, b));\n      } catch (h) {\n        c.push(\"[exception trying to get caller]\\n\");\n      }\n    } else {\n      a ? c.push(\"[...long stack...]\") : c.push(\"[end]\");\n    }\n  }\n  return c.join(\"\");\n}\nfunction Gb(a) {\n  if (Hb[a]) {\n    return Hb[a];\n  }\n  a = String(a);\n  if (!Hb[a]) {\n    var b = /function ([^\\(]+)/.exec(a);\n    Hb[a] = b ? b[1] : \"[Anonymous]\";\n  }\n  return Hb[a];\n}\nvar Hb = {};\nfunction Ib(a, b, c, d, e) {\n  this.reset(a, b, c, d, e);\n}\nIb.prototype.Fb = null;\nIb.prototype.Eb = null;\nvar Jb = 0;\nIb.prototype.reset = function(a, b, c, d, e) {\n  \"number\" == typeof e || Jb++;\n  d || q();\n  this.Aa = a;\n  this.qc = b;\n  delete this.Fb;\n  delete this.Eb;\n};\nIb.prototype.$b = function(a) {\n  this.Aa = a;\n};\nfunction L(a) {\n  this.rc = a;\n}\nL.prototype.Sa = null;\nL.prototype.Aa = null;\nL.prototype.jb = null;\nL.prototype.Jb = null;\nfunction Kb(a, b) {\n  this.name = a;\n  this.value = b;\n}\nKb.prototype.toString = function() {\n  return this.name;\n};\nvar Lb = new Kb(\"SEVERE\", 1E3), Mb = new Kb(\"WARNING\", 900), Nb = new Kb(\"INFO\", 800), Ob = new Kb(\"CONFIG\", 700), Pb = new Kb(\"FINE\", 500);\nf = L.prototype;\nf.getParent = function() {\n  return this.Sa;\n};\nf.$b = function(a) {\n  this.Aa = a;\n};\nfunction Qb(a) {\n  if (a.Aa) {\n    return a.Aa;\n  }\n  if (a.Sa) {\n    return Qb(a.Sa);\n  }\n  Pa(\"Root logger has no level set.\");\n  return null;\n}\nf.log = function(a, b, c) {\n  if (a.value >= Qb(this).value) {\n    for (fa(b) && (b = b()), a = this.mc(a, b, c), b = \"log:\" + a.qc, l.console && (l.console.timeStamp ? l.console.timeStamp(b) : l.console.markTimeline && l.console.markTimeline(b)), l.msWriteProfilerMark && l.msWriteProfilerMark(b), b = this;b;) {\n      c = b;\n      var d = a;\n      if (c.Jb) {\n        for (var e = 0, g = void 0;g = c.Jb[e];e++) {\n          g(d);\n        }\n      }\n      b = b.getParent();\n    }\n  }\n};\nf.mc = function(a, b, c) {\n  var d = new Ib(a, String(b), this.rc);\n  if (c) {\n    d.Fb = c;\n    var e;\n    var g = arguments.callee.caller;\n    try {\n      var h;\n      var k = ba(\"window.location.href\");\n      if (n(c)) {\n        h = {message:c, name:\"Unknown error\", lineNumber:\"Not available\", fileName:k, stack:\"Not available\"};\n      } else {\n        var u, K, v = !1;\n        try {\n          u = c.lineNumber || c.Ic || \"Not available\";\n        } catch (r) {\n          u = \"Not available\", v = !0;\n        }\n        try {\n          K = c.fileName || c.filename || c.sourceURL || l.$googDebugFname || k;\n        } catch (Ka) {\n          K = \"Not available\", v = !0;\n        }\n        h = !v && c.lineNumber && c.fileName && c.stack && c.message && c.name ? c : {message:c.message || \"Not available\", name:c.name || \"UnknownError\", lineNumber:u, fileName:K, stack:c.stack || \"Not available\"};\n      }\n      e = \"Message: \" + la(h.message) + '\\nUrl: <a href=\"view-source:' + h.fileName + '\" target=\"_new\">' + h.fileName + \"</a>\\nLine: \" + h.lineNumber + \"\\n\\nBrowser stack:\\n\" + la(h.stack + \"-> \") + \"[end]\\n\\nJS stack traversal:\\n\" + la(Eb(g) + \"-> \");\n    } catch (w) {\n      e = \"Exception trying to expose exception! You win, we lose. \" + w;\n    }\n    d.Eb = e;\n  }\n  return d;\n};\nf.J = function(a, b) {\n  this.log(Lb, a, b);\n};\nf.Z = function(a, b) {\n  this.log(Mb, a, b);\n};\nf.info = function(a, b) {\n  this.log(Nb, a, b);\n};\nvar Rb = {}, Sb = null;\nfunction Tb(a) {\n  Sb || (Sb = new L(\"\"), Rb[\"\"] = Sb, Sb.$b(Ob));\n  var b;\n  if (!(b = Rb[a])) {\n    b = new L(a);\n    var c = a.lastIndexOf(\".\"), d = a.substr(c + 1), c = Tb(a.substr(0, c));\n    c.jb || (c.jb = {});\n    c.jb[d] = b;\n    b.Sa = c;\n    Rb[a] = b;\n  }\n  return b;\n}\n;function M(a, b) {\n  a && a.log(Pb, b, void 0);\n}\n;function N() {\n  this.r = Tb(\"goog.net.BrowserChannel\");\n}\nfunction Ub(a, b, c, d) {\n  a.info(\"XMLHTTP TEXT (\" + b + \"): \" + Vb(a, c) + (d ? \" \" + d : \"\"));\n}\nN.prototype.debug = function(a) {\n  this.info(a);\n};\nfunction Wb(a, b, c) {\n  a.J((c || \"Exception\") + b);\n}\nN.prototype.info = function(a) {\n  var b = this.r;\n  b && b.info(a, void 0);\n};\nN.prototype.Z = function(a) {\n  var b = this.r;\n  b && b.Z(a, void 0);\n};\nN.prototype.J = function(a) {\n  var b = this.r;\n  b && b.J(a, void 0);\n};\nfunction Vb(a, b) {\n  if (!b || b == Xb) {\n    return b;\n  }\n  try {\n    var c = xb(b);\n    if (c) {\n      for (var d = 0;d < c.length;d++) {\n        if (m(c[d])) {\n          var e = c[d];\n          if (!(2 > e.length)) {\n            var g = e[1];\n            if (m(g) && !(1 > g.length)) {\n              var h = g[0];\n              if (\"noop\" != h && \"stop\" != h) {\n                for (var k = 1;k < g.length;k++) {\n                  g[k] = \"\";\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return yb(c);\n  } catch (u) {\n    return a.debug(\"Exception parsing expected JS array - probably was not JS\"), b;\n  }\n}\n;function Yb(a, b) {\n  this.P = b ? xb : wb;\n}\nYb.prototype.parse = function(a) {\n  return this.P(a);\n};\nfunction O() {\n  0 != Zb && ($b[this[ga] || (this[ga] = ++ha)] = this);\n}\nvar Zb = 0, $b = {};\nO.prototype.mb = !1;\nO.prototype.Ja = function() {\n  if (!this.mb && (this.mb = !0, this.u(), 0 != Zb)) {\n    var a = this[ga] || (this[ga] = ++ha);\n    delete $b[a];\n  }\n};\nO.prototype.u = function() {\n  if (this.Pb) {\n    for (;this.Pb.length;) {\n      this.Pb.shift()();\n    }\n  }\n};\nvar ac = \"closure_listenable_\" + (1E6 * Math.random() | 0);\nfunction bc(a) {\n  try {\n    return!(!a || !a[ac]);\n  } catch (b) {\n    return!1;\n  }\n}\nvar cc = 0;\nfunction dc(a, b, c, d, e) {\n  this.fa = a;\n  this.Ua = null;\n  this.src = b;\n  this.type = c;\n  this.capture = !!d;\n  this.Oa = e;\n  this.key = ++cc;\n  this.na = this.Ia = !1;\n}\nfunction ec(a) {\n  a.na = !0;\n  a.fa = null;\n  a.Ua = null;\n  a.src = null;\n  a.Oa = null;\n}\n;function P(a) {\n  this.src = a;\n  this.s = {};\n  this.Ga = 0;\n}\nP.prototype.add = function(a, b, c, d, e) {\n  var g = this.s[a];\n  g || (g = this.s[a] = [], this.Ga++);\n  var h = fc(g, b, d, e);\n  -1 < h ? (a = g[h], c || (a.Ia = !1)) : (a = new dc(b, this.src, a, !!d, e), a.Ia = c, g.push(a));\n  return a;\n};\nP.prototype.remove = function(a, b, c, d) {\n  if (!(a in this.s)) {\n    return!1;\n  }\n  var e = this.s[a];\n  b = fc(e, b, c, d);\n  return-1 < b ? (ec(e[b]), B.splice.call(e, b, 1), 0 == e.length && (delete this.s[a], this.Ga--), !0) : !1;\n};\nfunction gc(a, b) {\n  var c = b.type;\n  if (!(c in a.s)) {\n    return!1;\n  }\n  var d = a.s[c], e = Xa(d, b), g;\n  (g = 0 <= e) && B.splice.call(d, e, 1);\n  g && (ec(b), 0 == a.s[c].length && (delete a.s[c], a.Ga--));\n  return g;\n}\nP.prototype.Xa = function(a) {\n  var b = 0, c;\n  for (c in this.s) {\n    if (!a || c == a) {\n      for (var d = this.s[c], e = 0;e < d.length;e++) {\n        ++b, ec(d[e]);\n      }\n      delete this.s[c];\n      this.Ga--;\n    }\n  }\n  return b;\n};\nP.prototype.ya = function(a, b, c, d) {\n  a = this.s[a];\n  var e = -1;\n  a && (e = fc(a, b, c, d));\n  return-1 < e ? a[e] : null;\n};\nfunction fc(a, b, c, d) {\n  for (var e = 0;e < a.length;++e) {\n    var g = a[e];\n    if (!g.na && g.fa == b && g.capture == !!c && g.Oa == d) {\n      return e;\n    }\n  }\n  return-1;\n}\n;var hc = !y || y && 9 <= Ma, ic = y && !A(\"9\");\n!z || A(\"528\");\nBa && A(\"1.9b\") || y && A(\"8\") || Aa && A(\"9.5\") || z && A(\"528\");\nBa && !A(\"8\") || y && A(\"9\");\nfunction Q(a, b) {\n  this.type = a;\n  this.currentTarget = this.target = b;\n}\nf = Q.prototype;\nf.u = function() {\n};\nf.Ja = function() {\n};\nf.ga = !1;\nf.defaultPrevented = !1;\nf.Yb = !0;\nf.preventDefault = function() {\n  this.defaultPrevented = !0;\n  this.Yb = !1;\n};\nfunction jc(a) {\n  jc[\" \"](a);\n  return a;\n}\njc[\" \"] = ca;\nfunction kc(a, b) {\n  Q.call(this, a ? a.type : \"\");\n  this.relatedTarget = this.currentTarget = this.target = null;\n  this.charCode = this.keyCode = this.button = this.screenY = this.screenX = this.clientY = this.clientX = this.offsetY = this.offsetX = 0;\n  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;\n  this.Db = this.state = null;\n  if (a) {\n    var c = this.type = a.type;\n    this.target = a.target || a.srcElement;\n    this.currentTarget = b;\n    var d = a.relatedTarget;\n    if (d) {\n      if (Ba) {\n        var e;\n        a: {\n          try {\n            jc(d.nodeName);\n            e = !0;\n            break a;\n          } catch (g) {\n          }\n          e = !1;\n        }\n        e || (d = null);\n      }\n    } else {\n      \"mouseover\" == c ? d = a.fromElement : \"mouseout\" == c && (d = a.toElement);\n    }\n    this.relatedTarget = d;\n    this.offsetX = z || void 0 !== a.offsetX ? a.offsetX : a.layerX;\n    this.offsetY = z || void 0 !== a.offsetY ? a.offsetY : a.layerY;\n    this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX;\n    this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY;\n    this.screenX = a.screenX || 0;\n    this.screenY = a.screenY || 0;\n    this.button = a.button;\n    this.keyCode = a.keyCode || 0;\n    this.charCode = a.charCode || (\"keypress\" == c ? a.keyCode : 0);\n    this.ctrlKey = a.ctrlKey;\n    this.altKey = a.altKey;\n    this.shiftKey = a.shiftKey;\n    this.metaKey = a.metaKey;\n    this.state = a.state;\n    this.Db = a;\n    a.defaultPrevented && this.preventDefault();\n    delete this.ga;\n  }\n}\ns(kc, Q);\nkc.prototype.preventDefault = function() {\n  kc.pa.preventDefault.call(this);\n  var a = this.Db;\n  if (a.preventDefault) {\n    a.preventDefault();\n  } else {\n    if (a.returnValue = !1, ic) {\n      try {\n        if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {\n          a.keyCode = -1;\n        }\n      } catch (b) {\n      }\n    }\n  }\n};\nkc.prototype.u = function() {\n};\nvar lc = \"closure_lm_\" + (1E6 * Math.random() | 0), mc = {}, nc = 0;\nfunction oc(a, b, c, d, e) {\n  if (m(b)) {\n    for (var g = 0;g < b.length;g++) {\n      oc(a, b[g], c, d, e);\n    }\n    return null;\n  }\n  c = pc(c);\n  if (bc(a)) {\n    a = a.Ra(b, c, d, e);\n  } else {\n    if (!b) {\n      throw Error(\"Invalid event type\");\n    }\n    var g = !!d, h = qc(a);\n    h || (a[lc] = h = new P(a));\n    c = h.add(b, c, !1, d, e);\n    c.Ua || (d = rc(), c.Ua = d, d.src = a, d.fa = c, a.addEventListener ? a.addEventListener(b, d, g) : a.attachEvent(b in mc ? mc[b] : mc[b] = \"on\" + b, d), nc++);\n    a = c;\n  }\n  return a;\n}\nfunction rc() {\n  var a = sc, b = hc ? function(c) {\n    return a.call(b.src, b.fa, c);\n  } : function(c) {\n    c = a.call(b.src, b.fa, c);\n    if (!c) {\n      return c;\n    }\n  };\n  return b;\n}\nfunction tc(a, b, c, d, e) {\n  if (m(b)) {\n    for (var g = 0;g < b.length;g++) {\n      tc(a, b[g], c, d, e);\n    }\n  } else {\n    c = pc(c), bc(a) ? a.vb(b, c, d, e) : a && (a = qc(a)) && (b = a.ya(b, c, !!d, e)) && uc(b);\n  }\n}\nfunction uc(a) {\n  if (\"number\" == typeof a || !a || a.na) {\n    return!1;\n  }\n  var b = a.src;\n  if (bc(b)) {\n    return gc(b.W, a);\n  }\n  var c = a.type, d = a.Ua;\n  b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent && b.detachEvent(c in mc ? mc[c] : mc[c] = \"on\" + c, d);\n  nc--;\n  (c = qc(b)) ? (gc(c, a), 0 == c.Ga && (c.src = null, b[lc] = null)) : ec(a);\n  return!0;\n}\nfunction vc(a, b, c, d) {\n  var e = 1;\n  if (a = qc(a)) {\n    if (b = a.s[b]) {\n      for (b = bb(b), a = 0;a < b.length;a++) {\n        var g = b[a];\n        g && g.capture == c && !g.na && (e &= !1 !== wc(g, d));\n      }\n    }\n  }\n  return Boolean(e);\n}\nfunction wc(a, b) {\n  var c = a.fa, d = a.Oa || a.src;\n  a.Ia && uc(a);\n  return c.call(d, b);\n}\nfunction sc(a, b) {\n  if (a.na) {\n    return!0;\n  }\n  if (!hc) {\n    var c = b || ba(\"window.event\"), d = new kc(c, this), e = !0;\n    if (!(0 > c.keyCode || void 0 != c.returnValue)) {\n      a: {\n        var g = !1;\n        if (0 == c.keyCode) {\n          try {\n            c.keyCode = -1;\n            break a;\n          } catch (h) {\n            g = !0;\n          }\n        }\n        if (g || void 0 == c.returnValue) {\n          c.returnValue = !0;\n        }\n      }\n      c = [];\n      for (g = d.currentTarget;g;g = g.parentNode) {\n        c.push(g);\n      }\n      for (var g = a.type, k = c.length - 1;!d.ga && 0 <= k;k--) {\n        d.currentTarget = c[k], e &= vc(c[k], g, !0, d);\n      }\n      for (k = 0;!d.ga && k < c.length;k++) {\n        d.currentTarget = c[k], e &= vc(c[k], g, !1, d);\n      }\n    }\n    return e;\n  }\n  return wc(a, new kc(b, this));\n}\nfunction qc(a) {\n  a = a[lc];\n  return a instanceof P ? a : null;\n}\nvar xc = \"__closure_events_fn_\" + (1E9 * Math.random() >>> 0);\nfunction pc(a) {\n  return fa(a) ? a : a[xc] || (a[xc] = function(b) {\n    return a.handleEvent(b);\n  });\n}\n;function R() {\n  O.call(this);\n  this.W = new P(this);\n  this.fc = this;\n}\ns(R, O);\nR.prototype[ac] = !0;\nf = R.prototype;\nf.tb = null;\nf.addEventListener = function(a, b, c, d) {\n  oc(this, a, b, c, d);\n};\nf.removeEventListener = function(a, b, c, d) {\n  tc(this, a, b, c, d);\n};\nf.dispatchEvent = function(a) {\n  var b, c = this.tb;\n  if (c) {\n    for (b = [];c;c = c.tb) {\n      b.push(c);\n    }\n  }\n  var c = this.fc, d = a.type || a;\n  if (n(a)) {\n    a = new Q(a, c);\n  } else {\n    if (a instanceof Q) {\n      a.target = a.target || c;\n    } else {\n      var e = a;\n      a = new Q(d, c);\n      Wa(a, e);\n    }\n  }\n  var e = !0, g;\n  if (b) {\n    for (var h = b.length - 1;!a.ga && 0 <= h;h--) {\n      g = a.currentTarget = b[h], e = yc(g, d, !0, a) && e;\n    }\n  }\n  a.ga || (g = a.currentTarget = c, e = yc(g, d, !0, a) && e, a.ga || (e = yc(g, d, !1, a) && e));\n  if (b) {\n    for (h = 0;!a.ga && h < b.length;h++) {\n      g = a.currentTarget = b[h], e = yc(g, d, !1, a) && e;\n    }\n  }\n  return e;\n};\nf.u = function() {\n  R.pa.u.call(this);\n  this.W && this.W.Xa(void 0);\n  this.tb = null;\n};\nf.Ra = function(a, b, c, d) {\n  return this.W.add(String(a), b, !1, c, d);\n};\nf.vb = function(a, b, c, d) {\n  return this.W.remove(String(a), b, c, d);\n};\nfunction yc(a, b, c, d) {\n  b = a.W.s[String(b)];\n  if (!b) {\n    return!0;\n  }\n  b = bb(b);\n  for (var e = !0, g = 0;g < b.length;++g) {\n    var h = b[g];\n    if (h && !h.na && h.capture == c) {\n      var k = h.fa, u = h.Oa || h.src;\n      h.Ia && gc(a.W, h);\n      e = !1 !== k.call(u, d) && e;\n    }\n  }\n  return e && !1 != d.Yb;\n}\nf.ya = function(a, b, c, d) {\n  return this.W.ya(String(a), b, c, d);\n};\nfunction zc(a, b) {\n  R.call(this);\n  this.ea = a || 1;\n  this.ra = b || l;\n  this.ib = p(this.Gc, this);\n  this.sb = q();\n}\ns(zc, R);\nf = zc.prototype;\nf.enabled = !1;\nf.l = null;\nf.setInterval = function(a) {\n  this.ea = a;\n  this.l && this.enabled ? (this.stop(), this.start()) : this.l && this.stop();\n};\nf.Gc = function() {\n  if (this.enabled) {\n    var a = q() - this.sb;\n    0 < a && a < 0.8 * this.ea ? this.l = this.ra.setTimeout(this.ib, this.ea - a) : (this.l && (this.ra.clearTimeout(this.l), this.l = null), this.dispatchEvent(Ac), this.enabled && (this.l = this.ra.setTimeout(this.ib, this.ea), this.sb = q()));\n  }\n};\nf.start = function() {\n  this.enabled = !0;\n  this.l || (this.l = this.ra.setTimeout(this.ib, this.ea), this.sb = q());\n};\nf.stop = function() {\n  this.enabled = !1;\n  this.l && (this.ra.clearTimeout(this.l), this.l = null);\n};\nf.u = function() {\n  zc.pa.u.call(this);\n  this.stop();\n  delete this.ra;\n};\nvar Ac = \"tick\";\nfunction Bc(a, b, c) {\n  if (fa(a)) {\n    c && (a = p(a, c));\n  } else {\n    if (a && \"function\" == typeof a.handleEvent) {\n      a = p(a.handleEvent, a);\n    } else {\n      throw Error(\"Invalid listener argument\");\n    }\n  }\n  return 2147483647 < b ? -1 : l.setTimeout(a, b || 0);\n}\n;function Cc() {\n}\nCc.prototype.Ab = null;\nfunction Dc(a) {\n  var b;\n  (b = a.Ab) || (b = {}, Ec(a) && (b[0] = !0, b[1] = !0), b = a.Ab = b);\n  return b;\n}\n;var Fc;\nfunction Gc() {\n}\ns(Gc, Cc);\nfunction Hc(a) {\n  return(a = Ec(a)) ? new ActiveXObject(a) : new XMLHttpRequest;\n}\nfunction Ec(a) {\n  if (!a.Kb && \"undefined\" == typeof XMLHttpRequest && \"undefined\" != typeof ActiveXObject) {\n    for (var b = [\"MSXML2.XMLHTTP.6.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\"], c = 0;c < b.length;c++) {\n      var d = b[c];\n      try {\n        return new ActiveXObject(d), a.Kb = d;\n      } catch (e) {\n      }\n    }\n    throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");\n  }\n  return a.Kb;\n}\nFc = new Gc;\nfunction Ic(a) {\n  R.call(this);\n  this.headers = new cb;\n  this.gb = a || null;\n  this.T = !1;\n  this.fb = this.f = null;\n  this.Mb = this.Qa = \"\";\n  this.ka = 0;\n  this.q = \"\";\n  this.da = this.qb = this.Pa = this.nb = !1;\n  this.Fa = 0;\n  this.bb = null;\n  this.Xb = Jc;\n  this.cb = this.dc = !1;\n}\ns(Ic, R);\nvar Jc = \"\";\nIc.prototype.r = Tb(\"goog.net.XhrIo\");\nvar Kc = /^https?$/i, Lc = [\"POST\", \"PUT\"];\nf = Ic.prototype;\nf.send = function(a, b, c, d) {\n  if (this.f) {\n    throw Error(\"[goog.net.XhrIo] Object is active with another request=\" + this.Qa + \"; newUri=\" + a);\n  }\n  b = b ? b.toUpperCase() : \"GET\";\n  this.Qa = a;\n  this.q = \"\";\n  this.ka = 0;\n  this.Mb = b;\n  this.nb = !1;\n  this.T = !0;\n  this.f = this.gb ? Hc(this.gb) : Hc(Fc);\n  this.fb = this.gb ? Dc(this.gb) : Dc(Fc);\n  this.f.onreadystatechange = p(this.Qb, this);\n  try {\n    M(this.r, S(this, \"Opening Xhr\")), this.qb = !0, this.f.open(b, a, !0), this.qb = !1;\n  } catch (e) {\n    M(this.r, S(this, \"Error opening Xhr: \" + e.message));\n    Mc(this, e);\n    return;\n  }\n  a = c || \"\";\n  var g = this.headers.n();\n  d && D(d, function(a, b) {\n    g.set(b, a);\n  });\n  d = Za(g.ca());\n  c = l.FormData && a instanceof l.FormData;\n  !(0 <= Xa(Lc, b)) || d || c || g.set(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\");\n  D(g, function(a, b) {\n    this.f.setRequestHeader(b, a);\n  }, this);\n  this.Xb && (this.f.responseType = this.Xb);\n  \"withCredentials\" in this.f && (this.f.withCredentials = this.dc);\n  try {\n    Nc(this), 0 < this.Fa && (this.cb = Oc(this.f), M(this.r, S(this, \"Will abort after \" + this.Fa + \"ms if incomplete, xhr2 \" + this.cb)), this.cb ? (this.f.timeout = this.Fa, this.f.ontimeout = p(this.qa, this)) : this.bb = Bc(this.qa, this.Fa, this)), M(this.r, S(this, \"Sending request\")), this.Pa = !0, this.f.send(a), this.Pa = !1;\n  } catch (h) {\n    M(this.r, S(this, \"Send error: \" + h.message)), Mc(this, h);\n  }\n};\nfunction Oc(a) {\n  return y && A(9) && \"number\" == typeof a.timeout && void 0 !== a.ontimeout;\n}\nfunction $a(a) {\n  return \"content-type\" == a.toLowerCase();\n}\nf.qa = function() {\n  \"undefined\" != typeof aa && this.f && (this.q = \"Timed out after \" + this.Fa + \"ms, aborting\", this.ka = 8, M(this.r, S(this, this.q)), this.dispatchEvent(\"timeout\"), this.abort(8));\n};\nfunction Mc(a, b) {\n  a.T = !1;\n  a.f && (a.da = !0, a.f.abort(), a.da = !1);\n  a.q = b;\n  a.ka = 5;\n  Pc(a);\n  Qc(a);\n}\nfunction Pc(a) {\n  a.nb || (a.nb = !0, a.dispatchEvent(\"complete\"), a.dispatchEvent(\"error\"));\n}\nf.abort = function(a) {\n  this.f && this.T && (M(this.r, S(this, \"Aborting\")), this.T = !1, this.da = !0, this.f.abort(), this.da = !1, this.ka = a || 7, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"abort\"), Qc(this));\n};\nf.u = function() {\n  this.f && (this.T && (this.T = !1, this.da = !0, this.f.abort(), this.da = !1), Qc(this, !0));\n  Ic.pa.u.call(this);\n};\nf.Qb = function() {\n  this.mb || (this.qb || this.Pa || this.da ? Rc(this) : this.uc());\n};\nf.uc = function() {\n  Rc(this);\n};\nfunction Rc(a) {\n  if (a.T && \"undefined\" != typeof aa) {\n    if (a.fb[1] && 4 == T(a) && 2 == Sc(a)) {\n      M(a.r, S(a, \"Local request error detected and ignored\"));\n    } else {\n      if (a.Pa && 4 == T(a)) {\n        Bc(a.Qb, 0, a);\n      } else {\n        if (a.dispatchEvent(\"readystatechange\"), 4 == T(a)) {\n          M(a.r, S(a, \"Request complete\"));\n          a.T = !1;\n          try {\n            var b = Sc(a), c, d;\n            a: {\n              switch(b) {\n                case 200:\n                ;\n                case 201:\n                ;\n                case 202:\n                ;\n                case 204:\n                ;\n                case 206:\n                ;\n                case 304:\n                ;\n                case 1223:\n                  d = !0;\n                  break a;\n                default:\n                  d = !1;\n              }\n            }\n            if (!(c = d)) {\n              var e;\n              if (e = 0 === b) {\n                var g = Ra(String(a.Qa))[1] || null;\n                if (!g && self.location) {\n                  var h = self.location.protocol, g = h.substr(0, h.length - 1)\n                }\n                e = !Kc.test(g ? g.toLowerCase() : \"\");\n              }\n              c = e;\n            }\n            if (c) {\n              a.dispatchEvent(\"complete\"), a.dispatchEvent(\"success\");\n            } else {\n              a.ka = 6;\n              var k;\n              try {\n                k = 2 < T(a) ? a.f.statusText : \"\";\n              } catch (u) {\n                M(a.r, \"Can not get status: \" + u.message), k = \"\";\n              }\n              a.q = k + \" [\" + Sc(a) + \"]\";\n              Pc(a);\n            }\n          } finally {\n            Qc(a);\n          }\n        }\n      }\n    }\n  }\n}\nfunction Qc(a, b) {\n  if (a.f) {\n    Nc(a);\n    var c = a.f, d = a.fb[0] ? ca : null;\n    a.f = null;\n    a.fb = null;\n    b || a.dispatchEvent(\"ready\");\n    try {\n      c.onreadystatechange = d;\n    } catch (e) {\n      (c = a.r) && c.J(\"Problem encountered resetting onreadystatechange: \" + e.message, void 0);\n    }\n  }\n}\nfunction Nc(a) {\n  a.f && a.cb && (a.f.ontimeout = null);\n  \"number\" == typeof a.bb && (l.clearTimeout(a.bb), a.bb = null);\n}\nf.isActive = function() {\n  return!!this.f;\n};\nfunction T(a) {\n  return a.f ? a.f.readyState : 0;\n}\nfunction Sc(a) {\n  try {\n    return 2 < T(a) ? a.f.status : -1;\n  } catch (b) {\n    return(a = a.r) && a.Z(\"Can not get status: \" + b.message, void 0), -1;\n  }\n}\nfunction Tc(a) {\n  try {\n    return a.f ? a.f.responseText : \"\";\n  } catch (b) {\n    return M(a.r, \"Can not get responseText: \" + b.message), \"\";\n  }\n}\nf.Ib = function() {\n  return n(this.q) ? this.q : String(this.q);\n};\nfunction S(a, b) {\n  return b + \" [\" + a.Mb + \" \" + a.Qa + \" \" + Sc(a) + \"]\";\n}\n;function Uc() {\n  this.Wb = q();\n}\nnew Uc;\nUc.prototype.set = function(a) {\n  this.Wb = a;\n};\nUc.prototype.reset = function() {\n  this.set(q());\n};\nUc.prototype.get = function() {\n  return this.Wb;\n};\nfunction Vc(a) {\n  O.call(this);\n  this.e = a;\n  this.j = {};\n}\ns(Vc, O);\nvar Wc = [];\nf = Vc.prototype;\nf.Ra = function(a, b, c, d) {\n  m(b) || (Wc[0] = b, b = Wc);\n  for (var e = 0;e < b.length;e++) {\n    var g = oc(a, b[e], c || this.handleEvent, d || !1, this.e || this);\n    if (!g) {\n      break;\n    }\n    this.j[g.key] = g;\n  }\n  return this;\n};\nf.vb = function(a, b, c, d, e) {\n  if (m(b)) {\n    for (var g = 0;g < b.length;g++) {\n      this.vb(a, b[g], c, d, e);\n    }\n  } else {\n    c = c || this.handleEvent, e = e || this.e || this, c = pc(c), d = !!d, b = bc(a) ? a.ya(b, c, d, e) : a ? (a = qc(a)) ? a.ya(b, c, d, e) : null : null, b && (uc(b), delete this.j[b.key]);\n  }\n  return this;\n};\nf.Xa = function() {\n  var a = this.j, b = uc, c;\n  for (c in a) {\n    b.call(void 0, a[c], c, a);\n  }\n  this.j = {};\n};\nf.u = function() {\n  Vc.pa.u.call(this);\n  this.Xa();\n};\nf.handleEvent = function() {\n  throw Error(\"EventHandler.handleEvent not implemented\");\n};\nfunction Xc(a, b, c) {\n  O.call(this);\n  this.pc = a;\n  this.ea = b;\n  this.e = c;\n  this.jc = p(this.vc, this);\n}\ns(Xc, O);\nf = Xc.prototype;\nf.Za = !1;\nf.Vb = 0;\nf.l = null;\nf.stop = function() {\n  this.l && (l.clearTimeout(this.l), this.l = null, this.Za = !1);\n};\nf.u = function() {\n  Xc.pa.u.call(this);\n  this.stop();\n};\nf.vc = function() {\n  this.l = null;\n  this.Za && !this.Vb && (this.Za = !1, Yc(this));\n};\nfunction Yc(a) {\n  a.l = Bc(a.jc, a.ea);\n  a.pc.call(a.e);\n}\n;function U(a, b, c, d, e) {\n  this.b = a;\n  this.a = b;\n  this.Y = c;\n  this.B = d;\n  this.Ea = e || 1;\n  this.qa = Zc;\n  this.ob = new Vc(this);\n  this.Ta = new zc;\n  this.Ta.setInterval($c);\n}\nf = U.prototype;\nf.v = null;\nf.F = !1;\nf.ua = null;\nf.xb = null;\nf.Da = null;\nf.sa = null;\nf.U = null;\nf.w = null;\nf.X = null;\nf.k = null;\nf.Ha = 0;\nf.K = null;\nf.ta = null;\nf.q = null;\nf.g = -1;\nf.Zb = !0;\nf.$ = !1;\nf.ma = 0;\nf.Va = null;\nvar Zc = 45E3, $c = 250;\nfunction ad(a, b) {\n  switch(a) {\n    case 0:\n      return \"Non-200 return code (\" + b + \")\";\n    case 1:\n      return \"XMLHTTP failure (no data)\";\n    case 2:\n      return \"HttpConnection timeout\";\n    default:\n      return \"Unknown error\";\n  }\n}\nvar bd = {}, dd = {};\nfunction ed() {\n  return!y || y && 10 <= Ma;\n}\nf = U.prototype;\nf.S = function(a) {\n  this.v = a;\n};\nf.setTimeout = function(a) {\n  this.qa = a;\n};\nf.bc = function(a) {\n  this.ma = a;\n};\nfunction fd(a, b, c) {\n  a.sa = 1;\n  a.U = H(b.n());\n  a.X = c;\n  a.Cb = !0;\n  gd(a, null);\n}\nfunction hd(a, b, c, d, e) {\n  a.sa = 1;\n  a.U = H(b.n());\n  a.X = null;\n  a.Cb = c;\n  e && (a.Zb = !1);\n  gd(a, d);\n}\nfunction gd(a, b) {\n  a.Da = q();\n  id(a);\n  a.w = a.U.n();\n  rb(a.w, \"t\", a.Ea);\n  a.Ha = 0;\n  a.k = a.b.lb(a.b.$a() ? b : null);\n  0 < a.ma && (a.Va = new Xc(p(a.ec, a, a.k), a.ma));\n  a.ob.Ra(a.k, \"readystatechange\", a.Bc);\n  var c;\n  if (a.v) {\n    c = a.v;\n    var d = {}, e;\n    for (e in c) {\n      d[e] = c[e];\n    }\n    c = d;\n  } else {\n    c = {};\n  }\n  a.X ? (a.ta = \"POST\", c[\"Content-Type\"] = \"application/x-www-form-urlencoded\", a.k.send(a.w, a.ta, a.X, c)) : (a.ta = \"GET\", a.Zb && !z && (c.Connection = \"close\"), a.k.send(a.w, a.ta, null, c));\n  a.b.H(jd);\n  if (d = a.X) {\n    for (c = \"\", d = d.split(\"&\"), e = 0;e < d.length;e++) {\n      var g = d[e].split(\"=\");\n      if (1 < g.length) {\n        var h = g[0], g = g[1], k = h.split(\"_\");\n        c = 2 <= k.length && \"type\" == k[1] ? c + (h + \"=\" + g + \"&\") : c + (h + \"=redacted&\");\n      }\n    }\n  } else {\n    c = null;\n  }\n  a.a.info(\"XMLHTTP REQ (\" + a.B + \") [attempt \" + a.Ea + \"]: \" + a.ta + \"\\n\" + a.w + \"\\n\" + c);\n}\nf.Bc = function(a) {\n  a = a.target;\n  var b = this.Va;\n  b && 3 == T(a) ? (this.a.debug(\"Throttling readystatechange.\"), b.l || b.Vb ? b.Za = !0 : Yc(b)) : this.ec(a);\n};\nf.ec = function(a) {\n  try {\n    if (a == this.k) {\n      a: {\n        var b = T(this.k), c = this.k.ka, d = Sc(this.k);\n        if (!ed() || z && !A(\"420+\")) {\n          if (4 > b) {\n            break a;\n          }\n        } else {\n          if (3 > b || 3 == b && !Aa && !Tc(this.k)) {\n            break a;\n          }\n        }\n        this.$ || 4 != b || 7 == c || (8 == c || 0 >= d ? this.b.H(kd) : this.b.H(ld));\n        md(this);\n        var e = Sc(this.k);\n        this.g = e;\n        var g = Tc(this.k);\n        g || this.a.debug(\"No response text for uri \" + this.w + \" status \" + e);\n        this.F = 200 == e;\n        this.a.info(\"XMLHTTP RESP (\" + this.B + \") [ attempt \" + this.Ea + \"]: \" + this.ta + \"\\n\" + this.w + \"\\n\" + b + \" \" + e);\n        this.F ? (4 == b && V(this), this.Cb ? (nd(this, b, g), Aa && this.F && 3 == b && (this.ob.Ra(this.Ta, Ac, this.Ac), this.Ta.start())) : (Ub(this.a, this.B, g, null), od(this, g)), this.F && !this.$ && (4 == b ? this.b.la(this) : (this.F = !1, id(this)))) : (400 == e && 0 < g.indexOf(\"Unknown SID\") ? (this.q = 3, W(), this.a.Z(\"XMLHTTP Unknown SID (\" + this.B + \")\")) : (this.q = 0, W(), this.a.Z(\"XMLHTTP Bad status \" + e + \" (\" + this.B + \")\")), V(this), pd(this));\n      }\n    } else {\n      this.a.Z(\"Called back with an unexpected xmlhttp\");\n    }\n  } catch (h) {\n    this.a.debug(\"Failed call to OnXmlHttpReadyStateChanged_\"), this.k && Tc(this.k) ? Wb(this.a, h, \"ResponseText: \" + Tc(this.k)) : Wb(this.a, h, \"No response text\");\n  } finally {\n  }\n};\nfunction nd(a, b, c) {\n  for (var d = !0;!a.$ && a.Ha < c.length;) {\n    var e = qd(a, c);\n    if (e == dd) {\n      4 == b && (a.q = 4, W(), d = !1);\n      Ub(a.a, a.B, null, \"[Incomplete Response]\");\n      break;\n    } else {\n      if (e == bd) {\n        a.q = 4;\n        W();\n        Ub(a.a, a.B, c, \"[Invalid Chunk]\");\n        d = !1;\n        break;\n      } else {\n        Ub(a.a, a.B, e, null), od(a, e);\n      }\n    }\n  }\n  4 == b && 0 == c.length && (a.q = 1, W(), d = !1);\n  a.F = a.F && d;\n  d || (Ub(a.a, a.B, c, \"[Invalid Chunked Response]\"), V(a), pd(a));\n}\nf.Ac = function() {\n  var a = T(this.k), b = Tc(this.k);\n  this.Ha < b.length && (md(this), nd(this, a, b), this.F && 4 != a && id(this));\n};\nfunction qd(a, b) {\n  var c = a.Ha, d = b.indexOf(\"\\n\", c);\n  if (-1 == d) {\n    return dd;\n  }\n  c = Number(b.substring(c, d));\n  if (isNaN(c)) {\n    return bd;\n  }\n  d += 1;\n  if (d + c > b.length) {\n    return dd;\n  }\n  var e = b.substr(d, c);\n  a.Ha = d + c;\n  return e;\n}\nfunction rd(a, b) {\n  a.Da = q();\n  id(a);\n  var c = b ? window.location.hostname : \"\";\n  a.w = a.U.n();\n  G(a.w, \"DOMAIN\", c);\n  G(a.w, \"t\", a.Ea);\n  try {\n    a.K = new ActiveXObject(\"htmlfile\");\n  } catch (d) {\n    a.a.J(\"ActiveX blocked\");\n    V(a);\n    a.q = 7;\n    W();\n    pd(a);\n    return;\n  }\n  var e = \"<html><body>\";\n  b && (e += '<script>document.domain=\"' + c + '\"\\x3c/script>');\n  e += \"</body></html>\";\n  a.K.open();\n  a.K.write(e);\n  a.K.close();\n  a.K.parentWindow.m = p(a.yc, a);\n  a.K.parentWindow.d = p(a.Ub, a, !0);\n  a.K.parentWindow.rpcClose = p(a.Ub, a, !1);\n  c = a.K.createElement(\"div\");\n  a.K.parentWindow.document.body.appendChild(c);\n  c.innerHTML = '<iframe src=\"' + a.w + '\"></iframe>';\n  a.a.info(\"TRIDENT REQ (\" + a.B + \") [ attempt \" + a.Ea + \"]: GET\\n\" + a.w);\n  a.b.H(jd);\n}\nf.yc = function(a) {\n  Y(p(this.xc, this, a), 0);\n};\nf.xc = function(a) {\n  if (!this.$) {\n    var b = this.a;\n    b.info(\"TRIDENT TEXT (\" + this.B + \"): \" + Vb(b, a));\n    md(this);\n    od(this, a);\n    id(this);\n  }\n};\nf.Ub = function(a) {\n  Y(p(this.wc, this, a), 0);\n};\nf.wc = function(a) {\n  this.$ || (this.a.info(\"TRIDENT TEXT (\" + this.B + \"): \" + a ? \"success\" : \"failure\"), V(this), this.F = a, this.b.la(this), this.b.H(sd));\n};\nf.nc = function() {\n  md(this);\n  this.b.la(this);\n};\nf.cancel = function() {\n  this.$ = !0;\n  V(this);\n};\nfunction id(a) {\n  a.xb = q() + a.qa;\n  td(a, a.qa);\n}\nfunction td(a, b) {\n  if (null != a.ua) {\n    throw Error(\"WatchDog timer not null\");\n  }\n  a.ua = Y(p(a.zc, a), b);\n}\nfunction md(a) {\n  a.ua && (l.clearTimeout(a.ua), a.ua = null);\n}\nf.zc = function() {\n  this.ua = null;\n  var a = q();\n  0 <= a - this.xb ? (this.F && this.a.J(\"Received watchdog timeout even though request loaded successfully\"), this.a.info(\"TIMEOUT: \" + this.w), 2 != this.sa && this.b.H(kd), V(this), this.q = 2, W(), pd(this)) : (this.a.Z(\"WatchDog timer called too early\"), td(this, this.xb - a));\n};\nfunction pd(a) {\n  a.b.Lb() || a.$ || a.b.la(a);\n}\nfunction V(a) {\n  md(a);\n  var b = a.Va;\n  b && \"function\" == typeof b.Ja && b.Ja();\n  a.Va = null;\n  a.Ta.stop();\n  a.ob.Xa();\n  a.k && (b = a.k, a.k = null, b.abort(), b.Ja());\n  a.K && (a.K = null);\n}\nf.Ib = function() {\n  return this.q;\n};\nfunction od(a, b) {\n  try {\n    a.b.Rb(a, b), a.b.H(sd);\n  } catch (c) {\n    Wb(a.a, c, \"Error in httprequest callback\");\n  }\n}\n;function ud(a, b, c, d, e) {\n  (new N).debug(\"TestLoadImageWithRetries: \" + e);\n  if (0 == d) {\n    c(!1);\n  } else {\n    var g = e || 0;\n    d--;\n    vd(a, b, function(e) {\n      e ? c(!0) : l.setTimeout(function() {\n        ud(a, b, c, d, g);\n      }, g);\n    });\n  }\n}\nfunction vd(a, b, c) {\n  function d(a, b) {\n    return function() {\n      try {\n        e.debug(\"TestLoadImage: \" + b), g.onload = null, g.onerror = null, g.onabort = null, g.ontimeout = null, l.clearTimeout(h), c(a);\n      } catch (d) {\n        Wb(e, d);\n      }\n    };\n  }\n  var e = new N;\n  e.debug(\"TestLoadImage: loading \" + a);\n  var g = new Image, h = null;\n  g.onload = d(!0, \"loaded\");\n  g.onerror = d(!1, \"error\");\n  g.onabort = d(!1, \"abort\");\n  g.ontimeout = d(!1, \"timeout\");\n  h = l.setTimeout(function() {\n    if (g.ontimeout) {\n      g.ontimeout();\n    }\n  }, b);\n  g.src = a;\n}\n;function wd(a, b) {\n  this.b = a;\n  this.a = b;\n  this.P = new Yb(0, !0);\n}\nf = wd.prototype;\nf.v = null;\nf.A = null;\nf.Wa = !1;\nf.cc = null;\nf.La = null;\nf.rb = null;\nf.I = null;\nf.c = null;\nf.g = -1;\nf.L = null;\nf.va = null;\nf.S = function(a) {\n  this.v = a;\n};\nf.ac = function(a) {\n  this.P = a;\n};\nf.kb = function(a) {\n  this.I = a;\n  a = xd(this.b, this.I);\n  W();\n  this.cc = q();\n  var b = this.b.Gb;\n  null != b ? (this.L = this.b.correctHostPrefix(b[0]), (this.va = b[1]) ? (this.c = 1, yd(this)) : (this.c = 2, zd(this))) : (rb(a, \"MODE\", \"init\"), this.A = new U(this, this.a, void 0, void 0, void 0), this.A.S(this.v), hd(this.A, a, !1, null, !0), this.c = 0);\n};\nfunction yd(a) {\n  var b = Ad(a.b, a.va, \"/mail/images/cleardot.gif\");\n  H(b);\n  ud(b.toString(), 5E3, p(a.kc, a), 3, 2E3);\n  a.H(jd);\n}\nf.kc = function(a) {\n  if (a) {\n    this.c = 2, zd(this);\n  } else {\n    W();\n    var b = this.b;\n    b.a.debug(\"Test Connection Blocked\");\n    b.g = b.V.g;\n    Z(b, 9);\n  }\n  a && this.H(ld);\n};\nfunction zd(a) {\n  a.a.debug(\"TestConnection: starting stage 2\");\n  var b = a.b.Dc;\n  if (null != b) {\n    a.a.debug(\"TestConnection: skipping stage 2, precomputed result is \" + b ? \"Buffered\" : \"Unbuffered\"), W(), b ? (W(), Bd(a.b, a, !1)) : (W(), Bd(a.b, a, !0));\n  } else {\n    if (a.A = new U(a, a.a, void 0, void 0, void 0), a.A.S(a.v), b = Cd(a.b, a.L, a.I), W(), ed()) {\n      rb(b, \"TYPE\", \"xmlhttp\"), hd(a.A, b, !1, a.L, !1);\n    } else {\n      rb(b, \"TYPE\", \"html\");\n      var c = a.A;\n      a = Boolean(a.L);\n      c.sa = 3;\n      c.U = H(b.n());\n      rd(c, a);\n    }\n  }\n}\nf.lb = function(a) {\n  return this.b.lb(a);\n};\nf.abort = function() {\n  this.A && (this.A.cancel(), this.A = null);\n  this.g = -1;\n};\nf.Lb = function() {\n  return!1;\n};\nf.Rb = function(a, b) {\n  this.g = a.g;\n  if (0 == this.c) {\n    if (this.a.debug(\"TestConnection: Got data for stage 1\"), b) {\n      try {\n        var c = this.P.parse(b);\n      } catch (d) {\n        Wb(this.a, d);\n        Dd(this.b, this);\n        return;\n      }\n      this.L = this.b.correctHostPrefix(c[0]);\n      this.va = c[1];\n    } else {\n      this.a.debug(\"TestConnection: Null responseText\"), Dd(this.b, this);\n    }\n  } else {\n    if (2 == this.c) {\n      if (this.Wa) {\n        W(), this.rb = q();\n      } else {\n        if (\"11111\" == b) {\n          if (W(), this.Wa = !0, this.La = q(), c = this.La - this.cc, ed() || 500 > c) {\n            this.g = 200, this.A.cancel(), this.a.debug(\"Test connection succeeded; using streaming connection\"), W(), Bd(this.b, this, !0);\n          }\n        } else {\n          W(), this.La = this.rb = q(), this.Wa = !1;\n        }\n      }\n    }\n  }\n};\nf.la = function() {\n  this.g = this.A.g;\n  if (!this.A.F) {\n    this.a.debug(\"TestConnection: request failed, in state \" + this.c), 0 == this.c ? W() : 2 == this.c && W(), Dd(this.b, this);\n  } else {\n    if (0 == this.c) {\n      this.a.debug(\"TestConnection: request complete for initial check\"), this.va ? (this.c = 1, yd(this)) : (this.c = 2, zd(this));\n    } else {\n      if (2 == this.c) {\n        this.a.debug(\"TestConnection: request complete for stage 2\");\n        var a = !1;\n        (a = ed() ? this.Wa : 200 > this.rb - this.La ? !1 : !0) ? (this.a.debug(\"Test connection succeeded; using streaming connection\"), W(), Bd(this.b, this, !0)) : (this.a.debug(\"Test connection failed; not using streaming\"), W(), Bd(this.b, this, !1));\n      }\n    }\n  }\n};\nf.$a = function() {\n  return this.b.$a();\n};\nf.isActive = function() {\n  return this.b.isActive();\n};\nf.H = function(a) {\n  this.b.H(a);\n};\nfunction Ed(a, b, c) {\n  this.Bb = a || null;\n  this.c = Fd;\n  this.t = [];\n  this.Q = [];\n  this.a = new N;\n  this.P = new Yb(0, !0);\n  this.Gb = b || null;\n  this.Dc = null != c ? c : null;\n}\nfunction Gd(a, b) {\n  this.Ob = a;\n  this.map = b;\n}\nf = Ed.prototype;\nf.v = null;\nf.xa = null;\nf.p = null;\nf.i = null;\nf.I = null;\nf.Ma = null;\nf.zb = null;\nf.L = null;\nf.hc = !0;\nf.Ba = 0;\nf.sc = 0;\nf.Ka = !1;\nf.e = null;\nf.G = null;\nf.M = null;\nf.aa = null;\nf.V = null;\nf.wb = null;\nf.gc = !0;\nf.za = -1;\nf.Nb = -1;\nf.g = -1;\nf.ba = 0;\nf.ha = 0;\nf.ic = 5E3;\nf.Cc = 1E4;\nf.pb = 2;\nf.Hb = 2E4;\nf.ma = 0;\nf.ab = !1;\nf.ia = 8;\nvar Fd = 1, Hd = new R;\nfunction Id(a) {\n  Q.call(this, \"statevent\", a);\n}\ns(Id, Q);\nfunction Jd(a, b) {\n  Q.call(this, \"timingevent\", a);\n  this.size = b;\n}\ns(Jd, Q);\nvar jd = 1, ld = 2, kd = 3, sd = 4;\nfunction Kd(a) {\n  Q.call(this, \"serverreachability\", a);\n}\ns(Kd, Q);\nvar Xb = \"y2f%\";\nf = Ed.prototype;\nf.kb = function(a, b, c, d, e) {\n  this.a.debug(\"connect()\");\n  W();\n  this.I = b;\n  this.xa = c || {};\n  d && void 0 !== e && (this.xa.OSID = d, this.xa.OAID = e);\n  this.a.debug(\"connectTest_()\");\n  Ld(this) && (this.V = new wd(this, this.a), this.V.S(this.v), this.V.ac(this.P), this.V.kb(a));\n};\nf.disconnect = function() {\n  this.a.debug(\"disconnect()\");\n  Md(this);\n  if (3 == this.c) {\n    var a = this.Ba++, b = this.Ma.n();\n    G(b, \"SID\", this.Y);\n    G(b, \"RID\", a);\n    G(b, \"TYPE\", \"terminate\");\n    Nd(this, b);\n    a = new U(this, this.a, this.Y, a, void 0);\n    a.sa = 2;\n    a.U = H(b.n());\n    b = new Image;\n    b.src = a.U;\n    b.onload = b.onerror = p(a.nc, a);\n    a.Da = q();\n    id(a);\n  }\n  Od(this);\n};\nfunction Md(a) {\n  a.V && (a.V.abort(), a.V = null);\n  a.i && (a.i.cancel(), a.i = null);\n  a.M && (l.clearTimeout(a.M), a.M = null);\n  Pd(a);\n  a.p && (a.p.cancel(), a.p = null);\n  a.G && (l.clearTimeout(a.G), a.G = null);\n}\nf.S = function(a) {\n  this.v = a;\n};\nf.bc = function(a) {\n  this.ma = a;\n};\nf.Lb = function() {\n  return 0 == this.c;\n};\nf.ac = function(a) {\n  this.P = a;\n};\nfunction Qd(a) {\n  a.p || a.G || (a.G = Y(p(a.Tb, a), 0), a.ba = 0);\n}\nf.Tb = function(a) {\n  this.G = null;\n  this.a.debug(\"startForwardChannel_\");\n  if (Ld(this)) {\n    if (this.c == Fd) {\n      if (a) {\n        this.a.J(\"Not supposed to retry the open\");\n      } else {\n        this.a.debug(\"open_()\");\n        this.Ba = Math.floor(1E5 * Math.random());\n        a = this.Ba++;\n        var b = new U(this, this.a, \"\", a, void 0);\n        b.S(this.v);\n        var c = Rd(this), d = this.Ma.n();\n        G(d, \"RID\", a);\n        this.Bb && G(d, \"CVER\", this.Bb);\n        Nd(this, d);\n        fd(b, d, c);\n        this.p = b;\n        this.c = 2;\n      }\n    } else {\n      3 == this.c && (a ? Sd(this, a) : 0 == this.t.length ? this.a.debug(\"startForwardChannel_ returned: nothing to send\") : this.p ? this.a.J(\"startForwardChannel_ returned: connection already in progress\") : (Sd(this), this.a.debug(\"startForwardChannel_ finished, sent request\")));\n    }\n  }\n};\nfunction Sd(a, b) {\n  var c, d;\n  b ? 6 < a.ia ? (a.t = a.Q.concat(a.t), a.Q.length = 0, c = a.Ba - 1, d = Rd(a)) : (c = b.B, d = b.X) : (c = a.Ba++, d = Rd(a));\n  var e = a.Ma.n();\n  G(e, \"SID\", a.Y);\n  G(e, \"RID\", c);\n  G(e, \"AID\", a.za);\n  Nd(a, e);\n  c = new U(a, a.a, a.Y, c, a.ba + 1);\n  c.S(a.v);\n  c.setTimeout(Math.round(0.5 * a.Hb) + Math.round(0.5 * a.Hb * Math.random()));\n  a.p = c;\n  fd(c, e, d);\n}\nfunction Nd(a, b) {\n  if (a.e) {\n    var c = a.e.getAdditionalParams(a);\n    c && D(c, function(a, c) {\n      G(b, c, a);\n    });\n  }\n}\nfunction Rd(a) {\n  var b = Math.min(a.t.length, 1E3), c = [\"count=\" + b], d;\n  6 < a.ia && 0 < b ? (d = a.t[0].Ob, c.push(\"ofs=\" + d)) : d = 0;\n  for (var e = 0;e < b;e++) {\n    var g = a.t[e].Ob, h = a.t[e].map, g = 6 >= a.ia ? e : g - d;\n    try {\n      D(h, function(a, b) {\n        c.push(\"req\" + g + \"_\" + b + \"=\" + encodeURIComponent(a));\n      });\n    } catch (k) {\n      c.push(\"req\" + g + \"_type=\" + encodeURIComponent(\"_badmap\")), a.e && a.e.badMapError(a, h);\n    }\n  }\n  a.Q = a.Q.concat(a.t.splice(0, b));\n  return c.join(\"&\");\n}\nfunction Td(a) {\n  a.i || a.M || (a.yb = 1, a.M = Y(p(a.Sb, a), 0), a.ha = 0);\n}\nfunction Ud(a) {\n  if (a.i || a.M) {\n    return a.a.J(\"Request already in progress\"), !1;\n  }\n  if (3 <= a.ha) {\n    return!1;\n  }\n  a.a.debug(\"Going to retry GET\");\n  a.yb++;\n  a.M = Y(p(a.Sb, a), Vd(a, a.ha));\n  a.ha++;\n  return!0;\n}\nf.Sb = function() {\n  this.M = null;\n  if (Ld(this)) {\n    this.a.debug(\"Creating new HttpRequest\");\n    this.i = new U(this, this.a, this.Y, \"rpc\", this.yb);\n    this.i.S(this.v);\n    this.i.bc(this.ma);\n    var a = this.zb.n();\n    G(a, \"RID\", \"rpc\");\n    G(a, \"SID\", this.Y);\n    G(a, \"CI\", this.wb ? \"0\" : \"1\");\n    G(a, \"AID\", this.za);\n    Nd(this, a);\n    if (ed()) {\n      G(a, \"TYPE\", \"xmlhttp\"), hd(this.i, a, !0, this.L, !1);\n    } else {\n      G(a, \"TYPE\", \"html\");\n      var b = this.i, c = Boolean(this.L);\n      b.sa = 3;\n      b.U = H(a.n());\n      rd(b, c);\n    }\n    this.a.debug(\"New Request created\");\n  }\n};\nfunction Ld(a) {\n  if (a.e) {\n    var b = a.e.okToMakeRequest(a);\n    if (0 != b) {\n      return a.a.debug(\"Handler returned error code from okToMakeRequest\"), Z(a, b), !1;\n    }\n  }\n  return!0;\n}\nfunction Bd(a, b, c) {\n  a.a.debug(\"Test Connection Finished\");\n  a.wb = a.gc && c;\n  a.g = b.g;\n  a.a.debug(\"connectChannel_()\");\n  a.lc(Fd, 0);\n  a.Ma = xd(a, a.I);\n  Qd(a);\n}\nfunction Dd(a, b) {\n  a.a.debug(\"Test Connection Failed\");\n  a.g = b.g;\n  Z(a, 2);\n}\nf.Rb = function(a, b) {\n  if (0 != this.c && (this.i == a || this.p == a)) {\n    if (this.g = a.g, this.p == a && 3 == this.c) {\n      if (7 < this.ia) {\n        var c;\n        try {\n          c = this.P.parse(b);\n        } catch (d) {\n          c = null;\n        }\n        if (m(c) && 3 == c.length) {\n          var e = c;\n          if (0 == e[0]) {\n            a: {\n              if (this.a.debug(\"Server claims our backchannel is missing.\"), this.M) {\n                this.a.debug(\"But we are currently starting the request.\");\n              } else {\n                if (this.i) {\n                  if (this.i.Da + 3E3 < this.p.Da) {\n                    Pd(this), this.i.cancel(), this.i = null;\n                  } else {\n                    break a;\n                  }\n                } else {\n                  this.a.Z(\"We do not have a BackChannel established\");\n                }\n                Ud(this);\n                W();\n              }\n            }\n          } else {\n            this.Nb = e[1], c = this.Nb - this.za, 0 < c && (e = e[2], this.a.debug(e + \" bytes (in \" + c + \" arrays) are outstanding on the BackChannel\"), 37500 > e && this.wb && 0 == this.ha && !this.aa && (this.aa = Y(p(this.tc, this), 6E3)));\n          }\n        } else {\n          this.a.debug(\"Bad POST response data returned\"), Z(this, 11);\n        }\n      } else {\n        b != Xb && (this.a.debug(\"Bad data returned - missing/invald magic cookie\"), Z(this, 11));\n      }\n    } else {\n      if (this.i == a && Pd(this), !/^[\\s\\xa0]*$/.test(b)) {\n        c = this.P.parse(b);\n        for (var e = this.e && this.e.channelHandleMultipleArrays ? [] : null, g = 0;g < c.length;g++) {\n          var h = c[g];\n          this.za = h[0];\n          h = h[1];\n          2 == this.c ? \"c\" == h[0] ? (this.Y = h[1], this.L = this.correctHostPrefix(h[2]), h = h[3], this.ia = null != h ? h : 6, this.c = 3, this.e && this.e.channelOpened(this), this.zb = Cd(this, this.L, this.I), Td(this)) : \"stop\" == h[0] && Z(this, 7) : 3 == this.c && (\"stop\" == h[0] ? (e && 0 != e.length && (this.e.channelHandleMultipleArrays(this, e), e.length = 0), Z(this, 7)) : \"noop\" != h[0] && (e ? e.push(h) : this.e && this.e.channelHandleArray(this, h)), this.ha = 0);\n        }\n        e && 0 != e.length && this.e.channelHandleMultipleArrays(this, e);\n      }\n    }\n  }\n};\nf.correctHostPrefix = function(a) {\n  return this.hc ? this.e ? this.e.correctHostPrefix(a) : a : null;\n};\nf.tc = function() {\n  null != this.aa && (this.aa = null, this.i.cancel(), this.i = null, Ud(this), W());\n};\nfunction Pd(a) {\n  null != a.aa && (l.clearTimeout(a.aa), a.aa = null);\n}\nf.la = function(a) {\n  this.a.debug(\"Request complete\");\n  var b;\n  if (this.i == a) {\n    Pd(this), this.i = null, b = 2;\n  } else {\n    if (this.p == a) {\n      this.p = null, b = 1;\n    } else {\n      return;\n    }\n  }\n  this.g = a.g;\n  if (0 != this.c) {\n    if (a.F) {\n      1 == b ? (q(), Hd.dispatchEvent(new Jd(Hd, a.X ? a.X.length : 0)), Qd(this), this.Q.length = 0) : Td(this);\n    } else {\n      var c = a.Ib();\n      if (3 == c || 7 == c || 0 == c && 0 < this.g) {\n        this.a.debug(\"Not retrying due to error type\");\n      } else {\n        this.a.debug(\"Maybe retrying, last error: \" + ad(c, this.g));\n        var d;\n        if (d = 1 == b) {\n          this.p || this.G ? (this.a.J(\"Request already in progress\"), d = !1) : this.c == Fd || this.ba >= (this.Ka ? 0 : this.pb) ? d = !1 : (this.a.debug(\"Going to retry POST\"), this.G = Y(p(this.Tb, this, a), Vd(this, this.ba)), this.ba++, d = !0);\n        }\n        if (d || 2 == b && Ud(this)) {\n          return;\n        }\n        this.a.debug(\"Exceeded max number of retries\");\n      }\n      this.a.debug(\"Error: HTTP request failed\");\n      switch(c) {\n        case 1:\n          Z(this, 5);\n          break;\n        case 4:\n          Z(this, 10);\n          break;\n        case 3:\n          Z(this, 6);\n          break;\n        case 7:\n          Z(this, 12);\n          break;\n        default:\n          Z(this, 2);\n      }\n    }\n  }\n};\nfunction Vd(a, b) {\n  var c = a.ic + Math.floor(Math.random() * a.Cc);\n  a.isActive() || (a.a.debug(\"Inactive channel\"), c *= 2);\n  return c * b;\n}\nf.lc = function(a) {\n  if (!(0 <= Xa(arguments, this.c))) {\n    throw Error(\"Unexpected channel state: \" + this.c);\n  }\n};\nfunction Z(a, b) {\n  a.a.info(\"Error code \" + b);\n  if (2 == b || 9 == b) {\n    var c = null;\n    a.e && (c = a.e.getNetworkTestImageUri(a));\n    var d = p(a.Fc, a);\n    c || (c = new E(\"//www.google.com/images/cleardot.gif\"), H(c));\n    vd(c.toString(), 1E4, d);\n  } else {\n    W();\n  }\n  Wd(a, b);\n}\nf.Fc = function(a) {\n  a ? (this.a.info(\"Successfully pinged google.com\"), W()) : (this.a.info(\"Failed to ping google.com\"), W(), Wd(this, 8));\n};\nfunction Wd(a, b) {\n  a.a.debug(\"HttpChannel: error - \" + b);\n  a.c = 0;\n  a.e && a.e.channelError(a, b);\n  Od(a);\n  Md(a);\n}\nfunction Od(a) {\n  a.c = 0;\n  a.g = -1;\n  if (a.e) {\n    if (0 == a.Q.length && 0 == a.t.length) {\n      a.e.channelClosed(a);\n    } else {\n      a.a.debug(\"Number of undelivered maps, pending: \" + a.Q.length + \", outgoing: \" + a.t.length);\n      var b = bb(a.Q), c = bb(a.t);\n      a.Q.length = 0;\n      a.t.length = 0;\n      a.e.channelClosed(a, b, c);\n    }\n  }\n}\nfunction xd(a, b) {\n  var c = Ad(a, null, b);\n  a.a.debug(\"GetForwardChannelUri: \" + c);\n  return c;\n}\nfunction Cd(a, b, c) {\n  b = Ad(a, a.$a() ? b : null, c);\n  a.a.debug(\"GetBackChannelUri: \" + b);\n  return b;\n}\nfunction Ad(a, b, c) {\n  var d = tb(c);\n  if (\"\" != d.ja) {\n    b && gb(d, b + \".\" + d.ja), hb(d, d.Ca);\n  } else {\n    var e = window.location, d = ub(e.protocol, b ? b + \".\" + e.hostname : e.hostname, e.port, c)\n  }\n  a.xa && D(a.xa, function(a, b) {\n    G(d, b, a);\n  });\n  G(d, \"VER\", a.ia);\n  Nd(a, d);\n  return d;\n}\nf.lb = function(a) {\n  if (a && !this.ab) {\n    throw Error(\"Can't create secondary domain capable XhrIo object.\");\n  }\n  a = new Ic;\n  a.dc = this.ab;\n  return a;\n};\nf.isActive = function() {\n  return!!this.e && this.e.isActive(this);\n};\nfunction Y(a, b) {\n  if (!fa(a)) {\n    throw Error(\"Fn must not be null and must be a function\");\n  }\n  return l.setTimeout(function() {\n    a();\n  }, b);\n}\nf.H = function() {\n  Hd.dispatchEvent(new Kd(Hd));\n};\nfunction W() {\n  Hd.dispatchEvent(new Id(Hd));\n}\nf.$a = function() {\n  return this.ab || !ed();\n};\nfunction Xd() {\n}\nf = Xd.prototype;\nf.channelHandleMultipleArrays = null;\nf.okToMakeRequest = function() {\n  return 0;\n};\nf.channelOpened = function() {\n};\nf.channelHandleArray = function() {\n};\nf.channelError = function() {\n};\nf.channelClosed = function() {\n};\nf.getAdditionalParams = function() {\n  return{};\n};\nf.getNetworkTestImageUri = function() {\n  return null;\n};\nf.isActive = function() {\n  return!0;\n};\nf.badMapError = function() {\n};\nf.correctHostPrefix = function(a) {\n  return a;\n};\nvar $, Yd;\nYd = {0:\"Ok\", 4:\"User is logging out\", 6:\"Unknown session ID\", 7:\"Stopped by server\", 8:\"General network error\", 2:\"Request failed\", 9:\"Blocked by a network administrator\", 5:\"No data from server\", 10:\"Got bad data from the server\", 11:\"Got a bad response from the server\"};\n$ = function(a, b) {\n  var c, d, e, g, h, k, u, K, v, r, Ka, w, X, cd;\n  if (!(this instanceof $)) {\n    return new $(a, b);\n  }\n  r = this;\n  a || (a = \"channel\");\n  a.match(/:\\/\\//) && a.replace(/^ws/, \"http\");\n  b || (b = {});\n  m(b || \"string\" === typeof b) && (b = {});\n  K = b.reconnectTime || 3E3;\n  c = b.extraHeaders || null;\n  d = b.extraParams || null;\n  null !== b.affinity && (d || (d = {}), b.affinityParam || (b.affinityParam = \"a\"), this.affinity = b.affinity || sa(), d[b.affinityParam] = this.affinity);\n  X = function(a) {\n    r.readyState = r.readyState = a;\n  };\n  X(this.CLOSED);\n  w = null;\n  k = null != (cd = b.prev) ? cd.Ec : void 0;\n  e = function(a, b, c, d, e) {\n    try {\n      return \"function\" === typeof r[a] ? r[a](c, d, e) : void 0;\n    } catch (g) {\n      throw \"undefined\" !== typeof console && null !== console && console.error(g.stack), g;\n    }\n  };\n  g = new Xd;\n  g.channelOpened = function() {\n    k = w;\n    X($.OPEN);\n    return e(\"onopen\");\n  };\n  h = null;\n  g.channelError = function(a, b) {\n    var c;\n    c = Yd[b];\n    h = b;\n    r.readyState !== $.CLOSED && X($.hb);\n    return e(\"onerror\", 0, c, b);\n  };\n  v = null;\n  g.channelClosed = function(a, c, d) {\n    var g;\n    if (r.readyState !== $.CLOSED) {\n      return w = null, a = h ? Yd[h] : \"Closed\", X($.CLOSED), b.reconnect && 7 !== h && 0 !== h && (g = 6 === h ? 0 : K, clearTimeout(v), v = setTimeout(u, g)), e(\"onclose\", 0, a, c, d), h = null;\n    }\n  };\n  g.channelHandleArray = function(a, b) {\n    return e(\"onmessage\", 0, {type:\"message\", data:b});\n  };\n  u = function() {\n    if (w) {\n      throw Error(\"Reconnect() called from invalid state\");\n    }\n    X($.CONNECTING);\n    e(\"onconnecting\");\n    clearTimeout(v);\n    r.Ec = w = new Ed(b.appVersion, null != k ? k.Gb : void 0);\n    b.crossDomainXhr && (w.ab = !0);\n    w.e = g;\n    c && w.S(c);\n    h = null;\n    if (b.failFast) {\n      var t = w;\n      t.Ka = !0;\n      t.a.info(\"setFailFast: true\");\n      (t.p || t.G) && t.ba > (t.Ka ? 0 : t.pb) && (t.a.info(\"Retry count \" + t.ba + \" > new maxRetries \" + (t.Ka ? 0 : t.pb) + \". Fail immediately!\"), t.p ? (t.p.cancel(), t.la(t.p)) : (l.clearTimeout(t.G), t.G = null, Z(t, 2)));\n    }\n    return w.kb(\"\" + a + \"/test\", \"\" + a + \"/bind\", d, null != k ? k.Y : void 0, null != k ? k.za : void 0);\n  };\n  this.open = function() {\n    if (r.readyState !== r.CLOSED) {\n      throw Error(\"Already open\");\n    }\n    return u();\n  };\n  this.close = function() {\n    clearTimeout(v);\n    h = 0;\n    if (r.readyState !== $.CLOSED) {\n      return X($.hb), w.disconnect();\n    }\n  };\n  this.sendMap = Ka = function(a) {\n    var b;\n    if ((b = r.readyState) !== $.hb && b !== $.CLOSED) {\n      b = w;\n      if (0 == b.c) {\n        throw Error(\"Invalid operation: sending map when state is closed\");\n      }\n      1E3 == b.t.length && b.a.J(\"Already have 1000 queued maps upon queueing \" + yb(a));\n      b.t.push(new Gd(b.sc++, a));\n      2 != b.c && 3 != b.c || Qd(b);\n    }\n  };\n  this.send = function(a) {\n    return \"string\" === typeof a ? Ka({_S:a}) : Ka({JSON:yb(a)});\n  };\n  u();\n};\n$.prototype.canSendWhileConnecting = $.canSendWhileConnecting = !0;\n$.prototype.canSendJSON = $.canSendJSON = !0;\n$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;\n$.prototype.OPEN = $.OPEN = $.OPEN = 1;\n$.prototype.CLOSING = $.CLOSING = $.hb = 2;\n$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;\n(\"undefined\" !== typeof exports && null !== exports ? exports : window).BCSocket = $;\n\n})();\n","var pSlice = Array.prototype.slice;\nvar Object_keys = typeof Object.keys === 'function'\n    ? Object.keys\n    : function (obj) {\n        var keys = [];\n        for (var key in obj) keys.push(key);\n        return keys;\n    }\n;\n\nvar deepEqual = module.exports = function (actual, expected) {\n  // enforce Object.is +0 !== -0\n  if (actual === 0 && expected === 0) {\n    return areZerosEqual(actual, expected);\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  } else if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  } else if (isNumberNaN(actual)) {\n    return isNumberNaN(expected);\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n};\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction isNumberNaN(value) {\n  // NaN === NaN -> false\n  return typeof value == 'number' && value !== value;\n}\n\nfunction areZerosEqual(zeroA, zeroB) {\n  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)\n  return (1 / zeroA) === (1 / zeroB);\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b);\n  }\n  try {\n    var ka = Object_keys(a),\n        kb = Object_keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n","exports.contexts = require('./lib/contexts');\nexports.expressions = require('./lib/expressions');\nexports.operatorFns = require('./lib/operatorFns');\nexports.templates = require('./lib/templates');\n","exports.ContextMeta = ContextMeta;\nexports.Context = Context;\n\nfunction noop() {}\n\n// TODO:\n// Implement removeItemContext\n\nfunction ContextMeta() {\n  this.addBinding = noop;\n  this.removeBinding = noop;\n  this.removeNode = noop;\n  this.addItemContext = noop;\n  this.removeItemContext = noop;\n  this.views = null;\n  this.idNamespace = '';\n  this.idCount = 0;\n  this.pending = [];\n  this.pauseCount = 0;\n}\n\nfunction Context(meta, controller, parent, unbound, expression, item, view, attributes, hooks, initHooks) {\n  // Required properties //\n\n  // Properties which are globally inherited for the entire page\n  this.meta = meta;\n  // The page or component. Must have a `model` property with a `data` property\n  this.controller = controller;\n\n  // Optional properties //\n\n  // Containing context\n  this.parent = parent;\n  // Boolean set to true when bindings should be ignored\n  this.unbound = unbound;\n  // The expression for a block\n  this.expression = expression;\n  // Alias name for the given expression\n  this.alias = expression && expression.meta && expression.meta.as;\n  // Alias name for the index or iterated key\n  this.keyAlias = expression && expression.meta && expression.meta.keyAs;\n\n  // For Context::eachChild\n  // The index of the each at render time\n  this.item = item;\n\n  // For Context::viewChild\n  // Reference to the current view\n  this.view = view;\n  // Attribute values passed to the view instance\n  this.attributes = attributes;\n  // MarkupHooks to be called after insert into DOM of component\n  this.hooks = hooks;\n  // MarkupHooks to be called immediately before init of component\n  this.initHooks = initHooks;\n\n  // Used in EventModel\n  this._id = null;\n}\n\nContext.prototype.id = function() {\n  var count = ++this.meta.idCount;\n  return this.meta.idNamespace + '_' + count.toString(36);\n};\n\nContext.prototype.addBinding = function(binding) {\n  // Don't add bindings that wrap list items. Only their outer range is needed\n  if (binding.itemFor) return;\n  var expression = binding.template.expression;\n  // Don't rerender in unbound sections\n  if (expression ? expression.isUnbound(this) : this.unbound) return;\n  // Don't rerender to changes in a with expression\n  if (expression && expression.meta && expression.meta.blockType === 'with') return;\n  this.meta.addBinding(binding);\n};\nContext.prototype.removeBinding = function(binding) {\n  this.meta.removeBinding(binding);\n};\nContext.prototype.removeNode = function(node) {\n  this.meta.removeNode(node);\n};\n\nContext.prototype.child = function(expression) {\n  // Set or inherit the binding mode\n  var blockType = expression.meta && expression.meta.blockType;\n  var unbound = (blockType === 'unbound') ? true :\n    (blockType === 'bound') ? false :\n    this.unbound;\n  return new Context(this.meta, this.controller, this, unbound, expression);\n};\n\nContext.prototype.componentChild = function(component) {\n  return new Context(this.meta, component, this, this.unbound);\n};\n\n// Make a context for an item in an each block\nContext.prototype.eachChild = function(expression, index) {\n  var context = new Context(this.meta, this.controller, this, this.unbound, expression, index);\n  this.meta.addItemContext(context);\n  return context;\n};\n\nContext.prototype.viewChild = function(view, attributes, hooks, initHooks) {\n  return new Context(this.meta, this.controller, this, this.unbound, null, null, view, attributes, hooks, initHooks);\n};\n\nContext.prototype.forRelative = function(expression) {\n  var context = this;\n  while (context && context.expression === expression || context.view) {\n    context = context.parent;\n  }\n  return context;\n};\n\n// Returns the closest context which defined the named alias\nContext.prototype.forAlias = function(alias) {\n  var context = this;\n  while (context) {\n    if (context.alias === alias || context.keyAlias === alias) return context;\n    context = context.parent;\n  }\n};\n\n// Returns the closest containing context for a view attribute name or nothing\nContext.prototype.forAttribute = function(attribute) {\n  var context = this;\n  while (context) {\n    // Find the closest context associated with a view\n    if (context.view) {\n      var attributes = context.attributes;\n      if (!attributes) return;\n      if (attributes.hasOwnProperty(attribute)) return context;\n      // If the attribute isn't found, but the attributes inherit, continue\n      // looking in the next closest view context\n      if (!attributes.inherit && !attributes.extend) return;\n    }\n    context = context.parent;\n  }\n};\n\nContext.prototype.forViewParent = function() {\n  var context = this;\n  while (context) {\n    // Find the closest view\n    if (context.view) return context.parent;\n    context = context.parent;\n  }\n};\n\nContext.prototype.getView = function() {\n  var context = this;\n  while (context) {\n    // Find the closest view\n    if (context.view) return context.view;\n    context = context.parent;\n  }\n};\n\n// Returns the `this` value for a context\nContext.prototype.get = function() {\n  return (this.expression) ? this.expression.get(this) : this.controller.model.data;\n};\n\nContext.prototype.pause = function() {\n  this.meta.pauseCount++;\n};\n\nContext.prototype.unpause = function() {\n  if (--this.meta.pauseCount) return;\n  this.flush();\n};\n\nContext.prototype.flush = function() {\n  var pending = this.meta.pending;\n  var len = pending.length;\n  if (!len) return;\n  this.meta.pending = [];\n  for (var i = 0; i < len; i++) {\n    pending[i]();\n  }\n};\n\nContext.prototype.queue = function(cb) {\n  this.meta.pending.push(cb);\n};\n","(function (global){\nvar serializeObject = require('serialize-object');\nvar operatorFns = require('./operatorFns');\nvar templates = require('./templates');\n\nexports.lookup = lookup;\nexports.templateTruthy = templateTruthy;\nexports.pathSegments = pathSegments;\nexports.renderValue = renderValue;\nexports._outerDependency = outerDependency;\nexports.ExpressionMeta = ExpressionMeta;\n\nexports.Expression = Expression;\nexports.LiteralExpression = LiteralExpression;\nexports.PathExpression = PathExpression;\nexports.RelativePathExpression = RelativePathExpression;\nexports.AliasPathExpression = AliasPathExpression;\nexports.AttributePathExpression = AttributePathExpression;\nexports.BracketsExpression = BracketsExpression;\nexports.FnExpression = FnExpression;\nexports.OperatorExpression = OperatorExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ScopedModelExpression = ScopedModelExpression;\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\n// Unlike JS, `[]` is falsey. Otherwise, truthiness is the same as JS\nfunction templateTruthy(value) {\n  return (Array.isArray(value)) ? value.length > 0 : !!value;\n}\n\nfunction pathSegments(segments) {\n  var result = [];\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    result[i] = (typeof segment === 'object') ? segment.item : segment;\n  }\n  return result;\n}\n\nfunction renderValue(value, context) {\n  return (typeof value !== 'object') ? value :\n    (value instanceof templates.Template) ? renderTemplate(value, context) :\n    (Array.isArray(value)) ? renderArray(value, context) :\n    renderObject(value, context);\n}\nfunction renderTemplate(value, context) {\n  var i = 1000;\n  while (value instanceof templates.Template) {\n    if (--i < 0) throw new Error('Maximum template render passes exceeded');\n    value = value.get(context, true);\n  }\n  return value;\n}\nfunction renderArray(array, context) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (hasTemplateProperty(array[i])) {\n      return renderArrayProperties(array, context);\n    }\n  }\n  return array;\n}\nfunction renderObject(object, context) {\n  return (hasTemplateProperty(object)) ?\n    renderObjectProperties(object, context) : object;\n}\nfunction hasTemplateProperty(object) {\n  if (!object) return false;\n  if (global.Node && object instanceof global.Node) return false;\n  for (var key in object) {\n    if (object[key] instanceof templates.Template) return true;\n  }\n  return false;\n}\nfunction renderArrayProperties(array, context) {\n  var out = [];\n  for (var i = 0, len = array.length; i < len; i++) {\n    var item = renderObject(array[i], context);\n    out.push(item);\n  }\n  return out;\n}\nfunction renderObjectProperties(object, context) {\n  var out = {};\n  for (var key in object) {\n    var value = object[key];\n    out[key] = renderTemplate(value, context);\n  }\n  return out;\n}\n\nfunction ExpressionMeta(source, blockType, isEnd, as, keyAs, unescaped, bindType, valueType) {\n  this.source = source;\n  this.blockType = blockType;\n  this.isEnd = isEnd;\n  this.as = as;\n  this.keyAs = keyAs;\n  this.unescaped = unescaped;\n  this.bindType = bindType;\n  this.valueType = valueType;\n}\nExpressionMeta.prototype.module = 'expressions';\nExpressionMeta.prototype.type = 'ExpressionMeta';\nExpressionMeta.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.source\n  , this.blockType\n  , this.isEnd\n  , this.as\n  , this.keyAs\n  , this.unescaped\n  , this.bindType\n  , this.valueType\n  );\n};\n\nfunction Expression(meta) {\n  this.meta = meta;\n}\nExpression.prototype.module = 'expressions';\nExpression.prototype.type = 'Expression';\nExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.meta);\n};\nExpression.prototype.toString = function() {\n  return this.meta && this.meta.source;\n};\nExpression.prototype.truthy = function(context) {\n  var blockType = this.meta.blockType;\n  if (blockType === 'else') return true;\n  var value = this.get(context, true);\n  var truthy = templateTruthy(value);\n  return (blockType === 'unless') ? !truthy : truthy;\n};\nExpression.prototype.get = function() {};\n// Return the expression's segment list with context objects\nExpression.prototype.resolve = function() {};\n// Return a list of segment lists or null\nExpression.prototype.dependencies = function() {};\n// Return the pathSegments that the expression currently resolves to or null\nExpression.prototype.pathSegments = function(context) {\n  var segments = this.resolve(context);\n  return segments && pathSegments(segments);\n};\nExpression.prototype.set = function(context, value) {\n  var segments = this.pathSegments(context);\n  if (!segments) throw new Error('Expression does not support setting');\n  context.controller.model._set(segments, value);\n};\nExpression.prototype._getPatch = function(context, value) {\n  if (this.meta && this.meta.blockType) {\n    value = renderTemplate(value, context);\n  }\n  return (context && context.expression === this && context.item != null) ?\n    value && value[context.item] : value;\n};\nExpression.prototype._resolvePatch = function(context, segments) {\n  return (context && context.expression === this && context.item != null) ?\n    segments.concat(context) : segments;\n};\nExpression.prototype.isUnbound = function(context) {\n  // If the template being rendered has an explicit bindType keyword, such as:\n  // {{unbound #item.text}}\n  var bindType = this.meta && this.meta.bindType;\n  if (bindType === 'unbound') return true;\n  if (bindType === 'bound') return false;\n  // Otherwise, inherit from the context\n  return context.unbound;\n};\n\n\nfunction LiteralExpression(value, meta) {\n  this.value = value;\n  this.meta = meta;\n}\nLiteralExpression.prototype = new Expression();\nLiteralExpression.prototype.type = 'LiteralExpression';\nLiteralExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.value, this.meta);\n};\nLiteralExpression.prototype.get = function(context) {\n  return this._getPatch(context, this.value);\n};\n\nfunction PathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nPathExpression.prototype = new Expression();\nPathExpression.prototype.type = 'PathExpression';\nPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nPathExpression.prototype.get = function(context) {\n  var value = lookup(this.segments, context.controller.model.data);\n  return this._getPatch(context, value);\n};\nPathExpression.prototype.resolve = function(context) {\n  var segments = concat(context.controller._scope, this.segments);\n  return this._resolvePatch(context, segments);\n};\nPathExpression.prototype.dependencies = function(context, forInnerPath) {\n  return outerDependency(this, context, forInnerPath);\n};\n\nfunction RelativePathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nRelativePathExpression.prototype = new Expression();\nRelativePathExpression.prototype.type = 'RelativePathExpression';\nRelativePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nRelativePathExpression.prototype.get = function(context) {\n  var relativeContext = context.forRelative(this);\n  var value = relativeContext.get();\n  if (this.segments.length) {\n    value = renderTemplate(value, relativeContext);\n    value = lookup(this.segments, value);\n  }\n  return this._getPatch(context, value);\n};\nRelativePathExpression.prototype.resolve = function(context) {\n  var relativeContext = context.forRelative(this);\n  var base = (relativeContext.expression) ?\n    relativeContext.expression.resolve(relativeContext) :\n    [];\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nRelativePathExpression.prototype.dependencies = function(context, forInnerPath) {\n  // Return inner dependencies from our ancestor\n  // (e.g., {{ with foo[bar] }} ... {{ this.x }} has 'bar' as a dependency.)\n  var relativeContext = context.forRelative(this);\n  var inner = relativeContext.expression &&\n    relativeContext.expression.dependencies(relativeContext, true);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(outer, inner);\n};\n\nfunction AliasPathExpression(alias, segments, meta) {\n  this.alias = alias;\n  this.segments = segments;\n  this.meta = meta;\n}\nAliasPathExpression.prototype = new Expression();\nAliasPathExpression.prototype.type = 'AliasPathExpression';\nAliasPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.alias, this.segments, this.meta);\n};\nAliasPathExpression.prototype.get = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    return aliasContext.item;\n  }\n  var value = aliasContext.get();\n  if (this.segments.length) {\n    value = renderTemplate(value, aliasContext);\n    value = lookup(this.segments, value);\n  }\n  return this._getPatch(context, value);\n};\nAliasPathExpression.prototype.resolve = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) return;\n  var base = aliasContext.expression.resolve(aliasContext);\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAliasPathExpression.prototype.dependencies = function(context, forInnerPath) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    // For keyAliases, use a dependency of the entire list, so that it will\n    // always update when the list changes in any way. This is over-binding,\n    // but would otherwise be much more complex\n    var base = aliasContext.expression.resolve(aliasContext.parent);\n    return [base];\n  }\n  var inner = aliasContext.expression.dependencies(aliasContext, true);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(outer, inner);\n};\n\nfunction AttributePathExpression(attribute, segments, meta) {\n  this.attribute = attribute;\n  this.segments = segments;\n  this.meta = meta;\n}\nAttributePathExpression.prototype = new Expression();\nAttributePathExpression.prototype.type = 'AttributePathExpression';\nAttributePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.attribute, this.segments, this.meta);\n};\nAttributePathExpression.prototype.get = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[this.attribute];\n  if (this.segments.length) {\n    value = renderTemplate(value, attributeContext);\n    value = lookup(this.segments, value);\n  }\n  return this._getPatch(context, value);\n};\nAttributePathExpression.prototype.resolve = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  // Attributes are either a ParentWrapper or a literal value\n  var value = attributeContext && attributeContext.attributes[this.attribute];\n  var base = value && (typeof value.resolve === 'function') &&\n    value.resolve(attributeContext);\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAttributePathExpression.prototype.dependencies = function(context, forInnerPath) {\n  var attributeContext = context.forAttribute(this.attribute);\n  // Attributes are either a ParentWrapper or a literal value\n  var value = attributeContext && attributeContext.attributes[this.attribute];\n  var inner = value && (typeof value.dependencies === 'function') &&\n    value.dependencies(attributeContext, true);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(outer, inner);\n};\n\nfunction BracketsExpression(before, inside, afterSegments, meta) {\n  this.before = before;\n  this.inside = inside;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nBracketsExpression.prototype = new Expression();\nBracketsExpression.prototype.type = 'BracketsExpression';\nBracketsExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.before, this.inside, this.afterSegments, this.meta);\n};\nBracketsExpression.prototype.get = function(context) {\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n  var before = this.before.get(context);\n  if (!before) return;\n  var base = before[inside];\n  var value = (this.afterSegments) ? lookup(this.afterSegments, base) : base;\n  return this._getPatch(context, value);\n};\nBracketsExpression.prototype.resolve = function(context) {\n  // Get and split the current value of the expression inside the brackets\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n\n  // Concat the before, inside, and optional after segments\n  var base = this.before.resolve(context);\n  if (!base) return;\n  var segments = (this.afterSegments) ?\n    base.concat(inside, this.afterSegments) :\n    base.concat(inside);\n  return this._resolvePatch(context, segments);\n};\nBracketsExpression.prototype.dependencies = function(context, forInnerPath) {\n  var before = this.before.dependencies(context, true);\n  var inner = this.inside.dependencies(context);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(concat(outer, inner), before);\n};\n\nfunction FnExpression(segments, args, afterSegments, meta) {\n  this.segments = segments;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  var parentSegments = segments && segments.slice();\n  this.lastSegment = parentSegments && parentSegments.pop();\n  this.parentSegments = (parentSegments && parentSegments.length) ? parentSegments : null;\n}\nFnExpression.prototype = new Expression();\nFnExpression.prototype.type = 'FnExpression';\nFnExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.args, this.afterSegments, this.meta);\n};\nFnExpression.prototype.get = function(context) {\n  var value = this.apply(context);\n  // Lookup property underneath computed value if needed\n  if (this.afterSegments) {\n    value = lookup(this.afterSegments, value);\n  }\n  return this._getPatch(context, value);\n};\nFnExpression.prototype.apply = function(context, extraInputs) {\n  var parent = this._lookupParent(context);\n  var fn = parent[this.lastSegment];\n  var getFn = fn.get || fn;\n  var out = this._applyFn(getFn, context, extraInputs, parent);\n  return out;\n};\nFnExpression.prototype._lookupParent = function(context) {\n  // Lookup function on current controller\n  var controller = context.controller;\n  var segments = this.parentSegments;\n  var parent = (segments) ? lookup(segments, controller) : controller;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Otherwise lookup function on page\n  var page = controller.page;\n  if (controller !== page) {\n    parent = (segments) ? lookup(segments, page) : page;\n    if (parent && parent[this.lastSegment]) return parent;\n  }\n  // Otherwise lookup function on global\n  parent = (segments) ? lookup(segments, global) : global;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Throw if not found\n  throw new Error('Function not found for: ' + this.segments.join('.'));\n};\nFnExpression.prototype._getInputs = function(context) {\n  var inputs = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var value = this.args[i].get(context);\n    inputs.push(renderValue(value, context));\n  }\n  return inputs;\n};\nFnExpression.prototype._applyFn = function(fn, context, extraInputs, thisArg) {\n  // Apply if there are no path inputs\n  if (!this.args) {\n    return (extraInputs) ?\n      fn.apply(thisArg, extraInputs) :\n      fn.call(thisArg);\n  }\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  if (extraInputs) {\n    for (var i = 0, len = extraInputs.length; i < len; i++) {\n      inputs.push(extraInputs[i]);\n    }\n  }\n  return fn.apply(thisArg, inputs);\n};\nFnExpression.prototype.dependencies = function(context) {\n  var dependencies = [];\n  if (!this.args) return dependencies;\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context);\n    var firstDependency = argDependencies && argDependencies[0];\n    if (!firstDependency) continue;\n    if (firstDependency[firstDependency.length - 1] !== '*') {\n      argDependencies[0] = argDependencies[0].concat('*');\n    }\n    for (var j = 0, jLen = argDependencies.length; j < jLen; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n  }\n  return dependencies;\n};\nFnExpression.prototype.set = function(context, value) {\n  var controller = context.controller;\n  var fn, parent;\n  while (controller) {\n    parent = (this.parentSegments) ?\n      lookup(this.parentSegments, controller) :\n      controller;\n    fn = parent && parent[this.lastSegment];\n    if (fn) break;\n    controller = controller.parent;\n  }\n  var setFn = fn && fn.set;\n  if (!setFn) throw new Error('No setter function for: ' + this.segments.join('.'));\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = setFn.apply(parent, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction NewExpression(segments, args, afterSegments, meta) {\n  FnExpression.call(this, segments, args, afterSegments, meta);\n}\nNewExpression.prototype = new FnExpression();\nNewExpression.prototype.type = 'NewExpression';\nNewExpression.prototype._applyFn = function(Fn, context) {\n  // Apply if there are no path inputs\n  if (!this.args) return new Fn();\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  inputs.unshift(null);\n  return new (Fn.bind.apply(Fn, inputs))();\n};\n\nfunction OperatorExpression(name, args, afterSegments, meta) {\n  this.name = name;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  this.getFn = operatorFns.get[name];\n  this.setFn = operatorFns.set[name];\n}\nOperatorExpression.prototype = new FnExpression();\nOperatorExpression.prototype.type = 'OperatorExpression';\nOperatorExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.args, this.afterSegments, this.meta);\n};\nOperatorExpression.prototype.apply = function(context) {\n  var inputs = this._getInputs(context);\n  return this.getFn.apply(null, inputs);\n};\nOperatorExpression.prototype.set = function(context, value) {\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = this.setFn.apply(null, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction SequenceExpression(args, afterSegments, meta) {\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nSequenceExpression.prototype = new OperatorExpression();\nSequenceExpression.prototype.type = 'SequenceExpression';\nSequenceExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.args, this.afterSegments, this.meta);\n};\nSequenceExpression.prototype.name = ',';\nSequenceExpression.prototype.getFn = operatorFns.get[','];\nSequenceExpression.prototype.resolve = function(context) {\n  var last = this.args[this.args.length - 1];\n  return last.resolve(context);\n};\nSequenceExpression.prototype.dependencies = function(context, forInnerPath) {\n  var dependencies = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context, forInnerPath);\n    for (var j = 0, jLen = argDependencies.length; j < jLen; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n  }\n  return dependencies;\n};\n\nfunction ScopedModelExpression(expression, meta) {\n  this.expression = expression;\n  this.meta = meta;\n}\nScopedModelExpression.prototype = new Expression();\nScopedModelExpression.prototype.type = 'ScopedModelExpression';\nScopedModelExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.meta);\n};\n// Return a scoped model instead of the value\nScopedModelExpression.prototype.get = function(context) {\n  var segments = this.pathSegments(context);\n  if (!segments) return;\n  return context.controller.model.scope(segments.join('.'));\n};\n// Delegate other methods to the inner expression\nScopedModelExpression.prototype.resolve = function(context) {\n  return this.expression.resolve(context);\n};\nScopedModelExpression.prototype.dependencies = function(context, forInnerPath) {\n  return this.expression.dependencies(context, forInnerPath);\n};\nScopedModelExpression.prototype.pathSegments = function(context) {\n  return this.expression.pathSegments(context);\n};\nScopedModelExpression.prototype.set = function(context, value) {\n  return this.expression.set(context, value);\n};\n\nfunction outerDependency(expression, context, forInnerPath) {\n  if (forInnerPath) return;\n  var val = expression.resolve(context);\n  if (typeof val === 'undefined') return;\n  return [val];\n}\n\nfunction concat(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a.concat(b);\n}\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})","// `-` and `+` can be either unary or binary, so all unary operators are\n// postfixed with `U` to differentiate\n\nexports.get = {\n  // Unary operators\n  '!U': function(value) {\n    return !value;\n  }\n, '-U': function(value) {\n    return -value;\n  }\n, '+U': function(value) {\n    return +value;\n  }\n, '~U': function(value) {\n    return ~value;\n  }\n, 'typeofU': function(value) {\n    return typeof value;\n  }\n  // Binary operators\n, '||': function(left, right) {\n    return left || right;\n  }\n, '&&': function(left, right) {\n    return left && right;\n  }\n, '|': function(left, right) {\n    return left | right;\n  }\n, '^': function(left, right) {\n    return left ^ right;\n  }\n, '&': function(left, right) {\n    return left & right;\n  }\n, '==': function(left, right) {\n    return left == right; // jshint ignore:line\n  }\n, '!=': function(left, right) {\n    return left != right; // jshint ignore:line\n  }\n, '===': function(left, right) {\n    return left === right;\n  }\n, '!==': function(left, right) {\n    return left !== right;\n  }\n, '<': function(left, right) {\n    return left < right;\n  }\n, '>': function(left, right) {\n    return left > right;\n  }\n, '<=': function(left, right) {\n    return left <= right;\n  }\n, '>=': function(left, right) {\n    return left >= right;\n  }\n, 'instanceof': function(left, right) {\n    return left instanceof right;\n  }\n, 'in': function(left, right) {\n    return left in right;\n  }\n, '<<': function(left, right) {\n    return left << right;\n  }\n, '>>': function(left, right) {\n    return left >> right;\n  }\n, '>>>': function(left, right) {\n    return left >>> right;\n  }\n, '+': function(left, right) {\n    return left + right;\n  }\n, '-': function(left, right) {\n    return left - right;\n  }\n, '*': function(left, right) {\n    return left * right;\n  }\n, '/': function(left, right) {\n    return left / right;\n  }\n, '%': function(left, right) {\n    return left % right;\n  }\n  // Conditional operator\n, '?': function(test, consequent, alternate) {\n    return (test) ? consequent : alternate;\n  }\n, // Sequence\n  ',': function() {\n    return arguments[arguments.length - 1];\n  }\n  // Array literal\n, '[]': function() {\n    return Array.prototype.slice.call(arguments);\n  }\n  // Object literal\n, '{}': function() {\n    var value = {};\n    for (var i = 0, len = arguments.length; i < len; i += 2) {\n      var key = arguments[i];\n      value[key] = arguments[i + 1];\n    }\n    return value;\n  }\n};\n\nexports.set = {\n  // Unary operators\n  '!U': function(value) {\n    return [!value];\n  }\n, '-U': function(value) {\n    return [-value];\n  }\n  // Binary operators\n, '==': function(value, left, right) {\n    if (value) return [right];\n  }\n, '===': function(value, left, right) {\n    if (value) return [right];\n  }\n, 'in': function(value, left, right) {\n    right[left] = true;\n    return {1: right};\n  }\n, '+': function(value, left, right) {\n    return [value - right];\n  }\n, '-': function(value, left, right) {\n    return [value + right];\n  }\n, '*': function(value, left, right) {\n    return [value / right];\n  }\n, '/': function(value, left, right) {\n    return [value * right];\n  }\n};\n","var saddle = require('saddle');\nvar serializeObject = require('serialize-object');\n\n(function() {\n  for (var key in saddle) {\n    exports[key] = saddle[key];\n  }\n})();\n\nexports.View = View;\nexports.ViewInstance = ViewInstance;\nexports.DynamicViewInstance = DynamicViewInstance;\nexports.ParentWrapper = ParentWrapper;\n\nexports.Views = Views;\n\nexports.MarkupHook = MarkupHook;\nexports.ElementOn = ElementOn;\nexports.ComponentOn = ComponentOn;\nexports.ComponentMarker = ComponentMarker;\nexports.AsProperty = AsProperty;\nexports.AsObject = AsObject;\nexports.AsObjectComponent = AsObjectComponent;\nexports.AsArray = AsArray;\nexports.AsArrayComponent = AsArrayComponent;\n\nexports.emptyTemplate = new saddle.Template([]);\n\n// Add ::isUnbound to Template && Binding\nsaddle.Template.prototype.isUnbound = function(context) {\n  return context.unbound;\n};\nsaddle.Binding.prototype.isUnbound = function() {\n  return this.template.expression.isUnbound(this.context);\n};\n\n// Add Template::resolve\nsaddle.Template.prototype.resolve = function() {};\n\n// The Template::dependencies method is specific to how Derby bindings work,\n// so extend all of the Saddle Template types here\nsaddle.Template.prototype.dependencies = function(context) {\n  return getArrayDependencies(this.content, context);\n};\nsaddle.Doctype.prototype.dependencies = function() {};\nsaddle.Text.prototype.dependencies = function() {};\nsaddle.DynamicText.prototype.dependencies = function(context) {\n  return getDependencies(this.expression, context);\n};\nsaddle.Comment.prototype.dependencies = function() {};\nsaddle.DynamicComment.prototype.dependencies = function(context) {\n  return getDependencies(this.expression, context);\n};\nsaddle.Element.prototype.dependencies = function(context) {\n  var items = getMapDependencies(this.attributes, context);\n  return getArrayDependencies(this.content, context, items);\n};\nsaddle.Block.prototype.dependencies = function(context) {\n  var items = getDependencies(this.expression, context);\n  return getArrayDependencies(this.content, context, items);\n};\nsaddle.ConditionalBlock.prototype.dependencies = function(context) {\n  var items = getArrayDependencies(this.expressions, context);\n  return getArrayOfArrayDependencies(this.contents, context, items);\n};\nsaddle.EachBlock.prototype.dependencies = function(context) {\n  var items = getDependencies(this.expression, context);\n  items = getArrayDependencies(this.content, context, items);\n  return getArrayDependencies(this.elseContent, context, items);\n};\nsaddle.Attribute.prototype.dependencies = function() {};\nsaddle.DynamicAttribute.prototype.dependencies = function(context) {\n  return getDependencies(this.expression, context);\n};\n\nfunction getArrayOfArrayDependencies(expressions, context, items) {\n  if (!expressions) return items;\n  for (var i = 0, len = expressions.length; i < len; i++) {\n    items = getArrayDependencies(expressions[i], context, items);\n  }\n  return items;\n}\nfunction getArrayDependencies(expressions, context, items) {\n  if (!expressions) return items;\n  for (var i = 0, len = expressions.length; i < len; i++) {\n    items = getDependencies(expressions[i], context, items);\n  }\n  return items;\n}\nfunction getMapDependencies(expressions, context, items) {\n  if (!expressions) return items;\n  for (var key in expressions) {\n    items = getDependencies(expressions[key], context, items);\n  }\n  return items;\n}\nfunction getDependencies(expression, context, items) {\n  var dependencies = expression && expression.dependencies(context);\n  if (!dependencies) return items;\n  for (var i = 0, len = dependencies.length; i < len; i++) {\n    items || (items = []);\n    items.push(dependencies[i]);\n  }\n  return items;\n}\n\nfunction ViewAttributesMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    this[items[i]] = true;\n  }\n}\nfunction ViewArraysMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i].split('/');\n    this[item[0]] = item[1] || item[0];\n  }\n}\nfunction View(views, name, source, options) {\n  this.views = views;\n  this.name = name;\n  this.source = source;\n  this.options = options;\n\n  var nameSegments = (this.name || '').split(':');\n  var lastSegment = nameSegments.pop();\n  this.namespace = nameSegments.join(':');\n  this.registeredName = (lastSegment === 'index') ? this.namespace : this.name;\n\n  this.attributesMap = options && options.attributes &&\n    new ViewAttributesMap(options.attributes);\n  this.arraysMap = options && options.arrays &&\n    new ViewArraysMap(options.arrays);\n  // The empty string is considered true for easier HTML attribute parsing\n  this.unminified = options && (options.unminified || options.unminified === '');\n  this.string = options && (options.string || options.string === '');\n  this.literal = options && (options.literal || options.literal === '');\n  this.template = null;\n  this.componentFactory = null;\n}\nView.prototype = Object.create(saddle.Template.prototype);\nView.prototype.type = 'View';\nView.prototype.serialize = function() {\n  return null;\n};\nView.prototype._isComponent = function(context) {\n  return this.componentFactory &&\n    context.attributes && !context.attributes.extend;\n};\nView.prototype._initComponent = function(context) {\n  return (this._isComponent(context)) ?\n    this.componentFactory.init(context) : context;\n};\nView.prototype._queueCreate = function(context, viewContext) {\n  if (this._isComponent(context)) {\n    var componentFactory = this.componentFactory;\n    context.queue(function queuedCreate() {\n      componentFactory.create(viewContext);\n    });\n\n    if (!context.hooks) return;\n    context.queue(function queuedComponentHooks() {\n      // Kick off hooks if view instance specified `on` or `as` attributes\n      for (var i = 0, len = context.hooks.length; i < len; i++) {\n        context.hooks[i].emit(context, viewContext.controller);\n      }\n    });\n  }\n};\nView.prototype.get = function(context, unescaped) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  return template.get(viewContext, unescaped);\n};\nView.prototype.getFragment = function(context, binding) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var fragment = template.getFragment(viewContext, binding);\n  this._queueCreate(context, viewContext);\n  return fragment;\n};\nView.prototype.appendTo = function(parent, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  template.appendTo(parent, viewContext);\n  this._queueCreate(context, viewContext);\n};\nView.prototype.attachTo = function(parent, node, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var node = template.attachTo(parent, node, viewContext);\n  this._queueCreate(context, viewContext);\n  return node;\n};\nView.prototype.dependencies = function(context) {\n  var template = this.template || this.parse();\n  return template.dependencies(context);\n};\nView.prototype.parse = function() {\n  this._parse();\n  if (this.componentFactory) {\n    var hooks = [new ComponentMarker()];\n    var marker = new saddle.Comment(this.name, hooks);\n    this.template.content.unshift(marker);\n  }\n  return this.template;\n};\n// View.prototype._parse is defined in parsing.js, so that it doesn't have to\n// be included in the client if templates are all parsed server-side\nView.prototype._parse = function() {\n  throw new Error('View parsing not available');\n};\n\nfunction ViewInstance(name, attributes, hooks, initHooks) {\n  this.name = name;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n  this.view = null;\n}\nViewInstance.prototype = Object.create(saddle.Template.prototype);\nViewInstance.prototype.type = 'ViewInstance';\nViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.attributes, this.hooks, this.initHooks);\n};\nViewInstance.prototype.get = function(context, unescaped) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.get(viewContext, unescaped);\n};\nViewInstance.prototype.getFragment = function(context, binding) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.getFragment(viewContext, binding);\n};\nViewInstance.prototype.appendTo = function(parent, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  view.appendTo(parent, viewContext);\n};\nViewInstance.prototype.attachTo = function(parent, node, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.attachTo(parent, node, viewContext);\n};\nViewInstance.prototype.dependencies = function(context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.dependencies(viewContext);\n};\nViewInstance.prototype._find = function(context) {\n  if (this.view) return this.view;\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  this.view = context.meta.views.find(this.name, namespace);\n  if (!this.view) {\n    var message = context.meta.views.findErrorMessage(this.name, contextView);\n    throw new Error(message);\n  }\n  return this.view;\n};\n\nfunction DynamicViewInstance(nameExpression, attributes, hooks, initHooks) {\n  this.nameExpression = nameExpression;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n}\nDynamicViewInstance.prototype = Object.create(ViewInstance.prototype);\nDynamicViewInstance.prototype.type = 'DynamicViewInstance';\nDynamicViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.nameExpression, this.attributes, this.hooks, this.initHooks);\n};\nDynamicViewInstance.prototype._find = function(context) {\n  var name = this.nameExpression.get(context);\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  var view = name && context.meta.views.find(name, namespace);\n  return view || exports.emptyTemplate;\n};\n\nfunction ParentWrapper(template, expression) {\n  this.template = template;\n  this.expression = expression;\n}\nParentWrapper.prototype = Object.create(saddle.Template.prototype);\nParentWrapper.prototype.type = 'ParentWrapper';\nParentWrapper.prototype.serialize = function() {\n  return serializeObject.instance(this, this.template, this.expression);\n};\nParentWrapper.prototype.get = function(context, unescaped) {\n  return (this.expression || this.template).get(context.forViewParent(), unescaped);\n};\nParentWrapper.prototype.getFragment = function(context, binding) {\n  return this.template.getFragment(context.forViewParent(), binding);\n};\nParentWrapper.prototype.appendTo = function(parent, context) {\n  this.template.appendTo(parent, context.forViewParent());\n};\nParentWrapper.prototype.attachTo = function(parent, node, context) {\n  return this.template.attachTo(parent, node, context.forViewParent());\n};\nParentWrapper.prototype.resolve = function(context) {\n  return this.expression && this.expression.resolve(context.forViewParent());\n};\nParentWrapper.prototype.dependencies = function(context, forInnerPath) {\n  return (this.expression || this.template).dependencies(context.forViewParent(), forInnerPath);\n};\n\nfunction ViewsMap() {}\nfunction Views() {\n  this.nameMap = new ViewsMap();\n  this.tagMap = new ViewsMap();\n  // TODO: elementMap is deprecated and should be removed with Derby 0.6.0\n  this.elementMap = this.tagMap;\n}\nViews.prototype.find = function(name, namespace) {\n  var map = this.nameMap;\n\n  // Exact match lookup\n  var exactName = (namespace) ? namespace + ':' + name : name;\n  var match = map[exactName];\n  if (match) return match;\n\n  // Relative lookup\n  var segments = name.split(':');\n  var segmentsDepth = segments.length;\n  if (namespace) segments = namespace.split(':').concat(segments);\n  // Iterate through segments, leaving the `segmentsDepth` segments and\n  // removing the second to `segmentsDepth` segment to traverse up the\n  // namespaces. Decrease `segmentsDepth` if not found and repeat again.\n  while (segmentsDepth > 0) {\n    var testSegments = segments.slice();\n    while (testSegments.length > segmentsDepth) {\n      testSegments.splice(-1 - segmentsDepth, 1);\n      var testName = testSegments.join(':');\n      var match = map[testName];\n      if (match) return match;\n    }\n    segmentsDepth--;\n  }\n};\nViews.prototype.register = function(name, source, options) {\n  var mapName = name.replace(/:index$/, '');\n  var view = this.nameMap[mapName];\n  if (view) {\n    // Recreate the view if it already exists. We re-apply the constructor\n    // instead of creating a new view object so that references to object\n    // can be cached after finding the first time\n    var componentFactory = view.componentFactory;\n    View.call(view, this, name, source, options);\n    view.componentFactory = componentFactory;\n  } else {\n    view = new View(this, name, source, options);\n  }\n  this.nameMap[mapName] = view;\n  // TODO: element is deprecated and should be removed with Derby 0.6.0\n  var tagName = options && (options.tag || options.element);\n  if (tagName) this.tagMap[tagName] = view;\n  return view;\n};\nViews.prototype.serialize = function(options) {\n  var out = 'function(derbyTemplates, views) {' +\n    'var expressions = derbyTemplates.expressions;' +\n    'var templates = derbyTemplates.templates;';\n  for (var name in this.nameMap) {\n    var view = this.nameMap[name];\n    if (options && !options.server && view.options && view.options.serverOnly) continue;\n    var template = view.template || view.parse();\n    out += 'views.register(' + serializeObject.args([\n      view.name\n    , (options && options.minify) ? null : view.source\n    , (hasKeys(view.options)) ? view.options : null\n    ]) + ').template = ' + template.serialize() + ';';\n  }\n  return out + '}';\n};\nViews.prototype.findErrorMessage = function(name, contextView) {\n  var names = Object.keys(this.nameMap);\n  var message = 'Cannot find view \"' + name + '\" in' +\n    [''].concat(names).join('\\n  ') + '\\n';\n  if (contextView) {\n    message += '\\nWithin template \"' + contextView.name + '\":\\n' + contextView.source;\n  }\n  return message;\n};\n\n\nfunction MarkupHook() {}\nMarkupHook.prototype.module = saddle.Template.prototype.module;\n\nfunction ElementOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nElementOn.prototype = Object.create(MarkupHook.prototype);\nElementOn.prototype.type = 'ElementOn';\nElementOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nElementOn.prototype.emit = function(context, element) {\n  var elementOn = this;\n  if (this.name === 'create') {\n    this.apply(context, element);\n\n  } else if (this.name === 'destroy') {\n    var destroyListeners = element.$destroyListeners || (element.$destroyListeners = []);\n    destroyListeners.push(function elementOnDestroy() {\n      elementOn.apply(context, element);\n    });\n\n  } else {\n    element.addEventListener(this.name, function elementOnListener(event) {\n      return elementOn.apply(context, element, event);\n    }, false);\n  }\n};\nElementOn.prototype.apply = function(context, element, event) {\n  var modelData = context.controller.model.data;\n  modelData.$event = event;\n  modelData.$element = element;\n  var out = this.expression.apply(context);\n  delete modelData.$event;\n  delete modelData.$element;\n  return out;\n};\n\nfunction ComponentOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nComponentOn.prototype = Object.create(MarkupHook.prototype);\nComponentOn.prototype.type = 'ComponentOn';\nComponentOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nComponentOn.prototype.emit = function(context, component) {\n  var expression = this.expression;\n  component.on(this.name, function componentOnListener() {\n    var args = arguments.length && Array.prototype.slice.call(arguments);\n    return expression.apply(context, args);\n  });\n};\n\nfunction ComponentMarker() {}\nComponentMarker.prototype = Object.create(MarkupHook.prototype);\nComponentMarker.prototype.type = 'ComponentMarker';\nComponentMarker.prototype.serialize = function() {\n  return serializeObject.instance(this);\n};\nComponentMarker.prototype.emit = function(context, node) {\n  node.$component = context.controller;\n  context.controller.markerNode = node;\n};\n\nfunction AsProperty(segments) {\n  this.segments = segments;\n  this.lastSegment = segments.pop();\n}\nAsProperty.prototype = Object.create(MarkupHook.prototype);\nAsProperty.prototype.type = 'AsProperty';\nAsProperty.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments);\n};\nAsProperty.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  node[this.lastSegment] = target;\n};\n\nfunction AsObject(segments, keyExpression) {\n  AsProperty.call(this, segments);\n  this.keyExpression = keyExpression;\n}\nAsObject.prototype = Object.create(AsProperty.prototype);\nAsObject.prototype.type = 'AsObject';\nAsObject.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var object = node[this.lastSegment] || (node[this.lastSegment] = {});\n  var key = this.keyExpression.get(context);\n  object[key] = target;\n  this.addListeners(target, object, key);\n};\nAsObject.prototype.addListeners = function(target, object, key) {\n  this.addDestroyListener(target, function asObjectDestroy() {\n    delete object[key];\n  });\n};\nAsObject.prototype.addDestroyListener = function(target, listener) {\n  var listeners = target.$destroyListeners || (target.$destroyListeners = []);\n  listeners.push(listener);\n};\n\nfunction AsObjectComponent(segments, keyExpression) {\n  AsObject.call(this, segments, keyExpression);\n}\nAsObjectComponent.prototype = Object.create(AsObject.prototype);\nAsObjectComponent.prototype.type = 'AsObjectComponent';\nAsObjectComponent.prototype.addDestroyListener = function(target, listener) {\n  target.on('destroy', listener);\n};\n\nfunction AsArray(segments) {\n  AsProperty.call(this, segments);\n}\nAsArray.prototype = Object.create(AsProperty.prototype);\nAsArray.prototype.type = 'AsArray';\nAsArray.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var array = node[this.lastSegment] || (node[this.lastSegment] = []);\n\n  // Iterate backwards, since rendering will usually append\n  for (var i = array.length; i--;) {\n    var item = array[i];\n    // Don't add an item if already in the array\n    if (item === target) return;\n    var mask = this.comparePosition(target, item);\n    // If the emitted target is after the current item in the document,\n    // insert it next in the array\n    // Node.DOCUMENT_POSITION_FOLLOWING = 4\n    if (mask & 4) {\n      array.splice(i + 1, 0, target);\n      this.addListeners(target, array);\n      return;\n    }\n  }\n  // Add to the beginning if before all items\n  array.unshift(target);\n  this.addListeners(target, array);\n};\nAsArray.prototype.addListeners = function(target, array) {\n  this.addDestroyListener(target, function asArrayDestroy() {\n    var index = array.indexOf(target);\n    if (index !== -1) array.splice(index, 1);\n  });\n};\nAsArray.prototype.comparePosition = function(target, item) {\n  return item.compareDocumentPosition(target);\n};\nAsArray.prototype.addDestroyListener = AsObject.prototype.addDestroyListener;\n\nfunction AsArrayComponent(segments) {\n  AsArray.call(this, segments);\n}\nAsArrayComponent.prototype = Object.create(AsArray.prototype);\nAsArrayComponent.prototype.type = 'AsArrayComponent';\nAsArrayComponent.prototype.comparePosition = function(target, item) {\n  return item.markerNode.compareDocumentPosition(target.markerNode);\n};\nAsArrayComponent.prototype.addDestroyListener = AsObjectComponent.prototype.addDestroyListener;\n\nfunction traverseAndCreate(node, segments) {\n  var len = segments.length;\n  if (!len) return node;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    node = node[segment] || (node[segment] = {});\n  }\n  return node;\n}\n\nfunction hasKeys(value) {\n  if (!value) return false;\n  for (var key in value) {\n    return true;\n  }\n  return false;\n}\n","var Derby = require('./lib/Derby');\nmodule.exports = new Derby();\n","/*\n * App.js\n *\n * Provides the glue between views, controllers, and routes for an\n * application's functionality. Apps are responsible for creating pages.\n *\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar tracks = require('tracks');\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar documentListeners = require('./documentListeners');\nvar Page = require('./Page');\nvar serializedViews = require('./_views');\n\nmodule.exports = App;\n\nfunction App(derby, name, filename) {\n  EventEmitter.call(this);\n  this.derby = derby;\n  this.name = name;\n  this.filename = filename;\n  this.scriptHash = '{{DERBY_SCRIPT_HASH}}';\n  this.bundledAt = '{{DERBY_BUNDLED_AT}}';\n  this.Page = createAppPage();\n  this.proto = this.Page.prototype;\n  this.views = new derbyTemplates.templates.Views();\n  this.tracksRoutes = tracks.setup(this);\n  this.model = null;\n  this.page = null;\n  this._init();\n}\n\nfunction createAppPage() {\n  // Inherit from Page so that we can add controller functions as prototype\n  // methods on this app's pages\n  function AppPage() {\n    Page.apply(this, arguments);\n  }\n  AppPage.prototype = Object.create(Page.prototype);\n  return AppPage;\n}\n\nutil.mergeInto(App.prototype, EventEmitter.prototype);\n\n// Overriden on server\nApp.prototype._init = function() {\n  this._waitForAttach = true;\n  this._cancelAttach = false;\n  this.model = new this.derby.Model();\n  this.model.createConnection();\n  serializedViews(derbyTemplates, this.views);\n  // Must init async so that app.on('model') listeners can be added.\n  // Must also wait for content ready so that bundle is fully downloaded.\n  this._contentReady();\n};\nApp.prototype._finishInit = function() {\n  this.emit('model', this.model);\n  var script = this._getScript();\n  var data = JSON.parse(script.nextSibling.innerHTML);\n  util.isProduction = data.nodeEnv === 'production';\n  if (!util.isProduction) this._autoRefresh();\n  this.model.unbundle(data);\n  var page = this.createPage();\n  page.params = this.model.get('$render.params');\n  this.emit('ready', page);\n  this._waitForAttach = false;\n  // Instead of attaching, do a route and render if a link was clicked before\n  // the page finished attaching\n  if (this._cancelAttach) {\n    this.history.refresh();\n    return;\n  }\n  // Since an attachment failure is *fatal* and could happen as a result of a\n  // browser extension like AdBlock, an invalid template, or a small bug in\n  // Derby or Saddle, re-render from scratch on production failures\n  if (util.isProduction) {\n    try {\n      page.attach();\n    } catch (err) {\n      this.history.refresh();\n      console.warn('attachment error', err.stack);\n    }\n  } else {\n    page.attach();\n  }\n  this.emit('load', page);\n};\n// Modified from: https://github.com/addyosmani/jquery.parts/blob/master/jquery.documentReady.js\nApp.prototype._contentReady = function() {\n  // Is the DOM ready to be used? Set to true once it occurs.\n  var isReady = false;\n  var app = this;\n\n  // The ready event handler\n  function onDOMContentLoaded() {\n    if (document.addEventListener) {\n      document.removeEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    } else {\n      // we're here because readyState !== 'loading' in oldIE\n      // which is good enough for us to call the dom ready!\n      document.detachEvent('onreadystatechange', onDOMContentLoaded);\n    }\n    onDOMReady();\n  }\n\n  // Handle when the DOM is ready\n  function onDOMReady() {\n    // Make sure that the DOM is not already loaded\n    if (isReady) return;\n    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n    if (!document.body) return setTimeout(onDOMReady, 0);\n    // Remember that the DOM is ready\n    isReady = true;\n    // Make sure this is always async and then finishin init\n    setTimeout(function() {\n      app._finishInit();\n    }, 0);\n  }\n\n  // The DOM ready check for Internet Explorer\n  function doScrollCheck() {\n    if (isReady) return;\n    try {\n      // If IE is used, use the trick by Diego Perini\n      // http://javascript.nwbox.com/IEContentLoaded/\n      document.documentElement.doScroll('left');\n    } catch (err) {\n      setTimeout(doScrollCheck, 0);\n      return;\n    }\n    // and execute any waiting functions\n    onDOMReady();\n  }\n\n  // Catch cases where called after the browser event has already occurred.\n  if (document.readyState !== 'loading') return onDOMReady();\n\n  // Mozilla, Opera and webkit nightlies currently support this event\n  if (document.addEventListener) {\n    // Use the handy event callback\n    document.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    // A fallback to window.onload, that will always work\n    window.addEventListener('load', onDOMContentLoaded, false);\n    // If IE event model is used\n  } else if (document.attachEvent) {\n    // ensure firing before onload,\n    // maybe late but safe also for iframes\n    document.attachEvent('onreadystatechange', onDOMContentLoaded);\n    // A fallback to window.onload, that will always work\n    window.attachEvent('onload', onDOMContentLoaded);\n    // If IE and not a frame\n    // continually check to see if the document is ready\n    var toplevel;\n    try {\n      toplevel = window.frameElement == null;\n    } catch (err) {}\n    if (document.documentElement.doScroll && toplevel) {\n      doScrollCheck();\n    }\n  }\n};\n\nApp.prototype._getScript = function() {\n  return document.querySelector('script[src^=\"/derby/' + this.name + '\"]');\n};\n\nApp.prototype.use = util.use;\nApp.prototype.serverUse = util.serverUse;\n\nApp.prototype.loadViews = function() {};\n\nApp.prototype.loadStyles = function() {};\n\nApp.prototype.createPage = function() {\n  if (this.page) {\n    this.emit('destroyPage', this.page);\n    this.page.destroy();\n  }\n  var page = new this.Page(this, this.model);\n  this.page = page;\n  return page;\n};\n\nApp.prototype.onRoute = function(callback, page, next, done) {\n  if (this._waitForAttach) {\n    // Cancel any routing before the initial page attachment. Instead, do a\n    // render once derby is ready\n    this._cancelAttach = true;\n    return;\n  }\n  this.emit('route', page);\n  // HACK: To update render in transitional routes\n  page.model.set('$render.params', page.params);\n  page.model.set('$render.url', page.params.url);\n  page.model.set('$render.query', page.params.query);\n  // If transitional\n  if (done) {\n    var app = this;\n    var _done = function() {\n      app.emit('routeDone', page, 'transition');\n      done();\n    };\n    callback.call(page, page, page.model, page.params, next, _done);\n    return;\n  }\n  callback.call(page, page, page.model, page.params, next);\n};\n\nApp.prototype._autoRefresh = function() {\n  var app = this;\n  this.model.on('change', '$connection.state', function(state) {\n    if (state === 'connected') registerClient();\n  });\n  this.model.channel.on('derby:refreshViews', function(serializedViews) {\n    var fn = new Function('return ' + serializedViews)(); // jshint ignore:line\n    fn(derbyTemplates, app.views);\n    var ns = app.model.get('$render.ns');\n    app.page.render(ns);\n  });\n  this.model.channel.on('derby:refreshStyles', function(data) {\n    var styleElement = document.querySelector('style[data-filename=\"' +\n      data.filename + '\"]');\n    if (styleElement) styleElement.innerHTML = data.css;\n  });\n  function registerClient() {\n    var data = {name: app.name, hash: app.scriptHash};\n    app.model.channel.send('derby:app', data, function(err) {\n      if (!err) return;\n      // Reload in a timeout so that returning fetches have time to complete\n      // in case an onbeforeunload handler is being used\n      setTimeout(function() {\n        window.location = window.location;\n      }, 100);\n    });\n  }\n  registerClient();\n};\n\nutil.serverRequire(module, './App.server');\n","var EventEmitter = require('events').EventEmitter;\nvar util = require('racer/lib/util');\nvar Dom = require('./Dom');\n\nmodule.exports = Controller;\n\nfunction Controller(app, page, model) {\n  EventEmitter.call(this);\n  this.dom = new Dom(this);\n  this.app = app;\n  this.page = page;\n  this.model = model;\n  model.data.$controller = this;\n}\n\nutil.mergeInto(Controller.prototype, EventEmitter.prototype);\n\nController.prototype.emitCancellable = function() {\n  var cancelled = false;\n  function cancel() {\n    cancelled = true;\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  args.push(cancel);\n  this.emit.apply(this, args);\n\n  return cancelled;\n};\n\nController.prototype.emitDelayable = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop();\n\n  var delayed = false;\n  function delay() {\n    delayed = true;\n    return callback;\n  }\n\n  args.push(delay);\n  this.emit.apply(this, args);\n  if (!delayed) callback();\n\n  return delayed;\n};\n","/*\n * Derby.js\n * Meant to be the entry point for the framework.\n *\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar racer = require('racer');\nvar App = require('./App');\nvar Page = require('./Page');\nvar components = require('./components');\n\nmodule.exports = Derby;\n\nfunction Derby() {}\nDerby.prototype = racer;\n\nDerby.prototype.App = App;\nDerby.prototype.Page = Page;\nDerby.prototype.Component = components.Component;\n\nDerby.prototype.createApp = function(name, filename) {\n  return new App(this, name, filename);\n};\n\nif (!racer.util.isServer) {\n  require('./documentListeners').add(document);\n}\n\nracer.util.serverRequire(module, './Derby.server');\n","module.exports = Dom;\n\nfunction Dom(controller) {\n  this.controller = controller;\n  this._listeners = null;\n}\n\nDom.prototype._initListeners = function() {\n  var dom = this;\n  this.controller.on('destroy', function domOnDestroy() {\n    var listeners = dom._listeners;\n    if (!listeners) return;\n    for (var i = listeners.length; i--;) {\n      listeners[i].remove();\n    }\n    dom._listeners = null;\n  });\n  return this._listeners = [];\n};\n\nDom.prototype._listenerIndex = function(domListener) {\n  var listeners = this._listeners;\n  if (!listeners) return -1;\n  for (var i = listeners.length; i--;) {\n    if (listeners[i].equals(domListener)) return i;\n  }\n  return -1;\n};\n\nDom.prototype.addListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener =\n    (type === 'destroy') ? new DestroyListener(target, listener) :\n    new DomListener(type, target, listener, useCapture);\n  if (-1 === this._listenerIndex(domListener)) {\n    var listeners = this._listeners || this._initListeners();\n    listeners.push(domListener);\n  }\n  domListener.add();\n};\nDom.prototype.on = Dom.prototype.addListener;\n\nDom.prototype.once = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  this.addListener(type, target, wrappedListener, useCapture);\n  var dom = this;\n  function wrappedListener() {\n    dom.removeListener(type, target, wrappedListener, useCapture);\n    return listener.apply(this, arguments);\n  }\n};\n\nDom.prototype.removeListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener = new DomListener(type, target, listener, useCapture);\n  domListener.remove();\n  var i = this._listenerIndex(domListener);\n  if (i > -1) this._listeners.splice(i, 1);\n};\n\nfunction DomListener(type, target, listener, useCapture) {\n  this.type = type;\n  this.target = target;\n  this.listener = listener;\n  this.useCapture = !!useCapture;\n}\nDomListener.prototype.equals = function(domListener) {\n  return this.listener === domListener.listener &&\n    this.target === domListener.target &&\n    this.type === domListener.type &&\n    this.useCapture === domListener.useCapture;\n};\nDomListener.prototype.add = function() {\n  this.target.addEventListener(this.type, this.listener, this.useCapture);\n};\nDomListener.prototype.remove = function() {\n  this.target.removeEventListener(this.type, this.listener, this.useCapture);\n};\n\nfunction DestroyListener(target, listener) {\n  DomListener.call(this, 'destroy', target, listener);\n}\nDestroyListener.prototype = new DomListener();\nDestroyListener.prototype.add = function() {\n  var listeners = this.target.$destroyListeners || (this.target.$destroyListeners = []);\n  if (listeners.indexOf(this.listener) === -1) {\n    listeners.push(this.listener);\n  }\n};\nDestroyListener.prototype.remove = function() {\n  var listeners = this.target.$destroyListeners;\n  if (!listeners) return;\n  var index = listeners.indexOf(this.listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n};\n","var derbyTemplates = require('derby-templates');\nvar contexts = derbyTemplates.contexts;\nvar expressions = derbyTemplates.expressions;\nvar templates = derbyTemplates.templates;\nvar util = require('racer/lib/util');\nvar EventModel = require('./eventmodel');\nvar textDiff = require('./textDiff');\nvar Controller = require('./Controller');\nvar documentListeners = require('./documentListeners');\n\nmodule.exports = Page;\n\nfunction Page(app, model, req, res) {\n  Controller.call(this, app, this, model);\n  this.req = req;\n  this.res = res;\n  this.params = null;\n  if (this.init) this.init(model);\n  this.context = this._createContext();\n  this._eventModel = null;\n  this._removeModelListeners = null;\n  this._components = {};\n  this._addListeners();\n}\n\nutil.mergeInto(Page.prototype, Controller.prototype);\n\nPage.prototype.$bodyClass = function(ns) {\n  if (!ns) return;\n  var classNames = [];\n  var segments = ns.split(':');\n  for (var i = 0, len = segments.length; i < len; i++) {\n    var className = segments.slice(0, i + 1).join('-');\n    classNames.push(className);\n  }\n  return classNames.join(' ');\n};\n\nPage.prototype.$preventDefault = function(e) {\n  e.preventDefault();\n};\n\nPage.prototype.$stopPropagation = function(e) {\n  e.stopPropagation();\n};\n\nPage.prototype._setRenderParams = function(ns) {\n  this.model.set('$render.ns', ns);\n  this.model.set('$render.params', this.params);\n  this.model.set('$render.url', this.params && this.params.url);\n  this.model.set('$render.query', this.params && this.params.query);\n};\n\nPage.prototype._setRenderPrefix = function(ns) {\n  var prefix = (ns) ? ns + ':' : '';\n  this.model.set('$render.prefix', prefix);\n};\n\nPage.prototype.get = function(viewName, ns, unescaped) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.get(this.context, unescaped);\n};\n\nPage.prototype.getFragment = function(viewName, ns) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.getFragment(this.context);\n};\n\nPage.prototype.getView = function(viewName, ns) {\n  return this.app.views.find(viewName, ns);\n};\n\nPage.prototype.render = function(ns) {\n  this.app.emit('render', this);\n  this.context.pause();\n  this._setRenderParams(ns);\n  var titleFragment = this.getFragment('TitleElement', ns);\n  var bodyFragment = this.getFragment('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleElement.parentNode.replaceChild(titleFragment, titleElement);\n  document.body.parentNode.replaceChild(bodyFragment, document.body);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n  this.app.emit('routeDone', this, 'render');\n};\n\nPage.prototype.attach = function() {\n  this.context.pause();\n  var ns = this.model.get('$render.ns');\n  var titleView = this.getView('TitleElement', ns);\n  var bodyView = this.getView('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleView.attachTo(titleElement.parentNode, titleElement, this.context);\n  bodyView.attachTo(document.body.parentNode, document.body, this.context);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n};\n\nPage.prototype._createContext = function() {\n  var contextMeta = new contexts.ContextMeta();\n  contextMeta.views = this.app && this.app.views;\n  var context = new contexts.Context(contextMeta, this);\n  context.expression = new expressions.PathExpression([]);\n  context.alias = '#root';\n  return context;\n};\n\nPage.prototype._addListeners = function() {\n  var eventModel = this._eventModel = new EventModel();\n  this._addModelListeners(eventModel);\n  this._addContextListeners(eventModel);\n};\n\nPage.prototype.destroy = function() {\n  this.emit('destroy');\n  this._removeModelListeners();\n  for (var id in this._components) {\n    var component = this._components[id];\n    component.destroy();\n  }\n  // Remove all data, refs, listeners, and reactive functions\n  // for the previous page\n  var silentModel = this.model.silent();\n  silentModel.destroy('_page');\n  silentModel.destroy('$components');\n  // Unfetch and unsubscribe from all queries and documents\n  silentModel.unloadAll && silentModel.unloadAll();\n};\n\nPage.prototype._addModelListeners = function(eventModel) {\n  var model = this.model;\n  if (!model) return;\n\n  var context = this.context;\n  var changeListener = model.on('change', '**', function onChange(path, value, previous, pass) {\n    var segments = util.castSegments(path.split('.'));\n    // The pass parameter is passed in for special handling of updates\n    // resulting from stringInsert or stringRemove\n    pass.$previous = previous;\n    eventModel.set(segments, pass);\n  });\n  var loadListener = model.on('load', '**', function onLoad(path) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.set(segments);\n  });\n  var unloadListener = model.on('unload', '**', function onUnload(path) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.set(segments);\n  });\n  var insertListener = model.on('insert', '**', function onInsert(path, index, values) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.insert(segments, index, values.length);\n  });\n  var removeListener = model.on('remove', '**', function onRemove(path, index, values) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.remove(segments, index, values.length);\n  });\n  var moveListener = model.on('move', '**', function onMove(path, from, to, howMany) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.move(segments, from, to, howMany);\n  });\n\n  this._removeModelListeners = function() {\n    model.removeListener('change', changeListener);\n    model.removeListener('load', loadListener);\n    model.removeListener('unload', unloadListener);\n    model.removeListener('insert', insertListener);\n    model.removeListener('remove', removeListener);\n    model.removeListener('move', moveListener);\n  };\n};\n\nPage.prototype._addContextListeners = function(eventModel) {\n  this.context.meta.addBinding = addBinding;\n  this.context.meta.removeBinding = removeBinding;\n  this.context.meta.removeNode = removeNode;\n  this.context.meta.addItemContext = addItemContext;\n  this.context.meta.removeItemContext = removeItemContext;\n\n  function addItemContext(context) {\n    var segments = context.expression.resolve(context);\n    eventModel.addItemContext(segments, context);\n  }\n  function removeItemContext(context) {\n    // TODO\n  }\n  function addBinding(binding) {\n    patchTextBinding(binding);\n    var expressions = binding.template.expressions;\n    if (expressions) {\n      for (var i = 0, len = expressions.length; i < len; i++) {\n        addDependencies(eventModel, expressions[i], binding);\n      }\n    } else {\n      var expression = binding.template.expression;\n      addDependencies(eventModel, expression, binding);\n    }\n  }\n  function removeBinding(binding) {\n    var bindingWrappers = binding.meta;\n    if (!bindingWrappers) return;\n    for (var i = bindingWrappers.length; i--;) {\n      eventModel.removeBinding(bindingWrappers[i]);\n    }\n  }\n  function removeNode(node) {\n    var component = node.$component;\n    if (component && !component.singleton) {\n      component.destroy();\n    }\n    var destroyListeners = node.$destroyListeners;\n    if (destroyListeners) {\n      for (var i = 0; i < destroyListeners.length; i++) {\n        destroyListeners[i]();\n      }\n    }\n  }\n};\n\nfunction addDependencies(eventModel, expression, binding) {\n  var bindingWrapper = new BindingWrapper(eventModel, expression, binding);\n  bindingWrapper.updateDependencies();\n}\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\nfunction BindingWrapper(eventModel, expression, binding) {\n  this.eventModel = eventModel;\n  this.expression = expression;\n  this.binding = binding;\n  this.id = nextId++;\n  this.eventModels = null;\n  this.dependencies = null;\n  if (binding.meta) {\n    binding.meta.push(this);\n  } else {\n    binding.meta = [this];\n  }\n}\nBindingWrapper.prototype.updateDependencies = function() {\n  var dependencies = this.expression.dependencies(this.binding.context);\n  if (this.dependencies) {\n    // Do nothing if dependencies haven't changed\n    if (equalDependencies(this.dependencies, dependencies)) return;\n    // Otherwise, remove current dependencies\n    this.eventModel.removeBinding(this);\n  }\n  // Add new dependencies\n  if (!dependencies) return;\n  this.dependencies = dependencies;\n  for (var i = 0, len = dependencies.length; i < len; i++) {\n    var dependency = dependencies[i];\n    if (dependency) this.eventModel.addBinding(dependency, this);\n  }\n};\nBindingWrapper.prototype.update = function(pass) {\n  this.binding.update(pass);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.insert = function(index, howMany) {\n  this.binding.insert(index, howMany);\n};\nBindingWrapper.prototype.remove = function(index, howMany) {\n  this.binding.remove(index, howMany);\n};\nBindingWrapper.prototype.move = function(from, to, howMany) {\n  this.binding.move(from, to, howMany);\n};\n\nfunction equalDependencies(a, b) {\n  var lenA = a ? a.length : -1;\n  var lenB = b ? b.length : -1;\n  if (lenA !== lenB) return false;\n  for (var i = 0; i < lenA; i++) {\n    var itemA = a[i];\n    var itemB = b[i];\n    var lenItemA = itemA ? itemA.length : -1;\n    var lenItemB = itemB ? itemB.length : -1;\n    if (lenItemA !== lenItemB) return false;\n    for (var j = 0; j < lenItemB; j++) {\n      if (itemA[j] !== itemB[j]) return false;\n    }\n  }\n  return true;\n}\n\nfunction patchTextBinding(binding) {\n  if (\n    binding instanceof templates.AttributeBinding &&\n    binding.name === 'value' &&\n    binding.element.tagName === 'INPUT' &&\n    documentListeners.inputSupportsSelection(binding.element) &&\n    binding.template.expression.resolve(binding.context)\n  ) {\n    binding.update = textInputUpdate;\n\n  } else if (\n    binding instanceof templates.NodeBinding &&\n    binding.node.parentNode.tagName === 'TEXTAREA' &&\n    binding.template.expression.resolve(binding.context)\n  ) {\n    binding.update = textAreaUpdate;\n  }\n}\n\nfunction textInputUpdate(pass) {\n  textUpdate(this, this.element, pass);\n}\nfunction textAreaUpdate(pass) {\n  var element = this.node.parentNode;\n  if (element) textUpdate(this, element, pass);\n}\nfunction textUpdate(binding, element, pass) {\n  if (pass) {\n    if (pass.$event && pass.$event.target === element) {\n      return;\n    } else if (pass.$stringInsert) {\n      return textDiff.onStringInsert(\n        element,\n        pass.$previous,\n        pass.$stringInsert.index,\n        pass.$stringInsert.text\n      );\n    } else if (pass.$stringRemove) {\n      return textDiff.onStringRemove(\n        element,\n        pass.$previous,\n        pass.$stringRemove.index,\n        pass.$stringRemove.howMany\n      );\n    }\n  }\n\n  if (element.tagName === 'TEXTAREA') {\n    var template = binding.template;\n    var value = template.expression.get(binding.context);\n    return element.value = template.stringify(value);\n  }\n\n  binding.template.update(binding.context, binding);\n}\n\nutil.serverRequire(module, './Page.server');\n","/*DERBY_SERIALIZED_VIEWS*/module.exports = function(derbyTemplates, views) {var expressions = derbyTemplates.expressions;var templates = derbyTemplates.templates;views.register('TitleElement', '<title><view name=\"{{$render.prefix}}Title\"></view></title>').template = new templates.Template([new templates.Element('title', void 0, [new templates.Block(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Title')], '{{$render.prefix}}Title'), [new templates.DynamicViewInstance(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Title')], '{{$render.prefix}}Title'), {})])], void 0, false)]);views.register('BodyElement', '<body class=\"{{$bodyClass($render.ns)}}\"><view name=\"{{$render.prefix}}Body\"></view>').template = new templates.Template([new templates.Element('body', {'class': new templates.DynamicAttribute(new expressions.FnExpression(['$bodyClass'], [new expressions.PathExpression(['$render', 'ns'])], void 0, new expressions.ExpressionMeta('$bodyClass($render.ns)')))}, [new templates.Block(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Body')], '{{$render.prefix}}Body'), [new templates.DynamicViewInstance(new templates.Template([new templates.DynamicText(new expressions.PathExpression(['$render', 'prefix'], new expressions.ExpressionMeta('$render.prefix'))), new templates.Text('Body')], '{{$render.prefix}}Body'), {})])], void 0, false, true)]);views.register('Title', '\\n\\n    CausalPath\\n\\n\\n').template = new templates.Template([new templates.Text('CausalPath')]);views.register('Head', '\\n\\n    <meta name=\"viewport\" content=\"width=device-width\">\\n    <!--External style files-->\\n        <link href=\"lib/css/font-awesome-4.0.3/css/font-awesome.css\" rel=\"stylesheet\">\\n        <link href=\"./lib/css/bootstrap.css\" rel=\"stylesheet\">\\n        <link href=\"lib/css/jquery.qtip.min.css\" rel=\"stylesheet\">\\n        <link href=\"./lib/css/w3.css\" rel=\"stylesheet\">\\n\\n    <!--Style files-->\\n        <link href=\"./css/main.css\" rel=\"stylesheet\">\\n\\n\\n\\n').template = new templates.Template([new templates.Element('meta', {'name': new templates.Attribute('viewport'), 'content': new templates.Attribute('width=device-width')}, null, void 0, false), new templates.Element('link', {'href': new templates.Attribute('lib/css/font-awesome-4.0.3/css/font-awesome.css'), 'rel': new templates.Attribute('stylesheet')}, null, void 0, false), new templates.Element('link', {'href': new templates.Attribute('./lib/css/bootstrap.css'), 'rel': new templates.Attribute('stylesheet')}, null, void 0, false), new templates.Element('link', {'href': new templates.Attribute('lib/css/jquery.qtip.min.css'), 'rel': new templates.Attribute('stylesheet')}, null, void 0, false), new templates.Element('link', {'href': new templates.Attribute('./lib/css/w3.css'), 'rel': new templates.Attribute('stylesheet')}, null, void 0, false), new templates.Element('link', {'href': new templates.Attribute('./css/main.css'), 'rel': new templates.Attribute('stylesheet')}, null, void 0, false)]);views.register('Body', '\\n\\n    <!--Cytoscape-related global variables-->\\n    <script src=\"./src/utilities/global-variables-functions.js\"></script>\\n\\n    <!--External libraries-->\\n    <script src=\"lib/js/jquery-1.8.2.js\"></script>\\n    <script src=\"lib/js/jquery.fancybox-1.3.4.pack.js\"></script>\\n    <script src=\"lib/js/jquery.expander-min.js\"></script>\\n    <script src=\"lib/js/jquery.qtip.js\"></script>\\n    <script src=\"lib/js/jquery-ui-1.10.3.custom.min.js\"></script>\\n    <script src=\"lib/js/bootstrap.min.js\"></script>\\n    <script src=\"lib/js/underscore.js\"></script>\\n    <script src=\"lib/js/cytoscape.js\"></script>\\n    <script src=\"lib/js/cytoscape.js-qtip.js\"></script>\\n    <script src=\"lib/js/backbone-min.js\"></script>\\n    <script src=\"lib/js/jquery.highlighttextarea.js\"></script>\\n    <script src=\"lib/js/FileSaver.js\"></script>\\n    <script src=\"lib/js/jquery.noty.packaged.js\"></script>\\n    <script src=\"lib/js/socket.io.js\"></script>\\n    <script src=\"lib/js/cytoscape-cose-bilkent.js\"></script>\\n\\n    <!--Source code-->\\n    <script src=\"./src/utilities/topology-grouping.js\"></script>\\n    <script src=\"./src/utilities/causality-cy-renderer.js\"></script>\\n\\n    <!--Demo json object-->\\n    <script src=\"./demo/demoJson.js\"></script>\\n\\n\\n\\n\\n    <!--Causality-related-->\\n\\n    <div id = \"banner\">\\n        CausalPath: Causality Analysis of Proteomic Profiles\\n    </div>\\n\\n    <div id = \"info-div\">\\n\\n        This web service runs <a href=\"https://github.com/PathwayAndDataAnalysis/causalpath\" >CausalPath</a> analysis on proteomics and phosphoproteomics datasets and/or renders analysis results. For a new analysis, please prepare your input files according to the <a href=\"https://github.com/PathwayAndDataAnalysis/causalpath/blob/master/wiki/InputFormat.md\">guidelines</a>. If you already have results, please visualize the result network by uploading the related .json file. Source code of this web server resides at <a href=\"https://github.com/PathwayAndDataAnalysis/causalpath-webserver\">its own project</a>.\\n    </div>\\n    <div id  = \"graph-options-container\">\\n        <table align= \"top\" cellpadding=\"10px\" >\\n            <tbody>\\n            <tr align = \"center\">\\n                <td>\\n\\n                    <label for=\"back-button\">\\n                    <i class=\"fa fa-arrow-circle-left\"></i> Back\\n                    </label>\\n\\n\\n\\n                    <div> <input type=\"button\" id = \"back-button\" display = \"none\" value = \"Back\" on-click = \"showInputContainer()\"> </div>\\n\\n                </td>\\n            <td></td><td></td>\\n                <td class = \"graph-options-td\"><input type=\"checkbox\" id = \"sif-topology-grouping\" checked = \"{{!_page.doc.noTopologyGrouping}}\" on-change = \"reloadGraph()\" > Topology grouping</td>\\n                <td></td><td></td>\\n                <td class = \"graph-options-td\"><input type=\"button\" id = \"run-layout\" value = \"Run Layout\" on-click = \"runLayout()\"> </td>\\n                <td></td><td></td>\\n\\n\\n                <td>\\n                    <div id = \"download-div\">\\n                        <label for=\"download-button\">\\n                            <i class=\"fa fa-download\"></i> Download Input & Analysis Results\\n                        </label>\\n                        <div> <input type=\"button\" id = \"download-button\"  value = \"Download\" on-click = \"downloadResults()\"> </div>\\n                    </div>\\n                </td>\\n\\n            </tr>\\n            </tbody>\\n        </table>\\n    </div>\\n\\n    <div id= \"input-container\">\\n\\n            <table  border=\"0\"  width=\"100%\" align=\"center\" >\\n                <tbody>\\n\\n                <tr align=\"center\">\\n\\n                    <td align=\"center\">\\n\\n                        <div  class=\"input-td\">\\n                            A. Upload json file for visualization\\n                            <label for=\"graph-file-input\">\\n                                <i class=\"fa fa-upload\"></i> Select\\n                            </label>\\n\\n                            <div><input type=\"file\" id=\"graph-file-input\" accept=\".txt, .json\" on-change = \"loadGraphFile($event)\" value ={_page.newFile} ></div>\\n                        </div>\\n                    </td>\\n                    <td align = \"center\">\\n                        OR\\n                    </td>\\n                    <td align = \"center\">\\n\\n                        <div  class=\"input-td\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Enter multiple input files or a zip file of input files\">\\n                            B. Upload input files for analysis\\n                            <label for=\"analysis-directory-input\">\\n                                <i class=\"fa fa-upload\"></i> Select\\n                            </label>\\n\\n                            <div><input type=\"file\"  id=\"analysis-directory-input\" accept=\".txt, .zip\"  on-change = \"loadAnalysisDir()\" value ={_page.analysisFiles} multiple ></div>\\n                        </div>\\n                    </td>\\n\\n                    <td align = \"center\">\\n                        OR\\n                    </td>\\n\\n                    <td align = \"center\">\\n\\n                        <div  class=\"input-td\">\\n                            C. Show demo graph\\n\\n                            <label for=\"demo-file-button\">\\n                                <i class=\"fa fa-play\"></i> Display\\n                            </label>\\n                            <div><input type=\"button\" id=\"demo-file-button\"  value = \"Display\" on-click = \"loadDemoGraph()\"  ></div>\\n                        </div>\\n                    </td>\\n\\n\\n                </tr>\\n\\n\\n\\n                </tbody>\\n\\n            </table>\\n        </div>\\n\\n\\n\\n\\n    <div id = \"graph-container\">\\n\\n\\n    </div>\\n\\n    <script>\\n\\n            $(document).ready(function(){\\n\\n                $(\\'[data-toggle=\"tooltip\"]\\').tooltip();\\n        });\\n    </script>\\n\\n\\n\\n').template = new templates.Template([new templates.Element('script', {'src': new templates.Attribute('./src/utilities/global-variables-functions.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery-1.8.2.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery.fancybox-1.3.4.pack.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery.expander-min.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery.qtip.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery-ui-1.10.3.custom.min.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/bootstrap.min.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/underscore.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/cytoscape.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/cytoscape.js-qtip.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/backbone-min.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery.highlighttextarea.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/FileSaver.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/jquery.noty.packaged.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/socket.io.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('lib/js/cytoscape-cose-bilkent.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('./src/utilities/topology-grouping.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('./src/utilities/causality-cy-renderer.js')}, [], void 0, false), new templates.Element('script', {'src': new templates.Attribute('./demo/demoJson.js')}, [], void 0, false), new templates.Element('div', {'id': new templates.Attribute('banner')}, [new templates.Text('CausalPath: Causality Analysis of Proteomic Profiles')], void 0, false), new templates.Element('div', {'id': new templates.Attribute('info-div')}, [new templates.Text('This web service runs '), new templates.Element('a', {'href': new templates.Attribute('https://github.com/PathwayAndDataAnalysis/causalpath')}, [new templates.Text('CausalPath')], void 0, false), new templates.Text(' analysis on proteomics and phosphoproteomics datasets and/or renders analysis results. For a new analysis, please prepare your input files according to the '), new templates.Element('a', {'href': new templates.Attribute('https://github.com/PathwayAndDataAnalysis/causalpath/blob/master/wiki/InputFormat.md')}, [new templates.Text('guidelines')], void 0, false), new templates.Text('. If you already have results, please visualize the result network by uploading the related .json file. Source code of this web server resides at '), new templates.Element('a', {'href': new templates.Attribute('https://github.com/PathwayAndDataAnalysis/causalpath-webserver')}, [new templates.Text('its own project')], void 0, false), new templates.Text('.')], void 0, false), new templates.Element('div', {'id': new templates.Attribute('graph-options-container')}, [new templates.Element('table', {'align': new templates.Attribute('top'), 'cellpadding': new templates.Attribute('10px')}, [new templates.Element('tbody', void 0, [new templates.Element('tr', {'align': new templates.Attribute('center')}, [new templates.Element('td', void 0, [new templates.Element('label', {'for': new templates.Attribute('back-button')}, [new templates.Element('i', {'class': new templates.Attribute('fa fa-arrow-circle-left')}, [], void 0, false), new templates.Text(' Back')], void 0, false), new templates.Element('div', void 0, [new templates.Text(' '), new templates.Element('input', {'type': new templates.Attribute('button'), 'id': new templates.Attribute('back-button'), 'display': new templates.Attribute('none'), 'value': new templates.Attribute('Back')}, null, [new templates.ElementOn('click', new expressions.FnExpression(['showInputContainer'], []))], false), new templates.Text(' ')], void 0, false)], void 0, false), new templates.Element('td', void 0, [], void 0, false), new templates.Element('td', void 0, [], void 0, false), new templates.Element('td', {'class': new templates.Attribute('graph-options-td')}, [new templates.Element('input', {'type': new templates.Attribute('checkbox'), 'id': new templates.Attribute('sif-topology-grouping'), 'checked': new templates.DynamicAttribute(new expressions.OperatorExpression('!U', [new expressions.PathExpression(['_page', 'doc', 'noTopologyGrouping'])], void 0, new expressions.ExpressionMeta('!_page.doc.noTopologyGrouping')))}, null, [new templates.ElementOn('change', new expressions.FnExpression(['reloadGraph'], []))], false), new templates.Text(' Topology grouping')], void 0, false), new templates.Element('td', void 0, [], void 0, false), new templates.Element('td', void 0, [], void 0, false), new templates.Element('td', {'class': new templates.Attribute('graph-options-td')}, [new templates.Element('input', {'type': new templates.Attribute('button'), 'id': new templates.Attribute('run-layout'), 'value': new templates.Attribute('Run Layout')}, null, [new templates.ElementOn('click', new expressions.FnExpression(['runLayout'], []))], false), new templates.Text(' ')], void 0, false), new templates.Element('td', void 0, [], void 0, false), new templates.Element('td', void 0, [], void 0, false), new templates.Element('td', void 0, [new templates.Element('div', {'id': new templates.Attribute('download-div')}, [new templates.Element('label', {'for': new templates.Attribute('download-button')}, [new templates.Element('i', {'class': new templates.Attribute('fa fa-download')}, [], void 0, false), new templates.Text(' Download Input & Analysis Results')], void 0, false), new templates.Element('div', void 0, [new templates.Text(' '), new templates.Element('input', {'type': new templates.Attribute('button'), 'id': new templates.Attribute('download-button'), 'value': new templates.Attribute('Download')}, null, [new templates.ElementOn('click', new expressions.FnExpression(['downloadResults'], []))], false), new templates.Text(' ')], void 0, false)], void 0, false)], void 0, false)], void 0, false)], void 0, false)], void 0, false)], void 0, false), new templates.Element('div', {'id': new templates.Attribute('input-container')}, [new templates.Element('table', {'border': new templates.Attribute('0'), 'width': new templates.Attribute('100%'), 'align': new templates.Attribute('center')}, [new templates.Element('tbody', void 0, [new templates.Element('tr', {'align': new templates.Attribute('center')}, [new templates.Element('td', {'align': new templates.Attribute('center')}, [new templates.Element('div', {'class': new templates.Attribute('input-td')}, [new templates.Text('A. Upload json file for visualization'), new templates.Element('label', {'for': new templates.Attribute('graph-file-input')}, [new templates.Element('i', {'class': new templates.Attribute('fa fa-upload')}, [], void 0, false), new templates.Text(' Select')], void 0, false), new templates.Element('div', void 0, [new templates.Element('input', {'type': new templates.Attribute('file'), 'id': new templates.Attribute('graph-file-input'), 'accept': new templates.Attribute('.txt, .json'), 'value': new templates.Attribute('{_page.newFile}')}, null, [new templates.ElementOn('change', new expressions.FnExpression(['loadGraphFile'], [new expressions.PathExpression(['$event'])]))], false)], void 0, false)], void 0, false)], void 0, false), new templates.Element('td', {'align': new templates.Attribute('center')}, [new templates.Text('OR')], void 0, false), new templates.Element('td', {'align': new templates.Attribute('center')}, [new templates.Element('div', {'class': new templates.Attribute('input-td'), 'data-toggle': new templates.Attribute('tooltip'), 'data-placement': new templates.Attribute('bottom'), 'title': new templates.Attribute('Enter multiple input files or a zip file of input files')}, [new templates.Text('B. Upload input files for analysis'), new templates.Element('label', {'for': new templates.Attribute('analysis-directory-input')}, [new templates.Element('i', {'class': new templates.Attribute('fa fa-upload')}, [], void 0, false), new templates.Text(' Select')], void 0, false), new templates.Element('div', void 0, [new templates.Element('input', {'type': new templates.Attribute('file'), 'id': new templates.Attribute('analysis-directory-input'), 'accept': new templates.Attribute('.txt, .zip'), 'value': new templates.Attribute('{_page.analysisFiles}'), 'multiple': new templates.Attribute(true)}, null, [new templates.ElementOn('change', new expressions.FnExpression(['loadAnalysisDir'], []))], false)], void 0, false)], void 0, false)], void 0, false), new templates.Element('td', {'align': new templates.Attribute('center')}, [new templates.Text('OR')], void 0, false), new templates.Element('td', {'align': new templates.Attribute('center')}, [new templates.Element('div', {'class': new templates.Attribute('input-td')}, [new templates.Text('C. Show demo graph'), new templates.Element('label', {'for': new templates.Attribute('demo-file-button')}, [new templates.Element('i', {'class': new templates.Attribute('fa fa-play')}, [], void 0, false), new templates.Text(' Display')], void 0, false), new templates.Element('div', void 0, [new templates.Element('input', {'type': new templates.Attribute('button'), 'id': new templates.Attribute('demo-file-button'), 'value': new templates.Attribute('Display')}, null, [new templates.ElementOn('click', new expressions.FnExpression(['loadDemoGraph'], []))], false)], void 0, false)], void 0, false)], void 0, false)], void 0, false)], void 0, false)], void 0, false)], void 0, false), new templates.Element('div', {'id': new templates.Attribute('graph-container')}, [], void 0, false), new templates.Element('script', void 0, [new templates.Text('$(document).ready(function(){$(\\'[data-toggle=\"tooltip\"]\\').tooltip();});')], void 0, false)]);views.register('Tail', '').template = new templates.Template([]);};/*DERBY_SERIALIZED_VIEWS_END*/","/*\n * components.js\n *\n * Components associate custom script functionality with a view. They can be\n * distributed as standalone modules containing templates, scripts, and styles.\n * They can also be used to modularize application functionality.\n *\n */\n\nvar path = require('path');\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar expressions = derbyTemplates.expressions;\nvar App = require('./App');\nvar Controller = require('./Controller');\n\nexports.Component = Component;\nexports.ComponentFactory = ComponentFactory;\nexports.SingletonComponentFactory = SingletonComponentFactory;\nexports.createFactory = createFactory;\n\nfunction Component(parent, context, id, scope) {\n  this.parent = parent;\n  this.context = context;\n  this.id = id;\n  this._scope = scope;\n}\n\nutil.mergeInto(Component.prototype, Controller.prototype);\n\nComponent.prototype.destroy = function() {\n  this.emit('destroy');\n  this.model.removeContextListeners();\n  this.model.destroy();\n  delete this.page._components[this.id];\n  var components = this.page._eventModel.object.$components;\n  if (components) delete components.object[this.id];\n};\n\nComponent.prototype.get = function(viewName, unescaped) {\n  var view = this.getView(viewName);\n  return view.get(this.context, unescaped);\n};\n\nComponent.prototype.getFragment = function(viewName) {\n  var view = this.getView(viewName);\n  return view.getFragment(this.context);\n};\n\nComponent.prototype.getView = function(viewName) {\n  var contextView = this.context.getView();\n  return (viewName) ?\n    this.app.views.find(viewName, contextView.namespace) : contextView;\n};\n\nComponent.prototype.getAttribute = function(key) {\n  var attributeContext = this.context.forAttribute(key);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[key];\n  return value && expressions.renderValue(value, attributeContext);\n};\n\nComponent.prototype.setAttribute = function(key, value) {\n  this.context.parent.attributes[key] = value;\n};\n\nComponent.prototype.setNullAttribute = function(key, value) {\n  var attributes = this.context.parent.attributes;\n  if (attributes[key] == null) attributes[key] = value;\n};\n\nfunction initComponent(context, component, parent, model, id, scope) {\n  // Do generic controller initialization\n  var componentContext = context.componentChild(component);\n  Controller.call(component, parent.app, parent.page, model);\n  Component.call(component, parent, componentContext, id, scope);\n\n  // Do the user-specific initialization. The component constructor should be\n  // an empty function and the actual initialization code should be done in the\n  // component's init method. This means that we don't have to rely on users\n  // properly calling the Component constructor method and avoids having to\n  // play nice with how CoffeeScript extends class constructors\n  emitInitHooks(context, component);\n  component.emit('init', component);\n  if (component.init) component.init(model);\n\n  return componentContext;\n}\n\nfunction emitInitHooks(context, component) {\n  if (!context.initHooks) return;\n  // Run initHooks for `on` listeners immediately before init\n  for (var i = 0, len = context.initHooks.length; i < len; i++) {\n    context.initHooks[i].emit(context, component);\n  }\n}\n\nfunction setAttributes(context, model) {\n  if (!context.attributes) return;\n  // Set attribute values on component model\n  for (var key in context.attributes) {\n    var attribute = context.attributes[key];\n    var segments = (\n      attribute instanceof templates.ParentWrapper &&\n      attribute.expression &&\n      attribute.expression.pathSegments(context)\n    );\n    if (segments) {\n      model.root.ref(model._at + '.' + key, segments.join('.'), {updateIndices: true});\n    } else {\n      model.set(key, attribute);\n    }\n  }\n}\n\nfunction createFactory(constructor) {\n  return (constructor.prototype.singleton) ?\n    new SingletonComponentFactory(constructor) :\n    new ComponentFactory(constructor);\n}\n\nfunction ComponentFactory(constructor) {\n  this.constructor = constructor;\n}\nComponentFactory.prototype.init = function(context) {\n  var component = new this.constructor();\n\n  var parent = context.controller;\n  var id = context.id();\n  var scope = ['$components', id];\n  var model = parent.model.root.eventContext(component);\n  model._at = scope.join('.');\n  model.set('id', id);\n  setAttributes(context, model);\n  // Store a reference to the component's scope such that the expression\n  // getters are relative to the component\n  model.data = model.get();\n  parent.page._components[id] = component;\n\n  return initComponent(context, component, parent, model, id, scope);\n};\nComponentFactory.prototype.create = function(context) {\n  var component = context.controller;\n  component.emit('create', component);\n  // Call the component's create function after its view is rendered\n  if (component.create) {\n    component.create(component.model, component.dom);\n  }\n};\n\nfunction SingletonComponentFactory(constructor) {\n  this.constructor = constructor;\n  this.component = null;\n}\nSingletonComponentFactory.prototype.init = function(context) {\n  if (!this.component) this.component = new this.constructor();\n  return context.componentChild(this.component);\n};\n// Don't call the create method for singleton components\nSingletonComponentFactory.prototype.create = function() {};\n\nApp.prototype.component = function(viewName, constructor) {\n  if (typeof viewName === 'function') {\n    constructor = viewName;\n    viewName = null;\n  }\n\n  // Inherit from Component\n  extendComponent(constructor);\n\n  // Load template view from filename\n  if (constructor.prototype.view) {\n    var viewFilename = constructor.prototype.view;\n    viewName = constructor.prototype.name || path.basename(viewFilename, '.html');\n    this.loadViews(viewFilename, viewName);\n\n  } else if (!viewName) {\n    if (constructor.prototype.name) {\n      viewName = constructor.prototype.name;\n      var view = this.views.register(viewName);\n      view.template = templates.emptyTemplate;\n    } else {\n      throw new Error('No view name specified for component');\n    }\n  }\n\n  // Associate the appropriate view with the component type\n  var view = this.views.find(viewName);\n  if (!view) {\n    var message = this.views.findErrorMessage(viewName);\n    throw new Error(message);\n  }\n  view.componentFactory = createFactory(constructor);\n\n  // Make chainable\n  return this;\n};\n\nfunction extendComponent(constructor) {\n  // Don't do anything if the constructor already extends Component\n  if (constructor.prototype instanceof Component) return;\n  // Otherwise, replace its prototype with an instance of Component\n  var oldPrototype = constructor.prototype;\n  constructor.prototype = new Component();\n  util.mergeInto(constructor.prototype, oldPrototype);\n}\n","var textDiff = require('./textDiff');\n\nexports.add = addDocumentListeners;\nexports.inputSupportsSelection = inputSupportsSelection;\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#do-not-apply\n// TODO: Date types support\nfunction inputSupportsSelection(input) {\n  var type = input.type;\n  return (\n    type === 'text' ||\n    type === 'search' ||\n    type === 'url' ||\n    type === 'tel' ||\n    type === 'password'\n  );\n}\nfunction inputIsNumberValue(input) {\n  var type = input.type;\n  return (type === 'number' || (type === 'range' && !input.multiple));\n}\nfunction inputValue(input) {\n  return inputIsNumberValue(input) ? input.valueAsNumber : input.value;\n}\n\nfunction addDocumentListeners(doc) {\n  doc.addEventListener('input', documentInput, true);\n  doc.addEventListener('change', documentChange, true);\n\n  // Listen to more events for versions of IE with buggy input event implementations\n  if (parseFloat(window.navigator.appVersion.split('MSIE ')[1]) <= 9) {\n    // We're listening on selectionchange because there's no other event emitted when\n    // the user clicks 'delete' from a context menu when right clicking on selected text.\n    // So although this event fires overly aggressively, it's the only real way\n    // to ensure that we can detect all changes to the input value in IE <= 9\n    doc.addEventListener('selectionchange', function(e){\n      if (document.activeElement) {\n        documentInput({target: document.activeElement}); // selectionchange evts don't have the e.target we need\n      }\n    }, true);\n  }\n\n  // For some reason valueAsNumber returns NaN for number inputs in IE\n  // until a new IE version that handles this is released, parse input.value as a fallback\n  var input = document.createElement('input');\n  input.type = 'number';\n  input.value = '7';\n  if (input.valueAsNumber !== input.valueAsNumber) {\n    var oldInputValue = inputValue;\n    inputValue = function(input) {\n      if (input.type === 'number') {\n        return inputIsNumberValue(input) ? parseFloat(input.value) : input.value;\n      } else {\n        return oldInputValue.apply(this, arguments);\n      }\n    };\n  }\n}\n\nfunction documentInput(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT') {\n    setInputValue(e, target);\n\n  } else if (target.tagName === 'TEXTAREA' && target.childNodes.length === 1) {\n    var binding = target.firstChild && target.firstChild.$bindNode;\n    if (!binding || binding.isUnbound()) return;\n\n    var pass = {$event: e};\n    textDiffBinding(binding, target.value, pass);\n  }\n}\n\nfunction documentChange(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT') {\n    setBoundProperty(target, 'checked');\n    setInputValue(e, target);\n\n  } else if (target.tagName === 'SELECT') {\n    setOptionBindings(target);\n  }\n}\n\nfunction setBoundProperty(node, property) {\n  var binding = node.$bindAttributes && node.$bindAttributes[property];\n  if (!binding || binding.isUnbound()) return;\n\n  var value = node[property];\n  binding.template.expression.set(binding.context, value);\n}\n\nfunction setInputValue(e, target) {\n  var binding = target.$bindAttributes && target.$bindAttributes.value;\n  if (!binding || binding.isUnbound()) return;\n\n  if (inputSupportsSelection(target)) {\n    var pass = {$event: e};\n    textDiffBinding(binding, target.value, pass);\n  } else {\n    var value = inputValue(target);\n    binding.template.expression.set(binding.context, value);\n  }\n}\n\nfunction textDiffBinding(binding, value, pass) {\n  var expression = binding.template.expression;\n  var segments = expression.pathSegments(binding.context);\n  if (segments) {\n    var model = binding.context.controller.model.pass(pass);\n    textDiff.onTextInput(model, segments, value);\n  } else if (expression.set) {\n    expression.set(binding.context, value);\n  }\n}\n\nfunction setOptionBindings(parent) {\n  for (var node = parent.firstChild; node; node = node.nextSibling) {\n    if (node.tagName === 'OPTION') {\n      setBoundProperty(node, 'selected');\n    } else if (node.hasChildNodes()) {\n      setOptionBindings(node);\n    }\n  }\n}\n","var expressions = require('derby-templates').expressions;\n\n// The many trees of bindings:\n//\n// - Model tree, containing your actual data. Eg:\n//    {users:{fred:{age:40}, wilma:{age:37}}}\n//\n// - Event model tree, whose structure mirrors the model tree. The event model\n//   tree lets us annotate the model tree with listeners which fire when events\n//   change. I think there are three types of listeners:\n//\n//   1. Reference binding binds to whatever is referred to by the path. Eg,\n//   {{each items as item}} binds item by reference as it goes through the\n//   list.\n//   2. Fixed path bindings explicitly bind to whatever is at that path\n//   regardless of how the model changes underneath the event model\n//   3. Listen on a subtree and fire when anything in the subtree changes. This\n//   is used for custom functions.\n//\n// {{foo.id}} would listen on the fixed path ['foo', 'id'].\n//\n//\n// - Context tree represents the changing (embedded) contexts of the templating\n//   engine. This maps to the tree of templates and allows templates to reference\n//   anything in any of their enclosing template scopes.\n//\n\nmodule.exports = EventModel;\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\n\n// A binding object is something with update(), insert()/move()/remove() defined.\n\n\n// Given x[y] with model.get(y) == 5:\n//  item = 5\n//  segments = ['y']\n//  outside = the EventModel for x.\n//\n// Note that item could be a Context or another ModelRef - eg:\n//\n// {{ each foo as bar }} ... {{ x[bar] }}  -or-  {{ x[y[z]] }}\nfunction ModelRef(model, item, segments, outside) {\n  this.id = nextId++;\n\n  // We need a reference to the model & our segment list so we can update our\n  // value.\n  this.model = model;\n  this.segments = segments;\n\n  // Our current value.\n  this.item = item;\n\n  // outside is a reference to the EventModel of the thing on the lhs of the\n  // brackets. For example, in x[y].z, outside is the EventModel of x.\n  this.outside = outside;\n\n  // result is the EventModel of the evaluated version of the brackets. In\n  // x[y].z, its the EventModel of x[y].\n  this.result = outside.child(item).refChild(this);\n}\n\nModelRef.prototype.update = function() {\n  var segments = expressions.pathSegments(this.segments);\n  var newItem = expressions.lookup(segments, this.model.data);\n  if (this.item === newItem) return;\n\n  // First remove myself.\n  delete this.outside.child(this.item).refChildren[this.id];\n\n  this.item = newItem;\n\n  var container = this.outside.child(this.item);\n  // I want to just call refChild but that would create a new EM. Instead I\n  // want to just implant my current EM there.\n  if (!container.refChildren) container.refChildren = new RefChildrenMap();\n  container.refChildren[this.id] = this.result;\n\n  // Finally, update all the bindings in the tree.\n  this.result.update();\n};\n\n\nfunction RefOutMap() {}\nfunction RefChildrenMap() {}\nfunction BindingsMap() {}\nfunction ItemContextsMap() {}\nfunction EventModelsMap() {}\n\nfunction EventModel() {\n  this.id = nextId++;\n\n  // Most of these won't ever be filled in, so I'm just leaving them null.\n  //\n  // These contain our EventModel children.\n  this.object = null;\n  this.array = null;\n\n  // This contains any EventModel children which have floating references.\n  this.arrayByReference = null;\n\n  // If the data stored here is ever used to lookup other values, this is an\n  // object mapping remote child ID -> ref.\n  //\n  // Eg given x[y], y.refOut[x.id] = <Binding>\n  this.refOut = null;\n\n  // This is a map from ref id -> event model for events bound to this\n  // EventModel but via a ref. We could just merge them into the main tree, but\n  // this way they're easy to move.\n  //\n  // Eg, given x[y] (y=1), x.1.refChildren[ref id] is an EventModel.\n  this.refChildren = null;\n\n  this.bindings = null;\n\n  // Item contexts are contexts which need their item number changed as this\n  // EventModel object moves around its surrounding list.\n  this.itemContexts = null;\n}\n\nEventModel.prototype.refChild = function(ref) {\n  if (!this.refChildren) this.refChildren = new RefChildrenMap();\n  var id = ref.id;\n\n  if (!this.refChildren[id]) {\n    this.refChildren[id] = new EventModel();\n  }\n  return this.refChildren[id];\n};\n\nEventModel.prototype.arrayLookup = function(model, segmentsBefore, segmentsInside) {\n  var segments = expressions.pathSegments(segmentsInside);\n  var item = expressions.lookup(segments, model.data);\n\n  var source = this.at(segmentsInside);\n\n  // What the array currently resolves to. Given x[y] with y=1, container is\n  // the EM for x\n  var container = this.at(segmentsBefore);\n\n  if (!source.refOut) source.refOut = new RefOutMap();\n\n  var ref = source.refOut[container.id];\n  if (ref == null) {\n    ref = new ModelRef(model, item, segmentsInside, container);\n    source.refOut[container.id] = ref;\n  }\n\n  return ref;\n};\n\n// Returns the EventModel node of the named child.\nEventModel.prototype.child = function(segment) {\n  var container;\n  if (typeof segment === 'string') {\n    // Object\n    if (!this.object) this.object = {};\n    container = this.object;\n\n  } else if (typeof segment === 'number') {\n    // Array by value\n    if (!this.array) this.array = [];\n    container = this.array;\n\n  } else if (segment instanceof ModelRef) {\n    // Array reference. We'll need to lookup the child with the right\n    // value, then look inside its ref children for the right EventModel\n    // (so we can update it later). This is pretty janky, but should be\n    // *correct* even in the face of recursive array accessors.\n    //\n    // This will calculate it based on the current segment values, but refs\n    // cache the EM anyway.\n    //return this.child(segment.item).refChild(segment);\n    return segment.result;\n\n  } else {\n    // Array by reference\n    if (!this.arrayByReference) this.arrayByReference = [];\n    container = this.arrayByReference;\n    segment = segment.item;\n  }\n\n  return container[segment] || (container[segment] = new EventModel());\n};\n\n// Returns the EventModel node at the given segments list. Note that although\n// EventModel nodes are unique, its possible for multiple EventModel nodes to\n// refer to the same section of the model because of references.\n//\n// If you want to update the bindings that refer to a specific path, use\n// each().\n//\n// EventModel objects are created as needed.\nEventModel.prototype.at = function(segments) {\n  // For unbound dependancies.\n  if (segments == null) return this;\n\n  var eventModel = this;\n\n  for (var i = 0; i < segments.length; i++) {\n    eventModel = eventModel.child(segments[i]);\n  }\n\n  return eventModel;\n};\n\nEventModel.prototype.isEmpty = function() {\n  if (hasKeys(this.dependancies)) return false;\n  if (hasKeys(this.itemContexts)) return false;\n\n  if (this.object) {\n    if (hasKeys(this.object)) return false;\n    this.object = null;\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      if (this.arrayByReference[i] != null) return false;\n    }\n    this.arrayByReference = null;\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      if (this.array[i] != null) return false;\n    }\n    this.array = null;\n  }\n\n  return true;\n};\n\nfunction hasKeys(object) {\n  for (var key in object) {\n    return true;\n  }\n  return false;\n}\n\n\n// **** Updating the EventModel\n\nEventModel.prototype._addItemContext = function(context) {\n  if (!context._id) context._id = nextId++;\n  if (!this.itemContexts) this.itemContexts = new ItemContextsMap();\n  this.itemContexts[context._id] = context;\n};\n\nEventModel.prototype._removeItemContext = function(context) {\n  if (this.itemContexts) {\n    delete this.itemContexts[context._id];\n  }\n};\n\nEventModel.prototype._addBinding = function(binding) {\n  var bindings = this.bindings || (this.bindings = new BindingsMap());\n  binding.eventModels || (binding.eventModels = new EventModelsMap());\n  bindings[binding.id] = binding;\n  binding.eventModels[this.id] = this;\n};\n\n// This is the main hook to add bindings to the event model tree. It should\n// only be called on the root EventModel object.\nEventModel.prototype.addBinding = function(segments, binding) {\n  this.at(segments)._addBinding(binding);\n};\n\n// This is used for objects (contexts in derby's case) that have a .item\n// property which refers to an array index.\nEventModel.prototype.addItemContext = function(segments, context) {\n  this.at(segments)._addItemContext(context);\n};\n\nEventModel.prototype.removeBinding = function(binding) {\n  for (var id in binding.eventModels) {\n    var eventModel = binding.eventModels[id];\n    if (eventModel.bindings) delete eventModel.bindings[binding.id];\n  }\n  binding.eventModels = null;\n};\n\nEventModel.prototype._each = function(segments, pos, fn) {\n  // Our refChildren are effectively merged into this object.\n  if (this.refChildren) {\n    for (var id in this.refChildren) {\n      this.refChildren[id]._each(segments, pos, fn);\n    }\n  }\n\n  if (segments.length === pos) {\n    fn(this);\n    return;\n  }\n\n  var segment = segments[pos];\n  var child;\n  if (typeof segment === 'string') {\n    // Object. Just recurse into our objects set. Its possible to rewrite this\n    // function to simply loop in the case of object lookups, but I don't think\n    // it'll buy us much.\n    child = this.object && this.object[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n  } else {\n    // Number. Recurse both into the fixed list and the reference list.\n    child = this.array && this.array[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n    child = this.arrayByReference && this.arrayByReference[segment];\n    if (child) child._each(segments, pos + 1, fn);\n  }\n};\n\n// Called when the scalar value at the path changes. This only calls update()\n// on this node. See update() below if you want to update entire\n// subtrees.\nEventModel.prototype.localUpdate = function(pass) {\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      binding.update(pass);\n    }\n  }\n\n  // If our value changed, we also need to update anything that depends on it\n  // via refOut.\n  if (this.refOut) {\n    for (var id in this.refOut) {\n      var ref = this.refOut[id];\n      ref.update();\n    }\n  }\n};\n\n// This is used when an object subtree is replaced / removed.\nEventModel.prototype.update = function(pass) {\n  this.localUpdate(pass);\n\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      var binding = this.array[i];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      var binding = this.arrayByReference[i];\n      if (binding) binding.update();\n    }\n  }\n};\n\n// Updates the indexes in itemContexts of our children in the range of\n// [from, to). from and to both optional.\nEventModel.prototype._updateChildItemContexts = function(from, to) {\n  if (!this.arrayByReference) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.arrayByReference.length;\n\n  for (var i = from; i < to; i++) {\n    var contexts = this.arrayByReference[i] &&\n      this.arrayByReference[i].itemContexts;\n    if (contexts) {\n      for (var key in contexts) {\n        contexts[key].item = i;\n      }\n    }\n  }\n};\n\n// Updates our array-by-value values. They have to recursively update every\n// binding in their children. Sad.\nEventModel.prototype._updateArray = function(from, to) {\n  if (!this.array) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.array.length;\n\n  for (var i = from; i < to; i++) {\n    var binding = this.array[i];\n    if (binding) binding.update();\n  }\n};\n\nEventModel.prototype._updateObject = function() {\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n};\n\nEventModel.prototype._set = function(pass) {\n  // This just updates anything thats bound to the whole subtree. An alternate\n  // implementation could be passed in the new value at this node (which we\n  // cache), then compare with the old version and only update parts of the\n  // subtree which are relevant. I don't know if thats an important\n  // optimization - it really depends on your use case.\n  this.update(pass);\n};\n\n// Insert into this EventModel node.\nEventModel.prototype._insert = function(index, howMany) {\n  // Update fixed paths\n  this._updateArray(index);\n\n  // Update relative paths\n  if (this.arrayByReference && this.arrayByReference.length > index) {\n    // Shift the actual items in the array references array.\n\n    // This probably isn't the best way to implement insert. Other options are\n    // using concat() on slices or though constructing a temporary array and\n    // using splice.call. Hopefully if this method is slow it'll come up during\n    // profiling.\n    for (var i = 0; i < howMany; i++) {\n      this.arrayByReference.splice(index, 0, null);\n    }\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(index + howMany);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.insert(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Remove howMany child elements from this EventModel at index.\nEventModel.prototype._remove = function(index, howMany) {\n  // Update fixed paths. Both the removed items and items after it may have changed.\n  this._updateArray(index);\n\n  if (this.arrayByReference) {\n    // Update relative paths. First throw away all the children which have been removed.\n    this.arrayByReference.splice(index, howMany);\n\n    this._updateChildItemContexts(index);\n  }\n\n  // Call bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.remove(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Move howMany items from `from` to `to`.\nEventModel.prototype._move = function(from, to, howMany) {\n  // first points to the first element that was moved. end points to the list\n  // element past the end of the changed region.\n  var first, end;\n  if (from < to) {\n    first = from;\n    end = to + howMany;\n  } else {\n    first = to;\n    end = from + howMany;\n  }\n\n  // Update fixed paths.\n  this._updateArray(first, end);\n\n  // Update relative paths\n  var arr = this.arrayByReference;\n  if (arr && arr.length > first) {\n    // Remove from the old location\n    var values = arr.splice(from, howMany);\n\n    // Insert at the new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(first, end);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      binding.move(from, to, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n\n// Helpers.\n\nEventModel.prototype.mutate = function(segments, fn) {\n  // This finds & returns a list of all event models which exist and could match\n  // the specified path. The path cannot contain contexts like derby expression\n  // segment lists (just because I don't think thats a useful feature and its not\n  // implemented)\n  this._each(segments, 0, fn);\n\n  // Also emit all mutations as sets on star paths, which are how dependencies\n  // for view helper functions are represented. They should react to a path\n  // or any child path being modified\n  for (var i = 0, len = segments.length; i++ < len;) {\n    var wildcardSegments = segments.slice(0, i);\n    wildcardSegments.push('*');\n    this._each(wildcardSegments, 0, childSetWildcard);\n  }\n};\n\nfunction childSetWildcard(child) {\n  child._set();\n}\n\nEventModel.prototype.set = function(segments, pass) {\n  this.mutate(segments, function childSet(child) {\n    child._set(pass);\n  });\n};\n\nEventModel.prototype.insert = function(segments, index, howMany) {\n  this.mutate(segments, function childInsert(child) {\n    child._insert(index, howMany);\n  });\n};\n\nEventModel.prototype.remove = function(segments, index, howMany) {\n  this.mutate(segments, function childRemove(child) {\n    child._remove(index, howMany);\n  });\n};\n\nEventModel.prototype.move = function(segments, from, to, howMany) {\n  this.mutate(segments, function childMove(child) {\n    child._move(from, to, howMany);\n  });\n};\n","exports.onStringInsert = onStringInsert;\nexports.onStringRemove = onStringRemove;\nexports.onTextInput = onTextInput;\n\nfunction onStringInsert(el, previous, index, text) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor + text.length : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + text + previous.slice(index);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction onStringRemove(el, previous, index, howMany) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + previous.slice(index + howMany);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction replaceText(el, newText, transformCursor) {\n  var selectionStart = transformCursor(el.selectionStart);\n  var selectionEnd = transformCursor(el.selectionEnd);\n\n  var scrollTop = el.scrollTop;\n  el.value = newText;\n  if (el.scrollTop !== scrollTop) {\n    el.scrollTop = scrollTop;\n  }\n  if (document.activeElement === el) {\n    el.selectionStart = selectionStart;\n    el.selectionEnd = selectionEnd;\n  }\n}\n\nfunction onTextInput(model, segments, value) {\n  var previous = model._get(segments) || '';\n  if (previous === value) return;\n  var start = 0;\n  while (previous.charAt(start) === value.charAt(start)) {\n    start++;\n  }\n  var end = 0;\n  while (\n    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&\n    end + start < previous.length &&\n    end + start < value.length\n  ) {\n    end++;\n  }\n\n  if (previous.length !== start + end) {\n    var howMany = previous.length - start - end;\n    model._stringRemove(segments, start, howMany);\n  }\n  if (value.length !== start + end) {\n    var inserted = value.slice(start, value.length - end);\n    model._stringInsert(segments, start, inserted);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function(leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function(op, otherOp, type) {\n    if (!(type === 'left' || type === 'right'))\n      throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1)\n      return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left')\n      return transformX(op, otherOp)[0];\n    else\n      return transformX(otherOp, op)[1];\n  };\n};\n","// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you're welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: require('./json0')\n};\n","/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function(obj) {\n  return (!!obj) && (obj.constructor === Object);\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function(subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function(data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function(c) {\n  var c_ = {p: c.p};\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length-1];\n    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function(op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function(elem) {\n  if (!isArray(elem))\n    throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function(elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {p: c.p.pop()};\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function(snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null)\n      convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null)\n        throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n    // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number')\n        throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld\n      elem[key] = c.li;\n    }\n\n    // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key,0, c.li);\n    }\n\n    // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld here too.\n      elem.splice(key,1);\n    }\n\n    // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n      if (c.lm != key) {\n        var e = elem[key];\n        // Remove it...\n        elem.splice(key,1);\n        // And insert it back.\n        elem.splice(c.lm,0,e);\n      }\n    }\n\n    // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      elem[key] = c.oi;\n    }\n\n    // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      delete elem[key];\n    }\n\n    else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function(op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function(snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {\n  if (p1.length != p2.length)\n    return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))\n      return false;\n  }\n\n  return true;\n};\n\njson.append = function(dest,c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function(op1,op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp,op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function(op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp,c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function(a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t)\n    alen++;\n\n  if (b.na != null || b.t)\n    blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i])\n      return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function(op, path) {\n  return json.commonLengthForOps({p:path}, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function(dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t)\n    cplength++;\n\n  if (otherC.na != null || otherC.t)\n    otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld),[oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od),[oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        if (res.length > 0) {\n          // convert back to old string ops\n          if (c.si != null || c.sd != null) {\n            var p = c.p;\n            for (var i = 0; i < res.length; i++) {\n              c.o = [res[i]];\n              c.p = p.slice();\n              convertToText(c);\n              json.append(dest, c);\n            }\n          } else {\n            c.o = res;\n            json.append(dest, c);\n          }\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n      // this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right')\n          c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm)\n            c.lm++;\n          // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          }\n          // otherC edits the same list we edit\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || (p === to && from < to))\n            c.lm--;\n\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;\n            else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            }\n\n            // step 2: where am i going to put it?\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from)\n                c.lm--;\n            }\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if ((otherTo > otherFrom && to > from) ||\n                  (otherTo < otherFrom && to < from)) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;\n                else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n          else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    }\n    else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest,{p: c.p, od:otherC.oi});\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand)\n          return dest;\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest,c);\n  return dest;\n};\n\nrequire('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = require('./text0');\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n","// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function(initial) {\n    if ((initial != null) && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function(c) {\n  if (typeof c.p !== 'number')\n    throw new Error('component missing position field');\n\n  if ((typeof c.i === 'string') === (typeof c.d === 'string'))\n    throw new Error('component needs an i or d field');\n\n  if (c.p < 0)\n    throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function(snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted)\n        throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function(newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};\n\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};\n\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function(op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function(op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || (c.p === pos && insertAfter)) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function(position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function(dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '')\n        append(dest, {d: s, p: c.p + otherC.i.length});\n\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length)\n        append(dest, {d: c.d, p: c.p - otherC.d.length});\n      else if (c.p + c.d.length <= otherC.p)\n        append(dest, c);\n      else {\n        // They overlap somewhere.\n        var newC = {d: '', p: c.p};\n\n        if (c.p < otherC.p)\n          newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length)\n          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect)\n          throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function(c) {\n  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function(op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\nrequire('./bootstrapTransform')(text, transformComponent, checkValidOp, append);\n","module.exports = {\n  type: require('./text-tp2')\n};\n","// A TP2 implementation of text, following this spec:\n// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README\n//\n// A document is made up of a string and a set of tombstones inserted throughout\n// the string. For example, 'some ', (2 tombstones), 'string'.\n//\n// This is encoded in a document as ['some ', (2 tombstones), 'string']\n// (It should be encoded as {s:'some string', t:[5, -2, 6]} because thats\n// faster in JS, but its not.)\n//\n// Ops are lists of components which iterate over the whole document. (I might\n// change this at some point, but a version thats less strict is backwards\n// compatible.)\n//\n// Components are either:\n//   N:         Skip N characters in the original document\n//   {i:'str'}: Insert 'str' at the current position in the document\n//   {i:N}:     Insert N tombstones at the current position in the document\n//   {d:N}:     Delete (tombstone) N characters at the current position in the document\n//\n// Eg: [3, {i:'hi'}, 5, {d:8}]\n//\n// Snapshots are lists with characters and tombstones. Characters are stored in strings\n// and adjacent tombstones are flattened into numbers.\n//\n// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)\n// would be represented by a document snapshot of ['Hello ', 5, 'world']\n\nvar type = module.exports = {\n  name: 'text-tp2',\n  tp2: true,\n  uri: 'http://sharejs.org/types/text-tp2v1',\n  create: function(initial) {\n    if (initial == null) {\n      initial = '';\n    } else {\n      if (typeof initial != 'string') throw new Error('Initial data must be a string');\n    }\n\n    return {\n      charLength: initial.length,\n      totalLength: initial.length,\n      data: initial.length ? [initial] : []\n    };\n  },\n\n  serialize: function(doc) {\n    if (!doc.data) {\n      throw new Error('invalid doc snapshot');\n    }\n    return doc.data;\n  },\n\n  deserialize: function(data) {\n    var doc = type.create();\n    doc.data = data;\n\n    for (var i = 0; i < data.length; i++) {\n      var component = data[i];\n\n      if (typeof component === 'string') {\n        doc.charLength += component.length;\n        doc.totalLength += component.length;\n      } else {\n        doc.totalLength += component;\n      }\n    }\n\n    return doc;\n  }\n};\n\nvar isArray = Array.isArray || function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\nvar checkOp = function(op) {\n  if (!isArray(op)) throw new Error('Op must be an array of components');\n\n  var last = null;\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (typeof c == 'object') {\n      // The component is an insert or a delete.\n      if (c.i !== undefined) { // Insert.\n        if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts\n              || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts\n          throw new Error('Inserts must insert a string or a +ive number');\n\n      } else if (c.d !== undefined) { // Delete\n        if (!(typeof c.d === 'number' && c.d > 0))\n          throw new Error('Deletes must be a +ive number');\n\n      } else throw new Error('Operation component must define .i or .d');\n\n    } else {\n      // The component must be a skip.\n      if (typeof c != 'number') throw new Error('Op components must be objects or numbers');\n\n      if (c <= 0) throw new Error('Skip components must be a positive number');\n      if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');\n    }\n\n    last = c;\n  }\n};\n\n// Take the next part from the specified position in a document snapshot.\n// position = {index, offset}. It will be updated.\nvar takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {\n  if (position.index >= doc.data.length)\n    throw new Error('Operation goes past the end of the document');\n\n  var part = doc.data[position.index];\n\n  // This can be written as an ugly-arsed giant ternary statement, but its much\n  // more readable like this. Uglify will convert it into said ternary anyway.\n  var result;\n  if (typeof part == 'string') {\n    if (maxlength != null) {\n      result = part.slice(position.offset, position.offset + maxlength);\n    } else {\n      result = part.slice(position.offset);\n    }\n  } else {\n    if (maxlength == null || tombsIndivisible) {\n      result = part - position.offset;\n    } else {\n      result = Math.min(maxlength, part - position.offset);\n    }\n  }\n\n  var resultLen = result.length || result;\n\n  if ((part.length || part) - position.offset > resultLen) {\n    position.offset += resultLen;\n  } else {\n    position.index++;\n    position.offset = 0;\n  }\n\n  return result;\n};\n\n// Append a part to the end of a document\nvar appendDoc = type._appendDoc = function(doc, p) {\n  if (p === 0 || p === '') return;\n\n  if (typeof p === 'string') {\n    doc.charLength += p.length;\n    doc.totalLength += p.length;\n  } else {\n    doc.totalLength += p;\n  }\n\n  var data = doc.data;\n  if (data.length === 0) {\n    data.push(p);\n  } else if (typeof data[data.length - 1] === typeof p) {\n    data[data.length - 1] += p;\n  } else {\n    data.push(p);\n  }\n};\n\n// Apply the op to the document. The document is not modified in the process.\ntype.apply = function(doc, op) {\n  if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {\n    throw new Error('Snapshot is invalid');\n  }\n  checkOp(op);\n\n  var newDoc = type.create();\n  var position = {index: 0, offset: 0};\n\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    var remainder, part;\n\n    if (typeof component == 'number') { // Skip\n      remainder = component;\n      while (remainder > 0) {\n        part = takeDoc(doc, position, remainder);\n        appendDoc(newDoc, part);\n        remainder -= part.length || part;\n      }\n\n    } else if (component.i !== undefined) { // Insert\n      appendDoc(newDoc, component.i);\n\n    } else if (component.d !== undefined) { // Delete\n      remainder = component.d;\n      while (remainder > 0) {\n        part = takeDoc(doc, position, remainder);\n        remainder -= part.length || part;\n      }\n      appendDoc(newDoc, component.d);\n    }\n  }\n  return newDoc;\n};\n\n// Append an op component to the end of the specified op.  Exported for the\n// randomOpGenerator.\nvar append = type._append = function(op, component) {\n  var last;\n\n  if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {\n    // Drop the new component.\n  } else if (op.length === 0) {\n    op.push(component);\n  } else {\n    last = op[op.length - 1];\n    if (typeof component == 'number' && typeof last == 'number') {\n      op[op.length - 1] += component;\n    } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {\n      last.i += component.i;\n    } else if (component.d != null && (last.d != null)) {\n      last.d += component.d;\n    } else {\n      op.push(component);\n    }\n  }\n};\n\nvar take = function(op, cursor, maxlength, insertsIndivisible) {\n  if (cursor.index === op.length) return null;\n  var e = op[cursor.index];\n  var current;\n  var result;\n\n  var offset = cursor.offset;\n\n  // if the current element is a skip, an insert of a number or a delete\n  if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {\n    var c;\n    if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {\n      // Return the rest of the current element.\n      c = current - offset;\n      ++cursor.index;\n      cursor.offset = 0;\n    } else {\n      cursor.offset += maxlength;\n      c = maxlength;\n    }\n\n    // Package the component back up.\n    if (e.i != null) {\n      return {i: c};\n    } else if (e.d != null) {\n      return {d: c};\n    } else {\n      return c;\n    }\n  } else { // Insert of a string.\n    if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {\n      result = {i: e.i.slice(offset)};\n      ++cursor.index;\n      cursor.offset = 0;\n    } else {\n      result = {i: e.i.slice(offset, offset + maxlength)};\n      cursor.offset += maxlength;\n    }\n    return result;\n  }\n};\n\n// Find and return the length of an op component\nvar componentLength = function(component) {\n  if (typeof component === 'number') {\n    return component;\n  } else if (typeof component.i === 'string') {\n    return component.i.length;\n  } else {\n    return component.d || component.i;\n  }\n};\n\n// Normalize an op, removing all empty skips and empty inserts / deletes.\n// Concatenate adjacent inserts and deletes.\ntype.normalize = function(op) {\n  var newOp = [];\n  for (var i = 0; i < op.length; i++) {\n    append(newOp, op[i]);\n  }\n  return newOp;\n};\n\n// This is a helper method to transform and prune. goForwards is true for transform, false for prune.\nvar transformer = function(op, otherOp, goForwards, side) {\n  checkOp(op);\n  checkOp(otherOp);\n\n  var newOp = [];\n\n  // Cursor moving over op. Used by take\n  var cursor = {index:0, offset:0};\n\n  for (var i = 0; i < otherOp.length; i++) {\n    var component = otherOp[i];\n    var len = componentLength(component);\n    var chunk;\n\n    if (component.i != null) { // Insert text or tombs\n      if (goForwards) { // Transform - insert skips over deleted parts.\n        if (side === 'left') {\n          // The left side insert should go first.\n          var next;\n          while ((next = op[cursor.index]) && next.i != null) {\n            append(newOp, take(op, cursor));\n          }\n        }\n        // In any case, skip the inserted text.\n        append(newOp, len);\n\n      } else { // Prune. Remove skips for inserts.\n        while (len > 0) {\n          chunk = take(op, cursor, len, true);\n\n          // The chunk will be null if we run out of components in the other op.\n          if (chunk === null) throw new Error('The transformed op is invalid');\n          if (chunk.d != null)\n            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');\n\n          if (typeof chunk == 'number')\n            len -= chunk;\n          else\n            append(newOp, chunk);\n        }\n      }\n    } else { // Skips or deletes.\n      while (len > 0) {\n        chunk = take(op, cursor, len, true);\n        if (chunk === null) throw new Error('The op traverses more elements than the document has');\n\n        append(newOp, chunk);\n        if (!chunk.i) len -= componentLength(chunk);\n      }\n    }\n  }\n\n  // Append extras from op1.\n  var component;\n  while ((component = take(op, cursor))) {\n    if (component.i === undefined) {\n      throw new Error(\"Remaining fragments in the op: \" + component);\n    }\n    append(newOp, component);\n  }\n  return newOp;\n};\n\n// transform op1 by op2. Return transformed version of op1. op1 and op2 are\n// unchanged by transform. Side should be 'left' or 'right', depending on if\n// op1.id <> op2.id.\n//\n// 'left' == client op for ShareJS.\ntype.transform = function(op, otherOp, side) {\n  if (side != 'left' && side != 'right')\n    throw new Error(\"side (\" + side + \") should be 'left' or 'right'\");\n\n  return transformer(op, otherOp, true, side);\n};\n\ntype.prune = function(op, otherOp) {\n  return transformer(op, otherOp, false);\n};\n\ntype.compose = function(op1, op2) {\n  //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;\n  if (op1 == null) return op2;\n\n  checkOp(op1);\n  checkOp(op2);\n\n  var result = [];\n\n  // Cursor over op1.\n  var cursor = {index:0, offset:0};\n\n  var component;\n\n  for (var i = 0; i < op2.length; i++) {\n    component = op2[i];\n    var len, chunk;\n\n    if (typeof component === 'number') { // Skip\n      // Just copy from op1.\n      len = component;\n      while (len > 0) {\n        chunk = take(op1, cursor, len);\n        if (chunk === null)\n          throw new Error('The op traverses more elements than the document has');\n\n        append(result, chunk);\n        len -= componentLength(chunk);\n      }\n\n    } else if (component.i !== undefined) { // Insert\n      append(result, {i: component.i});\n\n    } else { // Delete\n      len = component.d;\n      while (len > 0) {\n        chunk = take(op1, cursor, len);\n        if (chunk === null)\n          throw new Error('The op traverses more elements than the document has');\n\n        var chunkLength = componentLength(chunk);\n\n        if (chunk.i !== undefined)\n          append(result, {i: chunkLength});\n        else\n          append(result, {d: chunkLength});\n\n        len -= chunkLength;\n      }\n    }\n  }\n\n  // Append extras from op1.\n  while ((component = take(op1, cursor))) {\n    if (component.i === undefined) {\n      throw new Error(\"Remaining fragments in op1: \" + component);\n    }\n    append(result, component);\n  }\n  return result;\n};\n\n","// Text document API for the 'text' type. This implements some standard API\n// methods for any text-like type, so you can easily bind a textarea or\n// something without being fussy about the underlying OT implementation.\n//\n// The API is desigend as a set of functions to be mixed in to some context\n// object as part of its lifecycle. It expects that object to have getSnapshot\n// and submitOp methods, and call _onOp when an operation is received.\n//\n// This API defines:\n//\n// - getLength() returns the length of the document in characters\n// - getText() returns a string of the document\n// - insert(pos, text, [callback]) inserts text at position pos in the document\n// - remove(pos, length, [callback]) removes length characters at position pos\n//\n// A user can define:\n// - onInsert(pos, text): Called when text is inserted.\n// - onRemove(pos, length): Called when text is removed.\n\nmodule.exports = api;\nfunction api(getSnapshot, submitOp) {\n  return {\n    // Returns the text content of the document\n    get: function() { return getSnapshot(); },\n\n    // Returns the number of characters in the string\n    getLength: function() { return getSnapshot().length; },\n\n    // Insert the specified text at the given position in the document\n    insert: function(pos, text, callback) {\n      return submitOp([pos, text], callback);\n    },\n\n    remove: function(pos, length, callback) {\n      return submitOp([pos, {d:length}], callback);\n    },\n\n    // When you use this API, you should implement these two methods\n    // in your editing context.\n    //onInsert: function(pos, text) {},\n    //onRemove: function(pos, removedLength) {},\n\n    _onOp: function(op) {\n      var pos = 0;\n      var spos = 0;\n      for (var i = 0; i < op.length; i++) {\n        var component = op[i];\n        switch (typeof component) {\n          case 'number':\n            pos += component;\n            spos += component;\n            break;\n          case 'string':\n            if (this.onInsert) this.onInsert(pos, component);\n            pos += component.length;\n            break;\n          case 'object':\n            if (this.onRemove) this.onRemove(pos, component.d);\n            spos += component.d;\n        }\n      }\n    }\n  };\n};\napi.provides = {text: true};\n","var type = require('./text');\ntype.api = require('./api');\n\nmodule.exports = {\n  type: type\n};\n","/* Text OT!\n *\n * This is an OT implementation for text. It is the standard implementation of\n * text used by ShareJS.\n *\n * This type is composable but non-invertable. Its similar to ShareJS's old\n * text-composable type, but its not invertable and its very similar to the\n * text-tp2 implementation but it doesn't support tombstones or purging.\n *\n * Ops are lists of components which iterate over the document.\n * Components are either:\n *   A number N: Skip N characters in the original document\n *   \"str\"     : Insert \"str\" at the current position in the document\n *   {d:N}     : Delete N characters at the current position in the document\n *\n * Eg: [3, 'hi', 5, {d:8}]\n *\n * The operation does not have to skip the last characters in the document.\n *\n * Snapshots are strings.\n *\n * Cursors are either a single number (which is the cursor position) or a pair of\n * [anchor, focus] (aka [start, end]). Be aware that end can be before start.\n */\n\n/** @module text */\n\nexports.name = 'text';\nexports.uri = 'http://sharejs.org/types/textv1';\n\n/** Create a new text snapshot.\n *\n * @param {string} initial - initial snapshot data. Optional. Defaults to ''.\n */\nexports.create = function(initial) {\n  if ((initial != null) && typeof initial !== 'string') {\n    throw Error('Initial data must be a string');\n  }\n  return initial || '';\n};\n\nvar isArray = Array.isArray || function(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\";\n};\n\n/** Check the operation is valid. Throws if not valid. */\nvar checkOp = function(op) {\n  if (!isArray(op)) throw Error('Op must be an array of components');\n\n  var last = null;\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    switch (typeof c) {\n      case 'object':\n        // The only valid objects are {d:X} for +ive values of X.\n        if (!(typeof c.d === 'number' && c.d > 0)) throw Error('Object components must be deletes of size > 0');\n        break;\n      case 'string':\n        // Strings are inserts.\n        if (!(c.length > 0)) throw Error('Inserts cannot be empty');\n        break;\n      case 'number':\n        // Numbers must be skips. They have to be +ive numbers.\n        if (!(c > 0)) throw Error('Skip components must be >0');\n        if (typeof last === 'number') throw Error('Adjacent skip components should be combined');\n        break;\n    }\n    last = c;\n  }\n\n  if (typeof last === 'number') throw Error('Op has a trailing skip');\n};\n\n/** Check that the given selection range is valid. */\nvar checkSelection = function(selection) {\n  // This may throw from simply inspecting selection[0] / selection[1]. Thats\n  // sort of ok, though it'll generate the wrong message.\n  if (typeof selection !== 'number'\n      && (typeof selection[0] !== 'number' || typeof selection[1] !== 'number'))\n    throw Error('Invalid selection');\n};\n\n/** Make a function that appends to the given operation. */\nvar makeAppend = function(op) {\n  return function(component) {\n    if (!component || component.d === 0) {\n      // The component is a no-op. Ignore!\n \n    } else if (op.length === 0) {\n      return op.push(component);\n\n    } else if (typeof component === typeof op[op.length - 1]) {\n      if (typeof component === 'object') {\n        return op[op.length - 1].d += component.d;\n      } else {\n        return op[op.length - 1] += component;\n      }\n    } else {\n      return op.push(component);\n    }\n  };\n};\n\n/** Makes and returns utility functions take and peek. */\nvar makeTake = function(op) {\n  // The index of the next component to take\n  var idx = 0;\n  // The offset into the component\n  var offset = 0;\n\n  // Take up to length n from the front of op. If n is -1, take the entire next\n  // op component. If indivisableField == 'd', delete components won't be separated.\n  // If indivisableField == 'i', insert components won't be separated.\n  var take = function(n, indivisableField) {\n    // We're at the end of the operation. The op has skips, forever. Infinity\n    // might make more sense than null here.\n    if (idx === op.length)\n      return n === -1 ? null : n;\n\n    var part;\n    var c = op[idx];\n    if (typeof c === 'number') {\n      // Skip\n      if (n === -1 || c - offset <= n) {\n        part = c - offset;\n        ++idx;\n        offset = 0;\n        return part;\n      } else {\n        offset += n;\n        return n;\n      }\n    } else if (typeof c === 'string') {\n      // Insert\n      if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {\n        part = c.slice(offset);\n        ++idx;\n        offset = 0;\n        return part;\n      } else {\n        part = c.slice(offset, offset + n);\n        offset += n;\n        return part;\n      }\n    } else {\n      // Delete\n      if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {\n        part = {d: c.d - offset};\n        ++idx;\n        offset = 0;\n        return part;\n      } else {\n        offset += n;\n        return {d: n};\n      }\n    }\n  };\n\n  // Peek at the next op that will be returned.\n  var peekType = function() { return op[idx]; };\n\n  return [take, peekType];\n};\n\n/** Get the length of a component */\nvar componentLength = function(c) {\n  // Uglify will compress this down into a ternary\n  if (typeof c === 'number') {\n    return c;\n  } else {\n    return c.length || c.d;\n  }\n};\n\n/** Trim any excess skips from the end of an operation.\n *\n * There should only be at most one, because the operation was made with append.\n */\nvar trim = function(op) {\n  if (op.length > 0 && typeof op[op.length - 1] === 'number') {\n    op.pop();\n  }\n  return op;\n};\n\nexports.normalize = function(op) {\n  var newOp = [];\n  var append = makeAppend(newOp);\n  for (var i = 0; i < op.length; i++) {\n    append(op[i]);\n  }\n  return trim(newOp);\n};\n\n/** Apply an operation to a document snapshot */\nexports.apply = function(str, op) {\n  if (typeof str !== 'string') {\n    throw Error('Snapshot should be a string');\n  }\n  checkOp(op);\n\n  // We'll gather the new document here and join at the end.\n  var newDoc = [];\n\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    switch (typeof component) {\n      case 'number':\n        if (component > str.length) throw Error('The op is too long for this document');\n\n        newDoc.push(str.slice(0, component));\n        // This might be slow for big strings. Consider storing the offset in\n        // str instead of rewriting it each time.\n        str = str.slice(component);\n        break;\n      case 'string':\n        newDoc.push(component);\n        break;\n      case 'object':\n        str = str.slice(component.d);\n        break;\n    }\n  }\n\n  return newDoc.join('') + str;\n};\n\n/** Transform op by otherOp.\n *\n * @param op - The operation to transform\n * @param otherOp - Operation to transform it by\n * @param side - Either 'left' or 'right'\n */\nexports.transform = function(op, otherOp, side) {\n  if (side != 'left' && side != 'right') throw Error(\"side (\" + side + \") must be 'left' or 'right'\");\n\n  checkOp(op);\n  checkOp(otherOp);\n\n  var newOp = [];\n  var append = makeAppend(newOp);\n\n  var _fns = makeTake(op);\n  var take = _fns[0],\n      peek = _fns[1];\n\n  for (var i = 0; i < otherOp.length; i++) {\n    var component = otherOp[i];\n\n    var length, chunk;\n    switch (typeof component) {\n      case 'number': // Skip\n        length = component;\n        while (length > 0) {\n          chunk = take(length, 'i');\n          append(chunk);\n          if (typeof chunk !== 'string') {\n            length -= componentLength(chunk);\n          }\n        }\n        break;\n\n      case 'string': // Insert\n        if (side === 'left') {\n          // The left insert should go first.\n          if (typeof peek() === 'string') {\n            append(take(-1));\n          }\n        }\n\n        // Otherwise skip the inserted text.\n        append(component.length);\n        break;\n\n      case 'object': // Delete\n        length = component.d;\n        while (length > 0) {\n          chunk = take(length, 'i');\n          switch (typeof chunk) {\n            case 'number':\n              length -= chunk;\n              break;\n            case 'string':\n              append(chunk);\n              break;\n            case 'object':\n              // The delete is unnecessary now - the text has already been deleted.\n              length -= chunk.d;\n          }\n        }\n        break;\n    }\n  }\n  \n  // Append any extra data in op1.\n  while ((component = take(-1)))\n    append(component);\n  \n  return trim(newOp);\n};\n\n/** Compose op1 and op2 together and return the result */\nexports.compose = function(op1, op2) {\n  checkOp(op1);\n  checkOp(op2);\n\n  var result = [];\n  var append = makeAppend(result);\n  var take = makeTake(op1)[0];\n\n  for (var i = 0; i < op2.length; i++) {\n    var component = op2[i];\n    var length, chunk;\n    switch (typeof component) {\n      case 'number': // Skip\n        length = component;\n        while (length > 0) {\n          chunk = take(length, 'd');\n          append(chunk);\n          if (typeof chunk !== 'object') {\n            length -= componentLength(chunk);\n          }\n        }\n        break;\n\n      case 'string': // Insert\n        append(component);\n        break;\n\n      case 'object': // Delete\n        length = component.d;\n\n        while (length > 0) {\n          chunk = take(length, 'd');\n\n          switch (typeof chunk) {\n            case 'number':\n              append({d: chunk});\n              length -= chunk;\n              break;\n            case 'string':\n              length -= chunk.length;\n              break;\n            case 'object':\n              append(chunk);\n          }\n        }\n        break;\n    }\n  }\n\n  while ((component = take(-1)))\n    append(component);\n\n  return trim(result);\n};\n\n\nvar transformPosition = function(cursor, op) {\n  var pos = 0;\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (cursor <= pos) break;\n\n    // I could actually use the op_iter stuff above - but I think its simpler\n    // like this.\n    switch (typeof c) {\n      case 'number':\n        if (cursor <= pos + c)\n          return cursor;\n        pos += c;\n        break;\n\n      case 'string':\n        pos += c.length;\n        cursor += c.length;\n        break;\n\n      case 'object':\n        cursor -= Math.min(c.d, cursor - pos);\n        break;\n    }\n  }\n  return cursor;\n};\n\nexports.transformSelection = function(selection, op, isOwnOp) {\n  var pos = 0;\n  if (isOwnOp) {\n    // Just track the position. We'll teleport the cursor to the end anyway.\n    // This works because text ops don't have any trailing skips at the end - so the last\n    // component is the last thing.\n    for (var i = 0; i < op.length; i++) {\n      var c = op[i];\n      switch (typeof c) {\n        case 'number':\n          pos += c;\n          break;\n        case 'string':\n          pos += c.length;\n          break;\n        // Just eat deletes.\n      }\n    }\n    return pos;\n  } else {\n    return typeof selection === 'number' ?\n      transformPosition(selection, op) : [transformPosition(selection[0], op), transformPosition(selection[1], op)];\n  }\n};\n\nexports.selectionEq = function(c1, c2) {\n  if (c1[0] != null && c1[0] === c1[1]) c1 = c1[0];\n  if (c2[0] != null && c2[0] === c2[1]) c2 = c2[0];\n  return c1 === c2 || (c1[0] != null && c2[0] != null && c1[0] === c2[0] && c1[1] == c2[1]);\n};\n\n","(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require(\"g5I+bs\"))","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n","(function (global){\n/*! http://mths.be/punycode v1.2.4 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /\\x2E|\\u3002|\\uFF0E|\\uFF61/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\twhile (length--) {\n\t\t\tarray[length] = fn(array[length]);\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings.\n\t * @private\n\t * @param {String} domain The domain name.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\treturn map(string.split(regexSeparators), fn).join('.');\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <http://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols to a Punycode string of ASCII-only\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name to Unicode. Only the\n\t * Punycoded parts of the domain name will be converted, i.e. it doesn't\n\t * matter if you call it on a string that has already been converted to\n\t * Unicode.\n\t * @memberOf punycode\n\t * @param {String} domain The Punycode domain name to convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(domain) {\n\t\treturn mapDomain(domain, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name to Punycode. Only the\n\t * non-ASCII parts of the domain name will be converted, i.e. it doesn't\n\t * matter if you call it with a domain that's already in ASCII.\n\t * @memberOf punycode\n\t * @param {String} domain The domain name to convert, as a Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name.\n\t */\n\tfunction toASCII(domain) {\n\t\treturn mapDomain(domain, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.2.4',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <http://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})","'use strict';\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","'use strict';\n\nvar Utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false,\n    decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos));\n            val = options.decoder(part.slice(pos + 1));\n        }\n        if (has.call(obj, key)) {\n            obj[key] = [].concat(obj[key]).concat(val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, segment[1])) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].replace(/\\[|\\]/g, ''))) {\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n","'use strict';\n\nvar Utils = require('./utils');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar defaults = {\n    delimiter: '&',\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true,\n    encoder: Utils.encode\n};\n\nvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder ? encoder(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n        if (encoder) {\n            return [encoder(prefix) + '=' + encoder(obj)];\n        }\n        return [prefix + '=' + String(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        } else {\n            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n","'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            target[source] = true;\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (obj[i] && typeof obj[i] === 'object') {\n                compacted.push(exports.compact(obj[i], refs));\n            } else if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","/*!\n * QUnit 2.0.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-07-23T19:39Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar autorun = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\tdelete a[ prop ];\n\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\tcase \"Symbol\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn't support IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"2.0.1\";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tif ( testEnvironment && ( testEnvironment.setup || testEnvironment.teardown ) ) {\n\t\t\tconsole.warn(\n\t\t\t\t\"Module's `setup` and `teardown` are not hooks anymore on QUnit 2.0, use \" +\n\t\t\t\t\"`beforeEach` and `afterEach` instead\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tmoduleFns = {\n\t\t\tbefore: setHook( module, \"before\" ),\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" ),\n\t\t\tafter: setHook( module, \"after\" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName ),\n\t\t\t\ttestsRun: 0\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\tparentModule.childModule = module;\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() while test already started running\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"QUnit.start cannot be called inside a test context. This feature is removed in \" +\n\t\t\t\t\"QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tscheduleBegin();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tif ( !runStarted ) {\n\t\t\tconfig.blocking = false;\n\n\t\t\tif ( config.autostart ) {\n\t\t\t\tscheduleBegin();\n\t\t\t}\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction scheduleBegin() {\n\n\trunStarted = true;\n\n\t// Add a slight delay to allow definition of more modules and tests.\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tautorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar unitSampler,\n\tfocused = false,\n\tpriorityCount = 0;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\tthis.expected = null;\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.before;\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\tdelete this.module.testEnvironment.after;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tinternalRecover( this );\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName, hookOwner ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tif ( hookName === \"before\" ) {\n\t\t\t\tif ( hookOwner.testsRun !== 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttest.preserveEnvironment = true;\n\t\t\t}\n\n\t\t\tif ( hookName === \"after\" && hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tskipped = !!this.skip,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\tnotifyTestsRan( this.module );\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: skipped,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: skipped ? 0 : this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack\n\t\t} );\n\n\t\tconfig.current = undefined;\n\t},\n\n\tpreserveTestEnvironment: function() {\n\t\tif ( this.preserveEnvironment ) {\n\t\t\tthis.module.testEnvironment = this.testEnvironment;\n\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\t}\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"before\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.preserveTestEnvironment();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\t\t\t\ttest.hooks( \"after\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, resume, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tresume = internalStop( test );\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { resume(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tresume();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, callback ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, callback ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Put a hold on processing and return a function that will release it.\nfunction internalStop( test ) {\n\tvar released = false;\n\n\ttest.semaphore += 1;\n\tconfig.blocking = true;\n\n\t// Set a recovery timeout, if so configured.\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\tinternalRecover( test );\n\t\t}, config.testTimeout );\n\t}\n\n\treturn function resume() {\n\t\tif ( released ) {\n\t\t\treturn;\n\t\t}\n\n\t\treleased = true;\n\t\ttest.semaphore -= 1;\n\t\tinternalStart( test );\n\t};\n}\n\n// Forcefully release all processing holds.\nfunction internalRecover( test ) {\n\ttest.semaphore = 0;\n\tinternalStart( test );\n}\n\n// Release a processing hold, scheduling a resumption attempt if no holds remain.\nfunction internalStart( test ) {\n\n\t// If semaphore is non-numeric, throw error\n\tif ( isNaN( test.semaphore ) ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Invalid value on test.semaphore\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\t// Don't start until equal number of stop-calls\n\tif ( test.semaphore > 0 ) {\n\t\treturn;\n\t}\n\n\t// Throw an Error if start is called more often than stop\n\tif ( test.semaphore < 0 ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Tried to restart test while already started (test's semaphore was 0 already)\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\t// Add a slight delay to allow more assertions etc.\n\tif ( defined.setTimeout ) {\n\t\tif ( config.timeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t}\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( test.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction numberOfTests( module ) {\n\tvar count = module.tests.length;\n\twhile ( module = module.childModule ) {\n\t\tcount += module.tests.length;\n\t}\n\treturn count;\n}\n\nfunction notifyTestsRan( module ) {\n\tmodule.testsRun++;\n\twhile ( module = module.parentModule ) {\n\t\tmodule.testsRun++;\n\t}\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Put a hold on processing and return a function that will release it a maximum of once.\n\tasync: function( count ) {\n\t\tvar resume,\n\t\t\ttest = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.usedAsync = true;\n\t\tresume = internalStop( test );\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpopped = true;\n\t\t\tresume();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\tif ( message == null ) {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"throws/raises does not accept a string value for the expected argument.\\n\" +\n\t\t\t\t\t\"Use a non-string object value (e.g. regExp) instead if it's necessary.\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rath <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === \"object\" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === \"object\" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\t\t\"date\": useStrictEquality,\n\n\t\t\"nan\": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We're done when there's nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tfunction isArray( obj ) {\n\t\treturn (\n\n\t\t\t//Native Arrays\n\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t// NodeList objects\n\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined ) &&\n\t\t\t( obj.length ?\n\t\t\t\tobj.item( 0 ) === obj[ 0 ] :\n\t\t\t\t( obj.item( 0 ) === null && obj[ 0 ] === undefined )\n\t\t\t)\n\t\t);\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if ( isArray( obj ) ) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"(\";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\n\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal,\n\t\t\t\tsymbol: function( sym ) {\n\t\t\t\t\treturn sym.toString();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: \"  \",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\nfunction applyDeprecated( name ) {\n\treturn function() {\n\t\tthrow new Error(\n\t\t\tname + \" is removed in QUnit 2.0.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n}\n\nObject.keys( Assert.prototype ).forEach( function( key ) {\n\tQUnit[ key ] = applyDeprecated( \"`QUnit.\" + key + \"`\" );\n} );\n\nQUnit.asyncTest = function() {\n\tthrow new Error(\n\t\t\"asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nQUnit.stop = function() {\n\tthrow new Error(\n\t\t\"QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nfunction resetThrower() {\n\tthrow new Error(\n\t\t\"QUnit.reset is removed in QUnit 2.0 without replacement.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n}\n\nObject.defineProperty( QUnit, \"reset\", {\n\tget: function() {\n\t\treturn resetThrower;\n\t},\n\tset: resetThrower\n} );\n\nif ( defined.document ) {\n\tif ( window.QUnit ) {\n\t\tthrow new Error( \"QUnit has already been defined.\" );\n\t}\n\n\t[\n\t\t\"test\",\n\t\t\"module\",\n\t\t\"expect\",\n\t\t\"start\",\n\t\t\"ok\",\n\t\t\"notOk\",\n\t\t\"equal\",\n\t\t\"notEqual\",\n\t\t\"propEqual\",\n\t\t\"notPropEqual\",\n\t\t\"deepEqual\",\n\t\t\"notDeepEqual\",\n\t\t\"strictEqual\",\n\t\t\"notStrictEqual\",\n\t\t\"throws\",\n\t\t\"raises\"\n\t].forEach( function( key ) {\n\t\twindow[ key ] = applyDeprecated( \"The global `\" + key + \"`\" );\n\t} );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\nvar config = QUnit.config,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Stores fixture HTML for resetting later\nfunction storeFixture() {\n\n\t// Avoid overwriting user-defined values\n\tif ( hasOwn.call( config, \"fixture\" ) ) {\n\t\treturn;\n\t}\n\n\tvar fixture = document.getElementById( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nQUnit.begin( storeFixture );\n\n// Resets the fixture DOM element if available.\nfunction resetFixture() {\n\tif ( config.fixture == null ) {\n\t\treturn;\n\t}\n\n\tvar fixture = document.getElementById( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n}\n\nQUnit.testStart( resetFixture );\n\n}() );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== \"undefined\" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against \"moduleName: testName\"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: \"hidepassed\",\n\t\tlabel: \"Hide passed tests\",\n\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"noglobals\",\n\t\tlabel: \"Check for Globals\",\n\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"notrycatch\",\n\t\tlabel: \"No try-catch\",\n\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== \"string\" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\tname = decodeQueryParam( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeQueryParam( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\nfunction decodeQueryParam( param ) {\n\treturn decodeURIComponent( param.replace( /\\+/g, \"%20\" ) );\n}\n\n// Don't load the HTML Reporter on non-browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\nQUnit.init = function() {\n\tthrow new Error(\n\t\t\"QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n// Escape text for attribute or text content.\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t} );\n}\n\nfunction addEvent( elem, type, fn ) {\n\telem.addEventListener( type, fn, false );\n}\n\nfunction removeEvent( elem, type, fn ) {\n\telem.removeEventListener( type, fn, false );\n}\n\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction interceptNavigation( ev ) {\n\tapplyUrlParams();\n\n\tif ( ev && ev.preventDefault ) {\n\t\tev.preventDefault();\n\t}\n\n\treturn false;\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'><input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' />\" + escapeText( val.label ) + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = \"?\",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += \"&\";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar i,\n\t\tselectedModules = [],\n\t\tmodulesList = id( \"qunit-modulefilter-dropdown-list\" ).getElementsByTagName( \"input\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\tif ( modulesList[ i ].checked ) {\n\t\t\tselectedModules.push( modulesList[ i ].value );\n\t\t}\n\t}\n\n\twindow.location = setUrl( {\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\t\tmoduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,\n\n\t\t// Remove module and testId filter\n\t\tmodule: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"change\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( document.createTextNode( \" \" ) );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", interceptNavigation );\n\n\treturn filter;\n}\n\nfunction moduleListHtml () {\n\tvar i, checked,\n\t\thtml = \"\";\n\n\tfor ( i = 0; i < config.modules.length; i++ ) {\n\t\tif ( config.modules[ i ].name !== \"\" ) {\n\t\t\tchecked = config.moduleId.indexOf( config.modules[ i ].moduleId ) > -1;\n\t\t\thtml += \"<li><label class='clickable\" + ( checked ? \" checked\" : \"\" ) +\n\t\t\t\t\"'><input type='checkbox' \" + \"value='\" + config.modules[ i ].moduleId + \"'\" +\n\t\t\t\t( checked ? \" checked='checked'\" : \"\" ) + \" />\" +\n\t\t\t\tescapeText( config.modules[ i ].name ) + \"</label></li>\";\n\t\t}\n\t}\n\n\treturn html;\n}\n\nfunction toolbarModuleFilter () {\n\tvar allCheckbox, commit, reset,\n\t\tmoduleFilter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tmoduleSearch = document.createElement( \"input\" ),\n\t\tdropDown = document.createElement( \"div\" ),\n\t\tactions = document.createElement( \"span\" ),\n\t\tdropDownList = document.createElement( \"ul\" ),\n\t\tdirty = false;\n\n\tmoduleSearch.id = \"qunit-modulefilter-search\";\n\taddEvent( moduleSearch, \"input\", searchInput );\n\taddEvent( moduleSearch, \"input\", searchFocus );\n\taddEvent( moduleSearch, \"focus\", searchFocus );\n\taddEvent( moduleSearch, \"click\", searchFocus );\n\n\tlabel.id = \"qunit-modulefilter-search-container\";\n\tlabel.innerHTML = \"Module: \";\n\tlabel.appendChild( moduleSearch );\n\n\tactions.id = \"qunit-modulefilter-actions\";\n\tactions.innerHTML =\n\t\t\"<button style='display:none'>Apply</button>\" +\n\t\t\"<button type='reset' style='display:none'>Reset</button>\" +\n\t\t\"<label class='clickable\" +\n\t\t( config.moduleId.length ? \"\" : \" checked\" ) +\n\t\t\"'><input type='checkbox'\" + ( config.moduleId.length ? \"\" : \" checked='checked'\" ) +\n\t\t\">All modules</label>\";\n\tallCheckbox = actions.lastChild.firstChild;\n\tcommit = actions.firstChild;\n\treset = commit.nextSibling;\n\taddEvent( commit, \"click\", applyUrlParams );\n\n\tdropDownList.id = \"qunit-modulefilter-dropdown-list\";\n\tdropDownList.innerHTML = moduleListHtml();\n\n\tdropDown.id = \"qunit-modulefilter-dropdown\";\n\tdropDown.style.display = \"none\";\n\tdropDown.appendChild( actions );\n\tdropDown.appendChild( dropDownList );\n\taddEvent( dropDown, \"change\", selectionChange );\n\tselectionChange();\n\n\tmoduleFilter.id = \"qunit-modulefilter\";\n\tmoduleFilter.appendChild( label );\n\tmoduleFilter.appendChild( dropDown ) ;\n\taddEvent( moduleFilter, \"submit\", interceptNavigation );\n\taddEvent( moduleFilter, \"reset\", function() {\n\n\t\t// Let the reset happen, then update styles\n\t\twindow.setTimeout( selectionChange );\n\t} );\n\n\t// Enables show/hide for the dropdown\n\tfunction searchFocus() {\n\t\tif ( dropDown.style.display !== \"none\" ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdropDown.style.display = \"block\";\n\t\taddEvent( document, \"click\", hideHandler );\n\t\taddEvent( document, \"keydown\", hideHandler );\n\n\t\t// Hide on Escape keydown or outside-container click\n\t\tfunction hideHandler( e )  {\n\t\t\tvar inContainer = moduleFilter.contains( e.target );\n\n\t\t\tif ( e.keyCode === 27 || !inContainer ) {\n\t\t\t\tif ( e.keyCode === 27 && inContainer ) {\n\t\t\t\t\tmoduleSearch.focus();\n\t\t\t\t}\n\t\t\t\tdropDown.style.display = \"none\";\n\t\t\t\tremoveEvent( document, \"click\", hideHandler );\n\t\t\t\tremoveEvent( document, \"keydown\", hideHandler );\n\t\t\t\tmoduleSearch.value = \"\";\n\t\t\t\tsearchInput();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Processes module search box input\n\tfunction searchInput() {\n\t\tvar i, item,\n\t\t\tsearchText = moduleSearch.value.toLowerCase(),\n\t\t\tlistItems = dropDownList.children;\n\n\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\titem = listItems[ i ];\n\t\t\tif ( !searchText || item.textContent.toLowerCase().indexOf( searchText ) > -1 ) {\n\t\t\t\titem.style.display = \"\";\n\t\t\t} else {\n\t\t\t\titem.style.display = \"none\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Processes selection changes\n\tfunction selectionChange( evt ) {\n\t\tvar i, item,\n\t\t\tcheckbox = evt && evt.target || allCheckbox,\n\t\t\tmodulesList = dropDownList.getElementsByTagName( \"input\" ),\n\t\t\tselectedNames = [];\n\n\t\ttoggleClass( checkbox.parentNode, \"checked\", checkbox.checked );\n\n\t\tdirty = false;\n\t\tif ( checkbox.checked && checkbox !== allCheckbox ) {\n\t\t   allCheckbox.checked = false;\n\t\t   removeClass( allCheckbox.parentNode, \"checked\" );\n\t\t}\n\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\titem = modulesList[ i ];\n\t\t\tif ( !evt ) {\n\t\t\t\ttoggleClass( item.parentNode, \"checked\", item.checked );\n\t\t\t} else if ( checkbox === allCheckbox && checkbox.checked ) {\n\t\t\t\titem.checked = false;\n\t\t\t\tremoveClass( item.parentNode, \"checked\" );\n\t\t\t}\n\t\t\tdirty = dirty || ( item.checked !== item.defaultChecked );\n\t\t\tif ( item.checked ) {\n\t\t\t\tselectedNames.push( item.parentNode.textContent );\n\t\t\t}\n\t\t}\n\n\t\tcommit.style.display = reset.style.display = dirty ? \"\" : \"none\";\n\t\tmoduleSearch.placeholder = selectedNames.join( \", \" ) || allCheckbox.parentNode.textContent;\n\t\tmoduleSearch.title = \"Type to filter list. Current selection:\\n\" +\n\t\t\t( selectedNames.join( \"\\n\" ) || allCheckbox.parentNode.textContent );\n\t}\n\n\treturn moduleFilter;\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarModuleFilter() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbar.appendChild( document.createElement( \"div\" ) ).className = \"clearfix\";\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn \"\";\n\t}\n\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t\"'>Run all tests</a></div>\";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( \"qunit\" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\tappendFilteredTest() +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( \"qunit-tests\" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, \"hidepass\" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show  for good,  for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// The pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\tescapeText( expected ) +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t} else {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\" serialization</td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t} );\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === \"complete\" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n","var racer = require('racer');\nvar BCSocket = require('browserchannel/dist/bcsocket-uncompressed').BCSocket;\n\nvar CLIENT_OPTIONS = JSON.parse('{\"base\":\"/channel\",\"reconnect\":true}');\n\nracer.Model.prototype._createSocket = function(bundle) {\n  return new Socket(CLIENT_OPTIONS);\n};\n\n// Options:\n\n// base               - string  - base url part ('/channel' by default)\n// browserChannelOnly - boolean - don't use websockets (false by default)\n// srvPort            - number  - port for http (undefined by default)\n// srvSecurePort      - number  - port for https (undefined by default)\n// timeout            - number  - base timeout for reconnection (10000 ms by default)\n// timeoutIncrement   - number  - additional part of timeout (add every\n//                                new attempt - 10000 ms by default)\n\nfunction Socket(options) {\n  this._options = options;\n  this._messageQueue = [];\n  this._connectedOnce = false;\n  this._attemptNum = 0;\n  this._url = getWebSocketURL(options.base, options.srvPort, options.srvSecurePort);\n\n  if (supportWebSockets() && !options.browserChannelOnly) {\n    this._createWebSocket();\n  } else {\n    this._createBrowserChannel();\n  }\n}\n\nSocket.prototype._createWebSocket = function() {\n\n  this._type = 'websocket';\n  this._socket = new WebSocket(this._url);\n\n  this.open = this._createWebSocket.bind(this);\n  this._syncState();\n\n  this._socket.onmessage = this._ws_onmessage.bind(this);\n  this._socket.onopen = this._ws_onopen.bind(this);\n  this._socket.onclose = this._ws_onclose.bind(this);\n  \n};\n\nSocket.prototype._createBrowserChannel = function() {\n  this._type = 'browserchannel';\n  this._socket = BCSocket(this._options.base, this._options);\n\n  this.open = this._createBrowserChannel.bind(this);\n  this._syncState();\n\n  this._socket.onmessage = this._bc_onmessage.bind(this);\n  this._socket.onopen = this._bc_onopen.bind(this);\n  this._socket.onclose = this._bc_onclose.bind(this);\n};\n\nSocket.prototype._ws_onmessage = function(message) {\n  this._syncState();\n  message.data = JSON.parse(message.data);\n  this.onmessage && this.onmessage(message);\n};\n\nSocket.prototype._ws_onopen = function(event) {\n  this._attemptNum = 0;\n  this._connectedOnce = true;\n\n  this._syncState();\n  this._flushQueue();\n\n  this.onopen && this.onopen(event);\n};\n\nSocket.prototype._ws_onclose = function(event) {\n  this._syncState();\n  console.log('WebSocket: connection is broken', event);\n  \n  this.onclose && this.onclose(event);\n\n  if (!this._connectedOnce) {\n    return this._createBrowserChannel();\n  }\n\n  if (this._options.reconnect && !event.wasClean) {\n    setTimeout(this._createWebSocket.bind(this), this._getTimeout());\n  }\n  this._attemptNum++;\n};\n\nSocket.prototype._getTimeout = function(){\n  var base = (this._options.timeout || 10000);\n  var increment = (this._options.timeoutIncrement || 10000) * this._attemptNum;\n  return  base + increment;\n};\n\nSocket.prototype._bc_onmessage = function(data) {\n  this._syncState();\n  this.onmessage && this.onmessage(data);\n};\n\nSocket.prototype._bc_onopen = function(event) {\n  this._syncState();\n  this.onopen && this.onopen(event);\n};\n\nSocket.prototype._bc_onclose = function(event) {\n  this._syncState();\n  this.onclose && this.onclose(event);\n};\n\nSocket.prototype._flushQueue = function(){\n  while (this._messageQueue.length !== 0) {\n    var data = this._messageQueue.shift();\n    this._send(data);\n  }\n};\n\nSocket.prototype._send = function(data){\n  if (this._type === 'websocket' && (typeof data !== 'string')) data = JSON.stringify(data);\n\n  this._socket.send(data);\n};\n\nSocket.prototype.send = function(data){\n  if (this._type === 'websocket') {\n    if (this._socket.readyState === WebSocket.OPEN && this._messageQueue.length === 0) {\n      this._send(data);\n    } else {\n      this._messageQueue.push(data);\n    }\n  } else {\n    this._send(data);\n  }\n};\n\nSocket.prototype.close = function(){\n  this._socket.close();\n};\n\nSocket.prototype._syncState = function(){\n  this.readyState = this._socket.readyState;\n};\n\n// ShareJS constants\nSocket.prototype.canSendWhileConnecting = true;\nSocket.prototype.canSendJSON = true;\n\n// WebSocket constants\nSocket.prototype.CONNECTING = 0;\nSocket.prototype.OPEN = 1;\nSocket.prototype.CLOSING = 2;\nSocket.prototype.CLOSED = 3;\n\nfunction supportWebSockets(){\n  // The condition is from Modernizr\n  // https://github.com/Modernizr/Modernizr/blob/master/feature-detects/websockets.js#L28\n  return 'WebSocket' in window && window.WebSocket.CLOSING === 2;\n}\n\nfunction getWebSocketURL(base, srvPort, srvSecurePort){\n  var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:', port;\n\n  if (protocol === 'ws:' && srvPort) {\n    port = \":\" + srvPort;\n  } else if (protocol === 'wss:' && srvSecurePort) {\n    port = \":\" + srvSecurePort;\n  }\n  return protocol + '//' + window.location.host + (port || \"\") + base;\n}\n\n// Maybe need to use reconnection timing algorithm from\n// http://blog.johnryding.com/post/78544969349/how-to-reconnect-web-sockets-in-a-realtime-web-app\n\n\n","var EventEmitter = require('events').EventEmitter;\nvar util = require('./util');\n\nmodule.exports = Channel;\n\nfunction Channel(socket) {\n  EventEmitter.call(this);\n\n  this.socket = socket;\n  this.messages = new Messages();\n\n  var channel = this;\n  var onmessage = socket.onmessage;\n  socket.onmessage = function(message) {\n    var data = message.data;\n    try {\n      if (typeof data === 'string') data = JSON.parse(data);\n      if (data && data.racer) return channel._onMessage(data);\n      onmessage && onmessage.call(socket, message);\n    }\n    catch(error) {\n      console.log(error);\n    }\n    \n\n  };\n}\n\nutil.mergeInto(Channel.prototype, EventEmitter.prototype);\n\nChannel.prototype.send = function(name, data, cb) {\n  var message = this.messages.add(name, data, cb);\n  // Proactively call the toJSON function, since the Google Closure JSON\n  // serializer doesn't check for it\n  this.socket.send(message.toJSON());\n};\n\nChannel.prototype._reply = function(id, name, data) {\n  var message = new Message(id, true, name, data);\n  this.socket.send(message.toJSON());\n};\n\nChannel.prototype._onMessage = function(data) {\n  if (data.ack) {\n    var message = this.messages.remove(data.id);\n    if (message && message.cb) message.cb.apply(null, data.data);\n    return;\n  }\n  var name = data.racer;\n  if (data.cb) {\n    var channel = this;\n    var hasListeners = this.emit(name, data.data, function() {\n      var args = Array.prototype.slice.call(arguments);\n      channel._reply(data.id, name, args);\n    });\n    if (!hasListeners) this._reply(data.id, name);\n  } else {\n    this.emit(name, data.data);\n    this._reply(data.id, name);\n  }\n};\n\nfunction MessagesMap() {}\n\nfunction Messages() {\n  this.map = new MessagesMap();\n  this.idCount = 0;\n}\nMessages.prototype.id = function() {\n  return (++this.idCount).toString(36);\n};\nMessages.prototype.add = function(name, data, cb) {\n  var message = new Message(this.id(), false, name, data, cb);\n  this.map[message.id] = message;\n  return message;\n};\nMessages.prototype.remove = function(id) {\n  var message = this.map[id];\n  delete this.map[id];\n  return message;\n};\n\nfunction Message(id, ack, name, data, cb) {\n  this.id = id;\n  this.ack = ack;\n  this.name = name;\n  this.data = data;\n  this.cb = cb;\n}\nMessage.prototype.toJSON = function() {\n  return {\n    racer: this.name\n  , id: this.id\n  , data: this.data\n  , ack: +this.ack\n  , cb: (this.cb) ? 1 : 0\n  };\n};\n","module.exports = Doc;\n\nfunction Doc(model, collectionName, id) {\n  this.collectionName = collectionName;\n  this.id = id;\n  this.collectionData = model && model.data[collectionName];\n}\n\nDoc.prototype.path = function(segments) {\n  return this.collectionName + '.' + this.id + '.' + segments.join('.');\n};\n\nDoc.prototype._errorMessage = function(description, segments, value) {\n  return description + ' at ' + this.path(segments) + ': ' +\n    JSON.stringify(value, null, 2);\n};\n","var Doc = require('./Doc');\nvar util = require('../util');\n\nmodule.exports = LocalDoc;\n\nfunction LocalDoc(model, collectionName, id, snapshot) {\n  Doc.call(this, model, collectionName, id);\n  this.snapshot = snapshot;\n  this._updateCollectionData();\n}\n\nLocalDoc.prototype = new Doc();\n\nLocalDoc.prototype._updateCollectionData = function() {\n  this.collectionData[this.id] = this.snapshot;\n};\n\nLocalDoc.prototype.set = function(segments, value, cb) {\n  function set(node, key) {\n    var previous = node[key];\n    node[key] = value;\n    return previous;\n  }\n  return this._apply(segments, set, cb);\n};\n\nLocalDoc.prototype.del = function(segments, cb) {\n  // Don't do anything if the value is already undefined, since\n  // apply creates objects as it traverses, and the del method\n  // should not create anything\n  var previous = this.get(segments);\n  if (previous === void 0) {\n    cb();\n    return;\n  }\n  function del(node, key) {\n    delete node[key];\n    return previous;\n  }\n  return this._apply(segments, del, cb);\n};\n\nLocalDoc.prototype.increment = function(segments, byNumber, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'number' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'increment on non-number', segments, value\n    ));\n  }\n  function increment(node, key) {\n    var value = (node[key] || 0) + byNumber;\n    node[key] = value;\n    return value;\n  }\n  return this._validatedApply(segments, validate, increment, cb);\n};\n\nLocalDoc.prototype.push = function(segments, value, cb) {\n  function push(arr) {\n    return arr.push(value);\n  }\n  return this._arrayApply(segments, push, cb);\n};\n\nLocalDoc.prototype.unshift = function(segments, value, cb) {\n  function unshift(arr) {\n    return arr.unshift(value);\n  }\n  return this._arrayApply(segments, unshift, cb);\n};\n\nLocalDoc.prototype.insert = function(segments, index, values, cb) {\n  function insert(arr) {\n    arr.splice.apply(arr, [index, 0].concat(values));\n    return arr.length;\n  }\n  return this._arrayApply(segments, insert, cb);\n};\n\nLocalDoc.prototype.pop = function(segments, cb) {\n  function pop(arr) {\n    return arr.pop();\n  }\n  return this._arrayApply(segments, pop, cb);\n};\n\nLocalDoc.prototype.shift = function(segments, cb) {\n  function shift(arr) {\n    return arr.shift();\n  }\n  return this._arrayApply(segments, shift, cb);\n};\n\nLocalDoc.prototype.remove = function(segments, index, howMany, cb) {\n  function remove(arr) {\n    return arr.splice(index, howMany);\n  }\n  return this._arrayApply(segments, remove, cb);\n};\n\nLocalDoc.prototype.move = function(segments, from, to, howMany, cb) {\n  function move(arr) {\n    // Remove from old location\n    var values = arr.splice(from, howMany);\n    // Insert in new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n    return values;\n  }\n  return this._arrayApply(segments, move, cb);\n};\n\nLocalDoc.prototype.stringInsert = function(segments, index, value, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'string' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'stringInsert on non-string', segments, value\n    ));\n  }\n  function stringInsert(node, key) {\n    var previous = node[key];\n    if (previous == null) {\n      node[key] = value;\n      return previous;\n    }\n    node[key] = previous.slice(0, index) + value + previous.slice(index);\n    return previous;\n  }\n  return this._validatedApply(segments, validate, stringInsert, cb);\n};\n\nLocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'string' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'stringRemove on non-string', segments, value\n    ));\n  }\n  function stringRemove(node, key) {\n    var previous = node[key];\n    if (previous == null) return previous;\n    if (index < 0) index += previous.length;\n    node[key] = previous.slice(0, index) + previous.slice(index + howMany);\n    return previous;\n  }\n  return this._validatedApply(segments, validate, stringRemove, cb);\n};\n\nLocalDoc.prototype.get = function(segments) {\n  return util.lookup(segments, this.snapshot);\n};\n\n/**\n * @param {Array} segments is the array representing a path\n * @param {Function} fn(node, key) applies a mutation on node[key]\n * @return {Object} returns the return value of fn(node, key)\n */\nLocalDoc.prototype._createImplied = function(segments, fn) {\n  var node = this;\n  var key = 'snapshot';\n  var i = 0;\n  var nextKey = segments[i++];\n  while (nextKey != null) {\n    // Get or create implied object or array\n    node = node[key] || (node[key] = /^\\d+$/.test(nextKey) ? [] : {});\n    key = nextKey;\n    nextKey = segments[i++];\n  }\n  return fn(node, key);\n};\n\nLocalDoc.prototype._apply = function(segments, fn, cb) {\n  var out = this._createImplied(segments, fn);\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nLocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {\n  var out = this._createImplied(segments, function(node, key) {\n    var err = validate(node[key]);\n    if (err) return cb(err);\n    return fn(node, key);\n  });\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nLocalDoc.prototype._arrayApply = function(segments, fn, cb) {\n  // Lookup a pointer to the property or nested property &\n  // return the current value or create a new array\n  var arr = this._createImplied(segments, nodeCreateArray);\n\n  if (!Array.isArray(arr)) {\n    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);\n    var err = new TypeError(message);\n    return cb(err);\n  }\n  var out = fn(arr);\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nfunction nodeCreateArray(node, key) {\n  return node[key] || (node[key] = []);\n}\n","var uuid = require('uuid');\n\nModel.INITS = [];\n\nmodule.exports = Model;\n\nfunction Model(options) {\n  this.root = this;\n\n  var inits = Model.INITS;\n  options || (options = {});\n  this.debug = options.debug || {};\n  for (var i = 0; i < inits.length; i++) {\n    inits[i](this, options);\n  }\n}\n\nModel.prototype.id = function() {\n  return uuid.v4();\n};\n\nModel.prototype._child = function() {\n  return new ChildModel(this);\n};\n\nfunction ChildModel(model) {\n  // Shared properties should be accessed via the root. This makes inheritance\n  // cheap and easily extensible\n  this.root = model.root;\n\n  // EventEmitter methods access these properties directly, so they must be\n  // inherited manually instead of via the root\n  this._events = model._events;\n  this._maxListeners = model._maxListeners;\n\n  // Properties specific to a child instance\n  this._context = model._context;\n  this._at = model._at;\n  this._pass = model._pass;\n  this._silent = model._silent;\n  this._eventContext = model._eventContext;\n}\nChildModel.prototype = new Model();\n","(function (process){\nvar util = require('../util');\nvar Model = require('./Model');\nvar arrayDiff = require('arraydiff');\n\nmodule.exports = Query;\n\nModel.INITS.push(function(model) {\n  model.root._queries = new Queries();\n  if (model.root.fetchOnly) return;\n  model.on('all', function(segments) {\n    var map = model.root._queries.map;\n    for (var hash in map) {\n      var query = map[hash];\n      if (query.isPathQuery && query.shareQuery && util.mayImpact(query.expression, segments)) {\n        var ids = pathIds(model, query.expression);\n        var previousIds = model._get(query.idsSegments);\n        query._onChange(ids, previousIds);\n      }\n    }\n  });\n});\n\n/**\n * @param {String} collectionName\n * @param {Object} expression\n * @param {String} source\n * @return {Query}\n */\nModel.prototype.query = function(collectionName, expression, source) {\n  if (typeof expression.path === 'function' || typeof expression !== 'object') {\n    expression = this._splitPath(expression);\n  }\n  var query = this.root._queries.get(collectionName, expression, source);\n  if (query) return query;\n  query = new Query(this, collectionName, expression, source);\n  this.root._queries.add(query);\n  return query;\n};\n\n/**\n * Called during initialization of the bundle on page load.\n */\nModel.prototype._initQueries = function(items) {\n  var queries = this.root._queries;\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var counts = item[0];\n    var collectionName = item[1];\n    var expression = item[2];\n    var ids = item[3] || [];\n    var snapshots = item[4] || [];\n    var versions = item[5] || [];\n    var source = item[6];\n    var extra = item[7];\n    var query = new Query(this, collectionName, expression, source);\n    queries.add(query);\n\n    this._set(query.idsSegments, ids);\n\n    // This is a bit of a hack, but it should be correct. Given that queries\n    // are initialized first, the ids path is probably not set yet, but it will\n    // be used to generate the query. Therefore, we assume that the value of\n    // path will be the ids that the query results were on the server. There\n    // are probably some really odd edge cases where this doesn't work, and\n    // a more correct thing to do would be to get the actual value for the\n    // path before creating the query subscription. This feature should\n    // probably be rethought.\n    if (query.isPathQuery && expression.length > 0 && this._isLocal(expression[0])) {\n      this._setNull(expression, ids.slice());\n    }\n\n    if (extra !== void 0) {\n      this._set(query.extraSegments, extra);\n    }\n\n    for (var j = 0; j < snapshots.length; j++) {\n      var snapshot = snapshots[j];\n      if (!snapshot) continue;\n      var id = ids[j];\n      var version = versions[j];\n      var data = {data: snapshot, v: version, type: 'json0'};\n      this.getOrCreateDoc(collectionName, id, data);\n      this._loadVersions[collectionName + '.' + id] = version;\n    }\n\n    for (var j = 0; j < counts.length; j++) {\n      var count = counts[j];\n      var subscribed = count[0] || 0;\n      var fetched = count[1] || 0;\n      var contextId = count[2];\n      if (contextId) query.model.setContext(contextId);\n      while (subscribed--) {\n        query.subscribe();\n      }\n      query.fetchCount += fetched;\n      while (fetched--) {\n        query.fetchIds.push(ids);\n        query.model._context.fetchQuery(query);\n        var alreadyLoaded = true;\n        for (var k = 0; k < ids.length; k++) {\n          query.model.fetchDoc(collectionName, ids[k], null, alreadyLoaded);\n        }\n      }\n    }\n  }\n};\n\nfunction QueriesMap() {}\n\nfunction Queries() {\n  this.map = new QueriesMap();\n}\nQueries.prototype.add = function(query) {\n  this.map[query.hash] = query;\n};\nQueries.prototype.remove = function(query) {\n  delete this.map[query.hash];\n};\nQueries.prototype.get = function(collectionName, expression, source) {\n  var hash = queryHash(collectionName, expression, source);\n  return this.map[hash];\n};\nQueries.prototype.toJSON = function() {\n  var out = [];\n  for (var hash in this.map) {\n    var query = this.map[hash];\n    if (query.subscribeCount || query.fetchCount) {\n      out.push(query.serialize());\n    }\n  }\n  return out;\n};\n\n/**\n * @private\n * @constructor\n * @param {Model} model\n * @param {Object} collectionName\n * @param {Object} expression\n * @param {String} source (e.g., 'solr')\n * @param {Number} subscribeCount\n * @param {Number} fetchCount\n * @param {Array<Array<String>>} fetchIds\n */\nfunction Query(model, collectionName, expression, source) {\n  this.model = model.pass({$query: this});\n  this.collectionName = collectionName;\n  this.expression = expression;\n  this.source = source;\n  this.hash = queryHash(collectionName, expression, source);\n  this.segments = ['$queries', this.hash];\n  this.idsSegments = ['$queries', this.hash, 'ids'];\n  this.extraSegments = ['$queries', this.hash, 'extra'];\n  this.isPathQuery = Array.isArray(expression);\n\n  this._pendingSubscribeCallbacks = [];\n\n  // These are used to help cleanup appropriately when calling unsubscribe and\n  // unfetch. A query won't be fully cleaned up until unfetch and unsubscribe\n  // are called the same number of times that fetch and subscribe were called.\n  this.subscribeCount = 0;\n  this.fetchCount = 0;\n  // The list of ids at the time of each fetch is pushed onto fetchIds, so\n  // that unfetchDoc can be called the same number of times as fetchDoc\n  this.fetchIds = [];\n\n  this.created = false;\n  this.shareQuery = null;\n}\n\nQuery.prototype.create = function() {\n  this.created = true;\n  this.model.root._queries.add(this);\n};\n\nQuery.prototype.destroy = function() {\n  this.created = false;\n  if (this.shareQuery) {\n    this.shareQuery.destroy();\n    this.shareQuery = null;\n  }\n  this.model.root._queries.remove(this);\n  this.model._del(this.segments);\n};\n\nQuery.prototype.sourceQuery = function() {\n  if (this.isPathQuery) {\n    var ids = pathIds(this.model, this.expression);\n    return {_id: {$in: ids}};\n  }\n  return this.expression;\n};\n\n/**\n * @param {Function} [cb] cb(err)\n */\nQuery.prototype.fetch = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.fetchQuery(this);\n\n  this.fetchCount++;\n\n  if (!this.created) this.create();\n  var query = this;\n\n  var model = this.model;\n  var shareDocs = collectionShareDocs(this.model, this.collectionName);\n  var options = {docMode: 'fetch', knownDocs: shareDocs};\n  if (this.source) options.source = this.source;\n\n  model.root.shareConnection.createFetchQuery(\n    this.collectionName, this.sourceQuery(), options, fetchQueryCallback\n  );\n  function fetchQueryCallback(err, results, extra) {\n    if (err) return cb(err);\n    var ids = resultsIds(results);\n\n    // Keep track of the ids at fetch time for use in unfetch\n    query.fetchIds.push(ids.slice());\n    // Update the results ids and extra\n    model._setArrayDiff(query.idsSegments, ids);\n    if (extra !== void 0) {\n      model._setDiffDeep(query.extraSegments, extra);\n    }\n\n    // Call fetchDoc for each document returned so that the proper load events\n    // and internal counts are maintained. However, specify that we already\n    // loaded the documents as part of the query, since we don't want to\n    // actually fetch the documents again\n    var alreadyLoaded = true;\n    for (var i = 0; i < ids.length; i++) {\n      model.fetchDoc(query.collectionName, ids[i], null, alreadyLoaded);\n    }\n    cb();\n  }\n  return this;\n};\n\n/**\n * Sets up a subscription to `this` query.\n * @param {Function} cb(err)\n */\nQuery.prototype.subscribe = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.subscribeQuery(this);\n\n  var query = this;\n\n  if (this.subscribeCount++) {\n    process.nextTick(function() {\n      var data = query.model._get(query.segments);\n      if (data) {\n        cb();\n      } else {\n        query._pendingSubscribeCallbacks.push(cb);\n      }\n    });\n    return this;\n  }\n\n  if (!this.created) this.create();\n\n  // When doing server-side rendering, we actually do a fetch the first time\n  // that subscribe is called, but keep track of the state as if subscribe\n  // were called for proper initialization in the client\n  var shareDocs = collectionShareDocs(this.model, this.collectionName);\n  var options = {docMode: 'sub', knownDocs: shareDocs};\n  if (this.source) options.source = this.source;\n\n  if (!this.model.root.fetchOnly) {\n    this._shareSubscribe(options, cb);\n    return this;\n  }\n\n  var model = this.model;\n  options.docMode = 'fetch';\n  model.root.shareConnection.createFetchQuery(\n    this.collectionName, this.sourceQuery(), options, function(err, results, extra) {\n      if (err) {\n        cb(err);\n        query._flushPendingCallbacks(err);\n        return;\n      }\n      var ids = resultsIds(results);\n      if (extra !== void 0) {\n        model._setDiffDeep(query.extraSegments, extra);\n      }\n      query._onChange(ids, null, function(err) {\n        cb(err);\n        query._flushPendingCallbacks(err);\n      });\n    }\n  );\n  return this;\n};\n\n/**\n * @private\n * @param {Object} options\n * @param {String} [options.source]\n * @param {Boolean} [options.poll]\n * @param {Boolean} [options.docMode = fetch or subscribe]\n * @param {Function} cb(err, results)\n */\nQuery.prototype._shareSubscribe = function(options, cb) {\n  var query = this;\n  var model = this.model;\n  this.shareQuery = this.model.root.shareConnection.createSubscribeQuery(\n    this.collectionName, this.sourceQuery(), options, function(err, results, extra) {\n      if (err) {\n        cb(err);\n        query._flushPendingCallbacks();\n        return;\n      }\n      if (extra !== void 0) {\n        model._setDiffDeep(query.extraSegments, extra);\n      }\n      // Results are not set in the callback, because the shareQuery should\n      // emit a 'change' event before calling back\n      cb();\n      query._flushPendingCallbacks();\n    }\n  );\n  var query = this;\n  this.shareQuery.on('insert', function(shareDocs, index) {\n    query._onInsert(shareDocs, index);\n  });\n  this.shareQuery.on('remove', function(shareDocs, index) {\n    query._onRemove(shareDocs, index);\n  });\n  this.shareQuery.on('move', function(shareDocs, from, to) {\n    query._onMove(shareDocs, from, to);\n  });\n  this.shareQuery.on('change', function(results, previous) {\n    // Get the new and previous list of ids when the entire results set changes\n    var ids = resultsIds(results);\n    var previousIds = previous && resultsIds(previous);\n    query._onChange(ids, previousIds);\n  });\n  this.shareQuery.on('extra', function(extra) {\n    model._setDiffDeep(query.extraSegments, extra);\n  });\n};\n\n/**\n * Flushes `_pendingSubscribeCallbacks`, calling each callback in the array,\n * with an optional error to pass into each. `_pendingSubscribeCallbacks` will\n * be empty after this runs.\n * @private\n */\nQuery.prototype._flushPendingCallbacks = function(err) {\n  var pendingCallback;\n  while (pendingCallback = this._pendingSubscribeCallbacks.shift()) {\n    pendingCallback(err);\n  }\n};\n\n/**\n * @public\n * @param {Function} cb(err, newFetchCount)\n */\nQuery.prototype.unfetch = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.unfetchQuery(this);\n\n  // No effect if the query is not currently fetched\n  if (!this.fetchCount) {\n    cb();\n    return this;\n  }\n\n  var ids = this.fetchIds.shift() || [];\n  for (var i = 0; i < ids.length; i++) {\n    this.model.unfetchDoc(this.collectionName, ids[i]);\n  }\n\n  var query = this;\n  if (this.model.root.unloadDelay) {\n    setTimeout(finishUnfetchQuery, this.model.root.unloadDelay);\n  } else {\n    finishUnfetchQuery();\n  }\n  function finishUnfetchQuery() {\n    var count = --query.fetchCount;\n    if (count) return cb(null, count);\n    // Cleanup when no fetches or subscribes remain\n    if (!query.subscribeCount) query.destroy();\n    cb(null, 0);\n  }\n  return this;\n};\n\nQuery.prototype.unsubscribe = function(cb) {\n  cb = this.model.wrapCallback(cb);\n  this.model._context.unsubscribeQuery(this);\n\n  // No effect if the query is not currently subscribed\n  if (!this.subscribeCount) {\n    cb();\n    return this;\n  }\n\n  var query = this;\n  if (this.model.root.unloadDelay) {\n    setTimeout(finishUnsubscribeQuery, this.model.root.unloadDelay);\n  } else {\n    finishUnsubscribeQuery();\n  }\n  function finishUnsubscribeQuery() {\n    var count = --query.subscribeCount;\n    if (count) return cb(null, count);\n\n    var ids;\n    if (query.shareQuery) {\n      ids = resultsIds(query.shareQuery.results);\n      query.shareQuery.destroy();\n      query.shareQuery = null;\n    }\n\n    if (!query.model.root.fetchOnly && ids && ids.length) {\n      // Unsubscribe all documents that this query currently has in results\n      var group = util.asyncGroup(unsubscribeQueryCallback);\n      for (var i = 0; i < ids.length; i++) {\n        query.model.unsubscribeDoc(query.collectionName, ids[i], group());\n      }\n    }\n    unsubscribeQueryCallback();\n  }\n  function unsubscribeQueryCallback(err) {\n    if (err) return cb(err);\n    // Cleanup when no fetches or subscribes remain\n    if (!query.fetchCount) query.destroy();\n    cb(null, 0);\n  }\n  return this;\n};\n\nQuery.prototype._onInsert = function(shareDocs, index) {\n  var ids = [];\n  for (var i = 0; i < shareDocs.length; i++) {\n    var id = shareDocs[i].name;\n    ids.push(id);\n    this.model.subscribeDoc(this.collectionName, id);\n  }\n  this.model._insert(this.idsSegments, index, ids);\n};\nQuery.prototype._onRemove = function(shareDocs, index) {\n  this.model._remove(this.idsSegments, index, shareDocs.length);\n  for (var i = 0; i < shareDocs.length; i++) {\n    this.model.unsubscribeDoc(this.collectionName, shareDocs[i].name);\n  }\n};\nQuery.prototype._onMove = function(shareDocs, from, to) {\n  this.model._move(this.idsSegments, from, to, shareDocs.length);\n};\n\nQuery.prototype._onChange = function(ids, previousIds, cb) {\n  // Diff the new and previous list of ids, subscribing to documents for\n  // inserted ids and unsubscribing from documents for removed ids\n  var diff = (previousIds) ?\n    arrayDiff(previousIds, ids) :\n    [new arrayDiff.InsertDiff(0, ids)];\n  var previousCopy = previousIds && previousIds.slice();\n\n  // The results are updated via a different diff, since they might already\n  // have a value from a fetch or previous shareQuery instance\n  this.model._setArrayDiff(this.idsSegments, ids);\n\n  var group, finished;\n  if (cb) {\n    group = util.asyncGroup(cb);\n    finished = group();\n  }\n  for (var i = 0; i < diff.length; i++) {\n    var item = diff[i];\n    if (item instanceof arrayDiff.InsertDiff) {\n      // Subscribe to the document for each inserted id\n      var values = item.values;\n      for (var j = 0; j < values.length; j++) {\n        this.model.subscribeDoc(this.collectionName, values[j], cb && group());\n      }\n    } else if (item instanceof arrayDiff.RemoveDiff) {\n      var values = previousCopy.splice(item.index, item.howMany);\n      // Unsubscribe from the document for each removed id\n      for (var j = 0; j < values.length; j++) {\n        this.model.unsubscribeDoc(this.collectionName, values[j], cb && group());\n      }\n    }\n    // Moving doesn't change document subscriptions, so that is ignored.\n  }\n  // Make sure that the callback gets called if the diff is empty or it\n  // contains no inserts or removes\n  finished && finished();\n};\n\nQuery.prototype.get = function() {\n  var results = [];\n  var data = this.model._get(this.segments);\n  if (!data) {\n    console.warn('You must fetch or subscribe to a query before getting its results.');\n    return results;\n  }\n  var ids = data.ids;\n  if (!ids) return results;\n\n  var collection = this.model.getCollection(this.collectionName);\n  for (var i = 0, l = ids.length; i < l; i++) {\n    var id = ids[i];\n    var doc = collection && collection.docs[id];\n    results.push(doc && doc.get());\n  }\n  return results;\n};\n\nQuery.prototype.getIds = function() {\n  return this.model._get(this.idsSegments);\n};\n\nQuery.prototype.getExtra = function() {\n  return this.model._get(this.extraSegments);\n};\n\nQuery.prototype.ref = function(from) {\n  var idsPath = this.idsSegments.join('.');\n  return this.model.refList(from, this.collectionName, idsPath);\n};\n\nQuery.prototype.refIds = function(from) {\n  var idsPath = this.idsSegments.join('.');\n  return this.model.root.ref(from, idsPath);\n};\n\nQuery.prototype.refExtra = function(from, relPath) {\n  var extraPath = this.extraSegments.join('.');\n  if (relPath) extraPath += '.' + relPath;\n  return this.model.root.ref(from, extraPath);\n};\n\nQuery.prototype.serialize = function() {\n  var ids = this.getIds();\n  var collection = this.model.getCollection(this.collectionName);\n  var snapshots, versions;\n  if (collection) {\n    snapshots = [];\n    versions = [];\n    for (var i = 0; i < ids.length; i++) {\n      var id = ids[i];\n      var doc = collection.docs[id];\n      if (doc) {\n        snapshots.push(doc.shareDoc.snapshot);\n        versions.push(doc.shareDoc.version);\n        collection.remove(id);\n      } else {\n        snapshots.push(0);\n        versions.push(0);\n      }\n    }\n  }\n  var counts = [];\n  var contexts = this.model.root._contexts;\n  for (var key in contexts) {\n    var context = contexts[key];\n    var subscribed = context.subscribedQueries[this.hash] || 0;\n    var fetched = context.fetchedQueries[this.hash] || 0;\n    if (subscribed || fetched) {\n      if (key !== 'root') {\n        counts.push([subscribed, fetched, key]);\n      } else if (fetched) {\n        counts.push([subscribed, fetched]);\n      } else {\n        counts.push([subscribed]);\n      }\n    }\n  }\n  var serialized = [\n    counts\n  , this.collectionName\n  , this.expression\n  , ids\n  , snapshots\n  , versions\n  , this.source\n  , this.getExtra()\n  ];\n  while (serialized[serialized.length - 1] == null) {\n    serialized.pop();\n  }\n  return serialized;\n};\n\nfunction queryHash(collectionName, expression, source) {\n  var args = [collectionName, expression, source];\n  return JSON.stringify(args).replace(/\\./g, '|');\n}\n\nfunction resultsIds(results) {\n  var ids = [];\n  for (var i = 0; i < results.length; i++) {\n    var shareDoc = results[i];\n    ids.push(shareDoc.name);\n  }\n  return ids;\n}\n\nfunction pathIds(model, segments) {\n  var value = model._get(segments);\n  return (typeof value === 'string') ? [value] :\n    (Array.isArray(value)) ? value.slice() : [];\n}\n\nfunction collectionShareDocs(model, collectionName) {\n  var collection = model.getCollection(collectionName);\n  if (!collection) return;\n\n  var results = [];\n  for (var name in collection.docs) {\n    results.push(collection.docs[name].shareDoc);\n  }\n\n  return results;\n}\n\n}).call(this,require(\"g5I+bs\"))","/**\n * RemoteDoc adapts the ShareJS operation protocol to Racer's mutator\n * interface.\n *\n * 1. It maps Racer's mutator methods to outgoing ShareJS operations.\n * 2. It maps incoming ShareJS operations to Racer events.\n */\n\nvar Doc = require('./Doc');\nvar util = require('../util');\n\nmodule.exports = RemoteDoc;\n\nfunction RemoteDoc(model, collectionName, id, data) {\n  Doc.call(this, model, collectionName, id);\n  var shareDoc = this.shareDoc = model._getOrCreateShareDoc(collectionName, id, data);\n  if (model.root.debug.disableSubmit) {\n    shareDoc.submitOp = function() {};\n  }\n  this.debugMutations = model.root.debug.remoteMutations;\n  this.createdLocally = false;\n  this.model = model = model.pass({$remote: true});\n  this._updateCollectionData();\n\n  var doc = this;\n  shareDoc.on('op', function(op, isLocal) {\n    // Don't emit on local operations, since they are emitted in the mutator\n    if (isLocal) return;\n    doc._updateCollectionData();\n    doc._onOp(op);\n  });\n  shareDoc.on('del', function(isLocal, previous) {\n    // Calling the shareDoc.del method does not emit an operation event,\n    // so we create the appropriate event here.\n    if (isLocal) return;\n    delete doc.collectionData[id];\n    model.emit('change', [collectionName, id], [void 0, previous, model._pass]);\n  });\n  shareDoc.on('create', function(isLocal) {\n    // Local creates should not emit an event, since they only happen\n    // implicitly as a result of another mutation, and that operation will\n    // emit the appropriate event. Remote creates can set the snapshot data\n    // without emitting an operation event, so an event needs to be emitted\n    // for them.\n    if (isLocal) {\n      // Track when a document was created by this client, so that we don't\n      // emit a load event when subsequently subscribed\n      doc.createdLocally = true;\n      return;\n    }\n    doc._updateCollectionData();\n    var value = shareDoc.snapshot;\n    model.emit('change', [collectionName, id], [value, void 0, model._pass]);\n  });\n}\n\nRemoteDoc.prototype = new Doc();\n\nRemoteDoc.prototype._updateCollectionData = function() {\n  var snapshot = this.shareDoc.snapshot;\n  if (typeof snapshot === 'object' && !Array.isArray(snapshot) && snapshot !== null) {\n    snapshot.id = this.id;\n  }\n  this.collectionData[this.id] = snapshot;\n};\n\nRemoteDoc.prototype.set = function(segments, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc set', this.path(segments), value);\n  }\n  if (segments.length === 0 && !this.shareDoc.type) {\n    // We copy the snapshot at time of create to prevent the id added outside\n    // of ShareJS from getting stored in the data\n    var snapshot = util.copy(value);\n    if (snapshot) delete snapshot.id;\n    this.shareDoc.create('json0', snapshot, cb);\n    // The id value will get added to the snapshot that was passed in\n    this.shareDoc.snapshot = value;\n    this._updateCollectionData();\n    return;\n  }\n  var previous = this._createImplied(segments);\n  var lastSegment = segments[segments.length - 1];\n  if (previous instanceof ImpliedOp) {\n    previous.value[lastSegment] = value;\n    this.shareDoc.submitOp(previous.op, cb);\n    this._updateCollectionData();\n    return;\n  }\n  var op = (util.isArrayIndex(lastSegment)) ?\n    [new ListReplaceOp(segments.slice(0, -1), lastSegment, previous, value)] :\n    [new ObjectReplaceOp(segments, previous, value)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.del = function(segments, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc del', this.path(segments));\n  }\n  if (segments.length === 0) {\n    var previous = this.get();\n    this.shareDoc.del(cb);\n    delete this.collectionData[this.id];\n    return previous;\n  }\n  // Don't do anything if the value is already undefined, since\n  // the del method should not create anything\n  var previous = this.get(segments);\n  if (previous === void 0) {\n    cb();\n    return;\n  }\n  var op = [new ObjectDeleteOp(segments, previous)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.increment = function(segments, byNumber, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc increment', this.path(segments), byNumber);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) {\n    var lastSegment = segments[segments.length - 1];\n    previous.value[lastSegment] = byNumber;\n    this.shareDoc.submitOp(previous.op, cb);\n    this._updateCollectionData();\n    return byNumber;\n  }\n  if (previous == null) {\n    var lastSegment = segments[segments.length - 1];\n    var op = (util.isArrayIndex(lastSegment)) ?\n      [new ListInsertOp(segments.slice(0, -1), lastSegment, byNumber)] :\n      [new ObjectInsertOp(segments, byNumber)];\n    this.shareDoc.submitOp(op, cb);\n    this._updateCollectionData();\n    return byNumber;\n  }\n  var op = [new IncrementOp(segments, byNumber)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous + byNumber;\n};\n\nRemoteDoc.prototype.push = function(segments, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc push', this.path(segments), value);\n  }\n  var shareDoc = this.shareDoc;\n  function push(arr, fnCb) {\n    var op = [new ListInsertOp(segments, arr.length, value)];\n    shareDoc.submitOp(op, fnCb);\n    return arr.length;\n  }\n  return this._arrayApply(segments, push, cb);\n};\n\nRemoteDoc.prototype.unshift = function(segments, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc unshift', this.path(segments), value);\n  }\n  var shareDoc = this.shareDoc;\n  function unshift(arr, fnCb) {\n    var op = [new ListInsertOp(segments, 0, value)];\n    shareDoc.submitOp(op, fnCb);\n    return arr.length;\n  }\n  return this._arrayApply(segments, unshift, cb);\n};\n\nRemoteDoc.prototype.insert = function(segments, index, values, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc insert', this.path(segments), index, values);\n  }\n  var shareDoc = this.shareDoc;\n  function insert(arr, fnCb) {\n    var op = createInsertOp(segments, index, values);\n    shareDoc.submitOp(op, fnCb);\n    return arr.length;\n  }\n  return this._arrayApply(segments, insert, cb);\n};\n\nfunction createInsertOp(segments, index, values) {\n  if (!Array.isArray(values)) {\n    return [new ListInsertOp(segments, index, values)];\n  }\n  var op = [];\n  for (var i = 0, len = values.length; i < len; i++) {\n    op.push(new ListInsertOp(segments, index++, values[i]));\n  }\n  return op;\n}\n\nRemoteDoc.prototype.pop = function(segments, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc pop', this.path(segments));\n  }\n  var shareDoc = this.shareDoc;\n  function pop(arr, fnCb) {\n    var index = arr.length - 1;\n    var value = arr[index];\n    var op = [new ListRemoveOp(segments, index, value)];\n    shareDoc.submitOp(op, fnCb);\n    return value;\n  }\n  return this._arrayApply(segments, pop, cb);\n};\n\nRemoteDoc.prototype.shift = function(segments, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc shift', this.path(segments));\n  }\n  var shareDoc = this.shareDoc;\n  function shift(arr, fnCb) {\n    var value = arr[0];\n    var op = [new ListRemoveOp(segments, 0, value)];\n    shareDoc.submitOp(op, fnCb);\n    return value;\n  }\n  return this._arrayApply(segments, shift, cb);\n};\n\nRemoteDoc.prototype.remove = function(segments, index, howMany, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc remove', this.path(segments), index, howMany);\n  }\n  var shareDoc = this.shareDoc;\n  function remove(arr, fnCb) {\n    var values = arr.slice(index, index + howMany);\n    var op = [];\n    for (var i = 0, len = values.length; i < len; i++) {\n      op.push(new ListRemoveOp(segments, index, values[i]));\n    }\n    shareDoc.submitOp(op, fnCb);\n    return values;\n  }\n  return this._arrayApply(segments, remove, cb);\n};\n\nRemoteDoc.prototype.move = function(segments, from, to, howMany, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc move', this.path(segments), from, to, howMany);\n  }\n  var shareDoc = this.shareDoc;\n  function move(arr, fnCb) {\n    // Get the return value\n    var values = arr.slice(from, from + howMany);\n\n    // Build an op that moves each item individually\n    var op = [];\n    for (var i = 0; i < howMany; i++) {\n      op.push(new ListMoveOp(segments, (from < to) ? from : from + howMany - 1, (from < to) ? to + howMany - 1 : to));\n    }\n    shareDoc.submitOp(op, fnCb);\n\n    return values;\n  }\n  return this._arrayApply(segments, move, cb);\n};\n\nRemoteDoc.prototype.stringInsert = function(segments, index, value, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc stringInsert', this.path(segments), index, value);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) {\n    var lastSegment = segments[segments.length - 1];\n    previous.value[lastSegment] = value;\n    this.shareDoc.submitOp(previous.op, cb);\n    this._updateCollectionData();\n    return;\n  }\n  if (previous == null) {\n    var lastSegment = segments[segments.length - 1];\n    var op = (util.isArrayIndex(lastSegment)) ?\n      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :\n      [new ObjectInsertOp(segments, value)];\n    this.shareDoc.submitOp(op, cb);\n    this._updateCollectionData();\n    return previous;\n  }\n  var op = [new StringInsertOp(segments, index, value)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.stringRemove = function(segments, index, howMany, cb) {\n  if (this.debugMutations) {\n    console.log('RemoteDoc stringRemove', this.path(segments), index, howMany);\n  }\n  var previous = this._createImplied(segments);\n  if (previous instanceof ImpliedOp) return;\n  if (previous == null) return previous;\n  var removed = previous.slice(index, index + howMany);\n  var op = [new StringRemoveOp(segments, index, removed)];\n  this.shareDoc.submitOp(op, cb);\n  this._updateCollectionData();\n  return previous;\n};\n\nRemoteDoc.prototype.get = function(segments) {\n  return util.lookup(segments, this.shareDoc.snapshot);\n};\n\nRemoteDoc.prototype._createImplied = function(segments) {\n  if (!this.shareDoc.type) {\n    this.shareDoc.create('json0');\n  }\n  var parent = this.shareDoc;\n  var key = 'snapshot';\n  var node = parent[key];\n  var i = 0;\n  var nextKey = segments[i++];\n  var op, value;\n  while (nextKey != null) {\n    if (!node) {\n      if (op) {\n        value = value[key] = util.isArrayIndex(nextKey) ? [] : {};\n      } else {\n        value = util.isArrayIndex(nextKey) ? [] : {};\n        op = (Array.isArray(parent)) ?\n          new ListInsertOp(segments.slice(0, i - 2), key, value) :\n          new ObjectInsertOp(segments.slice(0, i - 1), value);\n      }\n      node = value;\n    }\n    parent = node;\n    key = nextKey;\n    node = parent[key];\n    nextKey = segments[i++];\n  }\n  if (op) return new ImpliedOp(op, value);\n  return node;\n};\n\nfunction ImpliedOp(op, value) {\n  this.op = op;\n  this.value = value;\n}\n\nRemoteDoc.prototype._arrayApply = function(segments, fn, cb) {\n  var arr = this._createImplied(segments);\n  if (arr instanceof ImpliedOp) {\n    this.shareDoc.submitOp(arr.op);\n    arr = this.get(segments);\n  }\n  if (arr == null) {\n    var lastSegment = segments[segments.length - 1];\n    var op = (util.isArrayIndex(lastSegment)) ?\n      [new ListInsertOp(segments.slice(0, -1), lastSegment, [])] :\n      [new ObjectInsertOp(segments, [])];\n    this.shareDoc.submitOp(op);\n    arr = this.get(segments);\n  }\n\n  if (!Array.isArray(arr)) {\n    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);\n    var err = new TypeError(message);\n    return cb(err);\n  }\n  var out = fn(arr, cb);\n  this._updateCollectionData();\n  return out;\n};\n\nRemoteDoc.prototype._onOp = function(op) {\n  var item = op[0];\n  var segments = [this.collectionName, this.id].concat(item.p);\n  var model = this.model;\n\n  // ObjectReplaceOp, ObjectInsertOp, or ObjectDeleteOp\n  if (defined(item.oi) || defined(item.od)) {\n    var value = item.oi;\n    var previous = item.od;\n    model.emit('change', segments, [value, previous, model._pass]);\n\n  // ListReplaceOp\n  } else if (defined(item.li) && defined(item.ld)) {\n    var value = item.li;\n    var previous = item.ld;\n    model.emit('change', segments, [value, previous, model._pass]);\n\n  // ListInsertOp\n  } else if (defined(item.li)) {\n    var index = segments[segments.length - 1];\n    var values = [item.li];\n    model.emit('insert', segments.slice(0, -1), [index, values, model._pass]);\n\n  // ListRemoveOp\n  } else if (defined(item.ld)) {\n    var index = segments[segments.length - 1];\n    var removed = [item.ld];\n    model.emit('remove', segments.slice(0, -1), [index, removed, model._pass]);\n\n  // ListMoveOp\n  } else if (defined(item.lm)) {\n    var from = segments[segments.length - 1];\n    var to = item.lm;\n    var howMany = 1;\n    model.emit('move', segments.slice(0, -1), [from, to, howMany, model._pass]);\n\n  // StringInsertOp\n  } else if (defined(item.si)) {\n    var index = segments[segments.length - 1];\n    var text = item.si;\n    segments = segments.slice(0, -1);\n    var value = model._get(segments);\n    var previous = value.slice(0, index) + value.slice(index + text.length);\n    var pass = model.pass({$stringInsert: {index: index, text: text}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n\n  // StringRemoveOp\n  } else if (defined(item.sd)) {\n    var index = segments[segments.length - 1];\n    var text = item.sd;\n    var howMany = text.length;\n    segments = segments.slice(0, -1);\n    var value = model._get(segments);\n    var previous = value.slice(0, index) + text + value.slice(index);\n    var pass = model.pass({$stringRemove: {index: index, howMany: howMany}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n\n  // IncrementOp\n  } else if (defined(item.na)) {\n    var value = this.get(item.p);\n    var previous = value - item.na;\n    model.emit('change', segments, [value, previous, model._pass]);\n  }\n};\n\nfunction ObjectReplaceOp(segments, before, after) {\n  this.p = util.castSegments(segments);\n  this.od = before;\n  this.oi = (after === void 0) ? null : after;\n}\nfunction ObjectInsertOp(segments, value) {\n  this.p = util.castSegments(segments);\n  this.oi = (value === void 0) ? null : value;\n}\nfunction ObjectDeleteOp(segments, value) {\n  this.p = util.castSegments(segments);\n  this.od = (value === void 0) ? null : value;\n}\nfunction ListReplaceOp(segments, index, before, after) {\n  this.p = util.castSegments(segments.concat(index));\n  this.ld = before;\n  this.li = (after === void 0) ? null : after;\n}\nfunction ListInsertOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.li = (value === void 0) ? null : value;\n}\nfunction ListRemoveOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.ld = (value === void 0) ? null : value;\n}\nfunction ListMoveOp(segments, from, to) {\n  this.p = util.castSegments(segments.concat(from));\n  this.lm = to;\n}\nfunction StringInsertOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.si = value;\n}\nfunction StringRemoveOp(segments, index, value) {\n  this.p = util.castSegments(segments.concat(index));\n  this.sd = value;\n}\nfunction IncrementOp(segments, byNumber) {\n  this.p = util.castSegments(segments);\n  this.na = byNumber;\n}\n\nfunction defined(value) {\n  return value !== void 0;\n}\n","var Model = require('./Model');\nvar LocalDoc = require('./LocalDoc');\nvar util = require('../util');\n\nfunction CollectionMap() {}\nfunction ModelData() {}\nfunction DocMap() {}\nfunction CollectionData() {}\n\nModel.INITS.push(function(model) {\n  model.root.collections = new CollectionMap();\n  model.root.data = new ModelData();\n});\n\nModel.prototype.getCollection = function(collectionName) {\n  return this.root.collections[collectionName];\n};\nModel.prototype.getDoc = function(collectionName, id) {\n  var collection = this.root.collections[collectionName];\n  return collection && collection.docs[id];\n};\nModel.prototype.get = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._get(segments);\n};\nModel.prototype._get = function(segments) {\n  return util.lookup(segments, this.root.data);\n};\nModel.prototype.getCopy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._getCopy(segments);\n};\nModel.prototype._getCopy = function(segments) {\n  var value = this._get(segments);\n  return util.copy(value);\n};\nModel.prototype.getDeepCopy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._getDeepCopy(segments);\n};\nModel.prototype._getDeepCopy = function(segments) {\n  var value = this._get(segments);\n  return util.deepCopy(value);\n};\nModel.prototype.getOrCreateCollection = function(name) {\n  var collection = this.root.collections[name];\n  if (collection) return collection;\n  var Doc = this._getDocConstructor(name);\n  collection = new Collection(this.root, name, Doc);\n  this.root.collections[name] = collection;\n  return collection;\n};\nModel.prototype._getDocConstructor = function() {\n  // Only create local documents. This is overriden in ./connection.js, so that\n  // the RemoteDoc behavior can be selectively included\n  return LocalDoc;\n};\n\n/**\n * Returns an existing document with id in a collection. If the document does\n * not exist, then creates the document with id in a collection and returns the\n * new document.\n * @param {String} collectionName\n * @param {String} id\n * @param {Object} [data] data to create if doc with id does not exist in collection\n */\nModel.prototype.getOrCreateDoc = function(collectionName, id, data) {\n  var collection = this.getOrCreateCollection(collectionName);\n  return collection.docs[id] || collection.add(id, data);\n};\n\n/**\n * @param {String} subpath\n */\nModel.prototype.destroy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  // Silently remove all types of listeners within subpath\n  var silentModel = this.silent();\n  silentModel.removeAllListeners(null, subpath);\n  silentModel._removeAllRefs(segments);\n  silentModel._stopAll(segments);\n  silentModel._removeAllFilters(segments);\n  // Silently remove all model data within subpath\n  if (segments.length === 0) {\n    this.root.collections = new CollectionMap();\n    // Delete each property of data instead of creating a new object so that\n    // it is possible to continue using a reference to the original data object\n    var data = this.root.data;\n    for (var key in data) {\n      delete data[key];\n    }\n  } else if (segments.length === 1) {\n    var collection = this.getCollection(segments[0]);\n    collection && collection.destroy();\n  } else {\n    silentModel._del(segments);\n  }\n};\n\nfunction Collection(model, name, Doc) {\n  this.model = model;\n  this.name = name;\n  this.Doc = Doc;\n  this.docs = new DocMap();\n  this.data = model.data[name] = new CollectionData();\n}\n\n/**\n * Adds a document with `id` and `data` to `this` Collection.\n * @param {String} id\n * @param {Object} data\n * @return {LocalDoc|RemoteDoc} doc\n */\nCollection.prototype.add = function(id, data) {\n  var doc = new this.Doc(this.model, this.name, id, data);\n  this.docs[id] = doc;\n  return doc;\n};\nCollection.prototype.destroy = function() {\n  delete this.model.collections[this.name];\n  delete this.model.data[this.name];\n};\n\n/**\n * Removes the document with `id` from `this` Collection. If there are no more\n * documents in the Collection after the given document is removed, then this\n * also destroys the Collection.\n * @param {String} id\n */\nCollection.prototype.remove = function(id) {\n  delete this.docs[id];\n  delete this.data[id];\n  if (noKeys(this.docs)) this.destroy();\n};\n\n/**\n * Returns an object that maps doc ids to fully resolved documents.\n * @return {Object}\n */\nCollection.prototype.get = function() {\n  return this.data;\n};\n\nfunction noKeys(object) {\n  for (var key in object) {\n    return false;\n  }\n  return true;\n}\n","(function (process){\nvar share = require('share/lib/client');\nvar Channel = require('../Channel');\nvar Model = require('./Model');\nvar LocalDoc = require('./LocalDoc');\nvar RemoteDoc = require('./RemoteDoc');\n\nModel.prototype.createConnection = function(bundle) {\n  // Model::_createSocket should be defined by the socket plugin\n  this.root.socket = this._createSocket(bundle);\n\n  // The Share connection will bind to the socket by defining the onopen,\n  // onmessage, etc. methods\n  var shareConnection = this.root.shareConnection = new share.Connection(this.root.socket);\n  var segments = ['$connection', 'state'];\n  var states = ['connecting', 'connected', 'disconnected', 'stopped'];\n  var model = this;\n  states.forEach(function(state) {\n    shareConnection.on(state, function() {\n      model._setDiff(segments, state);\n    });\n  });\n  this._set(segments, 'connected');\n\n  // Wrap the socket methods on top of Share's methods\n  this._createChannel();\n};\n\nModel.prototype.connect = function() {\n  this.root.socket.open();\n};\nModel.prototype.disconnect = function() {\n  this.root.socket.close();\n};\nModel.prototype.reconnect = function() {\n  this.disconnect();\n  this.connect();\n};\n// Clean delayed disconnect\nModel.prototype.close = function(cb) {\n  cb = this.wrapCallback(cb);\n  var model = this;\n  this.whenNothingPending(function() {\n    model.root.socket.close();\n    cb();\n  });\n};\n\nModel.prototype._createChannel = function() {\n  this.root.channel = new Channel(this.root.socket);\n};\n\nModel.prototype._getOrCreateShareDoc = function(collectionName, id, data) {\n  var shareDoc = this.root.shareConnection.get(collectionName, id, data);\n  shareDoc.incremental = true;\n  return shareDoc;\n};\n\nModel.prototype._isLocal = function(name) {\n  // Whether the collection is local or remote is determined by its name.\n  // Collections starting with an underscore ('_') are for user-defined local\n  // collections, those starting with a dollar sign ('$'') are for\n  // framework-defined local collections, and all others are remote.\n  var firstCharcter = name.charAt(0);\n  return firstCharcter === '_' || firstCharcter === '$';\n};\n\nModel.prototype._getDocConstructor = function(name) {\n  return (this._isLocal(name)) ? LocalDoc : RemoteDoc;\n};\n\nModel.prototype.hasPending = function() {\n  return !!this._firstShareDoc(hasPending);\n};\n\nModel.prototype.hasWritePending = function() {\n  return !!this._firstShareDoc(hasWritePending);\n};\n\nModel.prototype.whenNothingPending = function(cb) {\n  var shareDoc = this._firstShareDoc(hasPending);\n  if (shareDoc) {\n    // If a document is found with a pending operation, wait for it to emit\n    // that nothing is pending anymore, and then recheck all documents again.\n    // We have to recheck all documents, just in case another mutation has\n    // been made in the meantime as a result of an event callback\n    var model = this;\n    shareDoc.once('nothing pending', function retryNothingPending() {\n      process.nextTick(function(){\n        model.whenNothingPending(cb);\n      });\n    });\n    return;\n  }\n  // Call back when no Share documents have pending operations\n  process.nextTick(cb);\n};\n\nfunction hasPending(shareDoc) {\n  return shareDoc.hasPending();\n}\nfunction hasWritePending(shareDoc) {\n  return shareDoc.inflightData != null || !!shareDoc.pendingData.length;\n}\n\nModel.prototype._firstShareDoc = function(fn) {\n  // Loop through all of the documents on the share connection, and return the\n  // first document encountered with that matches the provided test function\n  var collections = this.root.shareConnection.collections;\n  for (var collectionName in collections) {\n    var collection = collections[collectionName];\n    for (var id in collection) {\n      var shareDoc = collection[id];\n      if (shareDoc && fn(shareDoc)) {\n        return shareDoc;\n      }\n    }\n  }\n};\n\n}).call(this,require(\"g5I+bs\"))","/**\n * Contexts are useful for keeping track of the origin of subscribes.\n */\n\nvar Model = require('./Model');\nvar Query = require('./Query');\n\nModel.INITS.push(function(model) {\n  model.root._contexts = new Contexts();\n  model.root.setContext('root');\n});\n\nModel.prototype.context = function(id) {\n  var model = this._child();\n  model.setContext(id);\n  return model;\n};\n\nModel.prototype.setContext = function(id) {\n  this._context = this.getOrCreateContext(id);\n};\n\nModel.prototype.getOrCreateContext = function(id) {\n  return this.root._contexts[id] ||\n    (this.root._contexts[id] = new Context(this, id));\n};\n\nModel.prototype.unload = function(id) {\n  var context = (id) ? this.root._contexts[id] : this._context;\n  context && context.unload();\n};\n\nModel.prototype.unloadAll = function() {\n  var contexts = this.root._contexts;\n  for (var key in contexts) {\n    contexts[key].unload();\n  }\n};\n\nfunction Contexts() {}\n\nfunction FetchedDocs() {}\nfunction SubscribedDocs() {}\nfunction FetchedQueries() {}\nfunction SubscribedQueries() {}\n\nfunction Context(model, id) {\n  this.model = model;\n  this.id = id;\n  this.fetchedDocs = new FetchedDocs();\n  this.subscribedDocs = new SubscribedDocs();\n  this.fetchedQueries = new FetchedQueries();\n  this.subscribedQueries = new SubscribedQueries();\n}\n\nContext.prototype.toJSON = function() {\n  return {\n    fetchedDocs: this.fetchedDocs\n  , subscribedDocs: this.subscribedDocs\n  };\n};\n\nContext.prototype.fetchDoc = function(path, pass) {\n  if (pass.$query) return;\n  mapIncrement(this.fetchedDocs, path);\n};\nContext.prototype.subscribeDoc = function(path, pass) {\n  if (pass.$query) return;\n  mapIncrement(this.subscribedDocs, path);\n};\nContext.prototype.unfetchDoc = function(path, pass) {\n  if (pass.$query) return;\n  mapDecrement(this.fetchedDocs, path);\n};\nContext.prototype.unsubscribeDoc = function(path, pass) {\n  if (pass.$query) return;\n  mapDecrement(this.subscribedDocs, path);\n};\nContext.prototype.fetchQuery = function(query) {\n  mapIncrement(this.fetchedQueries, query.hash);\n};\nContext.prototype.subscribeQuery = function(query) {\n  mapIncrement(this.subscribedQueries, query.hash);\n};\nContext.prototype.unfetchQuery = function(query) {\n  mapDecrement(this.fetchedQueries, query.hash);\n};\nContext.prototype.unsubscribeQuery = function(query) {\n  mapDecrement(this.subscribedQueries, query.hash);\n};\nfunction mapIncrement(map, key) {\n  map[key] = (map[key] || 0) + 1;\n}\nfunction mapDecrement(map, key) {\n  map[key] && map[key]--;\n  if (!map[key]) delete map[key];\n}\n\nContext.prototype.unload = function() {\n  var model = this.model;\n  for (var hash in this.fetchedQueries) {\n    var query = model.root._queries.map[hash];\n    if (!query) continue;\n    var count = this.fetchedQueries[hash];\n    while (count--) query.unfetch();\n  }\n  for (var hash in this.subscribedQueries) {\n    var query = model.root._queries.map[hash];\n    if (!query) continue;\n    var count = this.subscribedQueries[hash];\n    while (count--) query.unsubscribe();\n  }\n  for (var path in this.fetchedDocs) {\n    var segments = path.split('.');\n    var count = this.fetchedDocs[path];\n    while (count--) model.unfetchDoc(segments[0], segments[1]);\n  }\n  for (var path in this.subscribedDocs) {\n    var segments = path.split('.');\n    var count = this.subscribedDocs[path];\n    while (count--) model.unsubscribeDoc(segments[0], segments[1]);\n  }\n};\n","var defaultFns = module.exports = new DefaultFns();\n\ndefaultFns.reverse = new FnPair(getReverse, setReverse);\ndefaultFns.asc = asc;\ndefaultFns.desc = desc;\n\nfunction DefaultFns() {}\nfunction FnPair(get, set) {\n  this.get = get;\n  this.set = set;\n}\n\nfunction getReverse(array) {\n  return array && array.slice().reverse();\n}\nfunction setReverse(values) {\n  return {0: getReverse(values)};\n}\n\nfunction asc(a, b) {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n}\nfunction desc(a, b) {\n  if (a > b) return -1;\n  if (a < b) return 1;\n  return 0;\n}\n","var EventEmitter = require('events').EventEmitter;\nvar util = require('../util');\nvar Model = require('./Model');\n\n// This map determines which events get re-emitted as an 'all' event\nModel.MUTATOR_EVENTS = {\n  change: true\n, insert: true\n, remove: true\n, move: true\n, load: true\n, unload: true\n};\n\nModel.INITS.push(function(model) {\n  EventEmitter.call(this);\n\n  // Set max listeners to unlimited\n  model.setMaxListeners(0);\n\n  // Used in async methods to emit an error event if a callback is not supplied.\n  // This will throw if there is no handler for model.on('error')\n  model.root._defaultCallback = defaultCallback;\n  function defaultCallback(err) {\n    if (typeof err === 'string') err = new Error(err);\n    if (err) model.emit('error', err);\n  }\n\n  model.root._mutatorEventQueue = null;\n  model.root._pass = new Passed({}, {});\n  model.root._silent = null;\n  model.root._eventContext = null;\n});\n\nutil.mergeInto(Model.prototype, EventEmitter.prototype);\n\nModel.prototype.wrapCallback = function(cb) {\n  if (!cb) return this.root._defaultCallback;\n  var model = this;\n  return function wrappedCallback() {\n    try {\n      return cb.apply(this, arguments);\n    } catch (err) {\n      model.emit('error', err);\n    }\n  };\n};\n\n// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and\n// EventEmitter.prototype.once return `this`. The Model equivalents return\n// the listener instead, since it is made internally for method subscriptions\n// and may need to be passed to removeListener.\n\nModel.prototype._emit = EventEmitter.prototype.emit;\nModel.prototype.emit = function(type) {\n  if (type === 'error') {\n    return this._emit.apply(this, arguments);\n  }\n  if (Model.MUTATOR_EVENTS[type]) {\n    if (this._silent) return this;\n    var segments = arguments[1];\n    var eventArgs = arguments[2];\n    if (this.root._mutatorEventQueue) {\n      this.root._mutatorEventQueue.push([type, segments, eventArgs]);\n      return this;\n    }\n    this.root._mutatorEventQueue = [];\n    this._emit(type, segments, eventArgs);\n    this._emit('all', segments, [type].concat(eventArgs));\n    while (this.root._mutatorEventQueue.length) {\n      var queued = this.root._mutatorEventQueue.shift();\n      type = queued[0];\n      segments = queued[1];\n      eventArgs = queued[2];\n      this._emit(type, segments, eventArgs);\n      this._emit('all', segments, [type].concat(eventArgs));\n    }\n    this.root._mutatorEventQueue = null;\n    return this;\n  }\n  return this._emit.apply(this, arguments);\n};\n\nModel.prototype._on = EventEmitter.prototype.on;\nModel.prototype.addListener =\nModel.prototype.on = function(type, pattern, cb) {\n  var listener = eventListener(this, pattern, cb);\n  this._on(type, listener);\n  return listener;\n};\n\nModel.prototype.once = function(type, pattern, cb) {\n  var listener = eventListener(this, pattern, cb);\n  function g() {\n    var matches = listener.apply(null, arguments);\n    if (matches) this.removeListener(type, g);\n  }\n  this._on(type, g);\n  return g;\n};\n\nModel.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;\nModel.prototype.removeAllListeners = function(type, subpattern) {\n  // If a pattern is specified without an event type, remove all model event\n  // listeners under that pattern for all events\n  if (!type) {\n    for (var key in this._events) {\n      this.removeAllListeners(key, subpattern);\n    }\n    return this;\n  }\n\n  var pattern = this.path(subpattern);\n  // If no pattern is specified, remove all listeners like normal\n  if (!pattern) {\n    if (arguments.length === 0) {\n      return this._removeAllListeners();\n    } else {\n      return this._removeAllListeners(type);\n    }\n  }\n\n  // Remove all listeners for an event under a pattern\n  var listeners = this.listeners(type);\n  var segments = pattern.split('.');\n  // Make sure to iterate in reverse, since the array might be\n  // mutated as listeners are removed\n  for (var i = listeners.length; i--;) {\n    var listener = listeners[i];\n    if (patternContained(pattern, segments, listener)) {\n      this.removeListener(type, listener);\n    }\n  }\n  return this;\n};\n\nfunction patternContained(pattern, segments, listener) {\n  var listenerSegments = listener.patternSegments;\n  if (!listenerSegments) return false;\n  if (pattern === listener.pattern || pattern === '**') return true;\n  var len = segments.length;\n  if (len > listenerSegments.length) return false;\n  for (var i = 0; i < len; i++) {\n    if (segments[i] !== listenerSegments[i]) return false;\n  }\n  return true;\n}\n\nModel.prototype.pass = function(object, invert) {\n  var model = this._child();\n  model._pass = (invert) ?\n    new Passed(object, this._pass) :\n    new Passed(this._pass, object);\n  return model;\n};\n\nfunction Passed(previous, value) {\n  for (var key in previous) {\n    this[key] = previous[key];\n  }\n  for (var key in value) {\n    this[key] = value[key];\n  }\n}\n\n/**\n * The returned Model will or won't trigger event handlers when the model emits\n * events, depending on `value`\n * @param {Boolean|Null} value defaults to true\n * @return {Model}\n */\nModel.prototype.silent = function(value) {\n  var model = this._child();\n  model._silent = (value == null) ? true : value;\n  return model;\n};\n\nModel.prototype.eventContext = function(value) {\n  var model = this._child();\n  model._eventContext = value;\n  return model;\n};\n\nModel.prototype.removeContextListeners = function(value) {\n  if (arguments.length === 0) {\n    value = this._eventContext;\n  }\n  // Remove all events created within a given context\n  for (var type in this._events) {\n    var listeners = this.listeners(type);\n    // Make sure to iterate in reverse, since the array might be\n    // mutated as listeners are removed\n    for (var i = listeners.length; i--;) {\n      var listener = listeners[i];\n      if (listener.eventContext === value) {\n        this.removeListener(type, listener);\n      }\n    }\n  }\n  return this;\n};\n\nfunction eventListener(model, subpattern, cb) {\n  if (cb) {\n    // For signatures:\n    // model.on('change', 'example.subpath', callback)\n    // model.at('example').on('change', 'subpath', callback)\n    var pattern = model.path(subpattern);\n    return modelEventListener(pattern, cb, model._eventContext);\n  }\n  var path = model.path();\n  cb = arguments[1];\n  // For signature:\n  // model.at('example').on('change', callback)\n  if (path) return modelEventListener(path, cb, model._eventContext);\n  // For signature:\n  // model.on('normalEvent', callback)\n  return cb;\n}\n\nfunction modelEventListener(pattern, cb, eventContext) {\n  var patternSegments = util.castSegments(pattern.split('.'));\n  var testFn = testPatternFn(pattern, patternSegments);\n\n  function modelListener(segments, eventArgs) {\n    var captures = testFn(segments);\n    if (!captures) return;\n\n    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;\n    cb.apply(null, args);\n    return true;\n  }\n\n  // Used in Model#removeAllListeners\n  modelListener.pattern = pattern;\n  modelListener.patternSegments = patternSegments;\n  modelListener.eventContext = eventContext;\n\n  return modelListener;\n}\n\nfunction testPatternFn(pattern, patternSegments) {\n  if (pattern === '**') {\n    return function testPattern(segments) {\n      return [segments.join('.')];\n    };\n  }\n\n  var endingRest = stripRestWildcard(patternSegments);\n\n  return function testPattern(segments) {\n    // Any pattern with more segments does not match\n    var patternLen = patternSegments.length;\n    if (patternLen > segments.length) return;\n\n    // A pattern with the same number of segments matches if each\n    // of the segments are wildcards or equal. A shorter pattern matches\n    // if it ends in a rest wildcard and each of the corresponding\n    // segments are wildcards or equal.\n    if (patternLen === segments.length || endingRest) {\n      var captures = [];\n      for (var i = 0; i < patternLen; i++) {\n        var patternSegment = patternSegments[i];\n        var segment = segments[i];\n        if (patternSegment === '*' || patternSegment === '**') {\n          captures.push(segment);\n          continue;\n        }\n        if (patternSegment !== segment) return;\n      }\n      if (endingRest) {\n        var remainder = segments.slice(i).join('.');\n        captures.push(remainder);\n      }\n      return captures;\n    }\n  };\n}\n\nfunction stripRestWildcard(segments) {\n  // ['example', '**'] -> ['example']; return true\n  var lastIndex = segments.length - 1;\n  if (segments[lastIndex] === '**') {\n    segments.pop();\n    return true;\n  }\n  // ['example', 'subpath**'] -> ['example', 'subpath']; return true\n  var match = /^([^\\*]+)\\*\\*$/.exec(segments[lastIndex]);\n  if (!match) return false;\n  segments[lastIndex] = match[1];\n  return true;\n}\n","var util = require('../util');\nvar Model = require('./Model');\nvar defaultFns = require('./defaultFns');\n\nModel.INITS.push(function(model) {\n  model.root._filters = new Filters(model);\n  model.on('all', filterListener);\n  function filterListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    var map = model.root._filters.fromMap;\n    for (var path in map) {\n      var filter = map[path];\n      if (pass.$filter === filter) continue;\n      if (\n        util.mayImpact(filter.segments, segments) ||\n        (filter.inputsSegments && util.mayImpactAny(filter.inputsSegments, segments))\n      ) {\n        filter.update(pass);\n      }\n    }\n  }\n});\n\nfunction parseFilterArguments(model, args) {\n  var fn = args.pop();\n  var options;\n  if (!model.isPath(args[args.length - 1])) {\n    options = args.pop();\n  }\n  var path = model.path(args.shift());\n  var i = args.length;\n  while (i--) {\n    args[i] = model.path(args[i]);\n  }\n  return {\n    path: path,\n    inputPaths: (args.length) ? args : null,\n    options: options,\n    fn: fn\n  };\n}\n\nModel.prototype.filter = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseFilterArguments(this, args);\n  return this.root._filters.add(\n    parsed.path,\n    parsed.fn,\n    null,\n    parsed.inputPaths,\n    parsed.options\n  );\n};\n\nModel.prototype.sort = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseFilterArguments(this, args);\n  return this.root._filters.add(\n    parsed.path,\n    null,\n    parsed.fn || 'asc',\n    parsed.inputPaths,\n    parsed.options\n  );\n};\n\nModel.prototype.removeAllFilters = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._removeAllFilters(segments);\n};\nModel.prototype._removeAllFilters = function(segments) {\n  var filters = this.root._filters.fromMap;\n  for (var from in filters) {\n    if (util.contains(segments, filters[from].fromSegments)) {\n      filters[from].destroy();\n    }\n  }\n};\n\nfunction FromMap() {}\nfunction Filters(model) {\n  this.model = model;\n  this.fromMap = new FromMap();\n}\n\nFilters.prototype.add = function(path, filterFn, sortFn, inputPaths, options) {\n  return new Filter(this, path, filterFn, sortFn, inputPaths, options);\n};\n\nFilters.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var filter = this.fromMap[from];\n    // Don't try to bundle if functions were passed directly instead of by name\n    if (!filter.bundle) continue;\n    var args = [from, filter.path, filter.filterName, filter.sortName, filter.inputPaths];\n    if (filter.options) args.push(filter.options);\n    out.push(args);\n  }\n  return out;\n};\n\nfunction Filter(filters, path, filterFn, sortFn, inputPaths, options) {\n  this.filters = filters;\n  this.model = filters.model.pass({$filter: this});\n  this.path = path;\n  this.segments = path.split('.');\n  this.filterName = null;\n  this.sortName = null;\n  this.bundle = true;\n  this.filterFn = null;\n  this.sortFn = null;\n  this.inputPaths = inputPaths;\n  this.inputsSegments = null;\n  if (inputPaths) {\n    this.inputsSegments = [];\n    for (var i = 0; i < this.inputPaths.length; i++) {\n      var segments = this.inputPaths[i].split('.');\n      this.inputsSegments.push(segments);\n    }\n  }\n  this.options = options;\n  this.skip = options && options.skip;\n  this.limit = options && options.limit;\n  if (filterFn) this.filter(filterFn);\n  if (sortFn) this.sort(sortFn);\n  this.idsSegments = null;\n  this.from = null;\n  this.fromSegments = null;\n}\n\nFilter.prototype.filter = function(fn) {\n  if (typeof fn === 'function') {\n    this.filterFn = fn;\n    this.bundle = false;\n    return this;\n  } else if (typeof fn === 'string') {\n    this.filterName = fn;\n    this.filterFn = this.model.root._namedFns[fn] || defaultFns[fn];\n    if (!this.filterFn) {\n      throw new TypeError('Filter function not found: ' + fn);\n    }\n  }\n  return this;\n};\n\nFilter.prototype.sort = function(fn) {\n  if (!fn) fn = 'asc';\n  if (typeof fn === 'function') {\n    this.sortFn = fn;\n    this.bundle = false;\n    return this;\n  } else if (typeof fn === 'string') {\n    this.sortName = fn;\n    this.sortFn = this.model.root._namedFns[fn] || defaultFns[fn];\n    if (!this.sortFn) {\n      throw new TypeError('Sort function not found: ' + fn);\n    }\n  }\n  return this;\n};\n\nFilter.prototype._slice = function(results) {\n  if (this.skip == null && this.limit == null) return results;\n  var begin = this.skip || 0;\n  // A limit of zero is equivalent to setting no limit\n  var end;\n  if (this.limit) end = begin + this.limit;\n  return results.slice(begin, end);\n};\n\nFilter.prototype.getInputs = function() {\n  if (!this.inputsSegments) return;\n  var inputs = [];\n  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {\n    var input = this.model._get(this.inputsSegments[i]);\n    inputs.push(input);\n  }\n  return inputs;\n};\n\nFilter.prototype.callFilter = function(items, key, inputs) {\n  var item = items[key];\n  return (inputs) ?\n    this.filterFn.apply(this.model, [item, key, items].concat(inputs)) :\n    this.filterFn.call(this.model, item, key, items);\n};\n\nFilter.prototype.ids = function() {\n  var items = this.model._get(this.segments);\n  var ids = [];\n  if (!items) return ids;\n  if (Array.isArray(items)) {\n    throw new Error('model.filter is not currently supported on arrays');\n  }\n  if (this.filterFn) {\n    var inputs = this.getInputs();\n    for (var key in items) {\n      if (items.hasOwnProperty(key) && this.callFilter(items, key, inputs)) {\n        ids.push(key);\n      }\n    }\n  } else {\n    ids = Object.keys(items);\n  }\n  var sortFn = this.sortFn;\n  if (sortFn) {\n    ids.sort(function(a, b) {\n      return sortFn(items[a], items[b]);\n    });\n  }\n  return this._slice(ids);\n};\n\nFilter.prototype.get = function() {\n  var items = this.model._get(this.segments);\n  var results = [];\n  if (Array.isArray(items)) {\n    throw new Error('model.filter is not currently supported on arrays');\n  }\n  if (this.filterFn) {\n    var inputs = this.getInputs();\n    for (var key in items) {\n      if (items.hasOwnProperty(key) && this.callFilter(items, key, inputs)) {\n        results.push(items[key]);\n      }\n    }\n  } else {\n    for (var key in items) {\n      if (items.hasOwnProperty(key)) {\n        results.push(items[key]);\n      }\n    }\n  }\n  if (this.sortFn) results.sort(this.sortFn);\n  return this._slice(results);\n};\n\nFilter.prototype.update = function(pass) {\n  var ids = this.ids();\n  this.model.pass(pass, true)._setArrayDiff(this.idsSegments, ids);\n};\n\nFilter.prototype.ref = function(from) {\n  from = this.model.path(from);\n  this.from = from;\n  this.fromSegments = from.split('.');\n  this.filters.fromMap[from] = this;\n  this.idsSegments = ['$filters', from.replace(/\\./g, '|')];\n  this.update();\n  return this.model.refList(from, this.path, this.idsSegments.join('.'));\n};\n\nFilter.prototype.destroy = function() {\n  delete this.filters.fromMap[this.from];\n  this.model._removeRef(this.idsSegments);\n  this.model._del(this.idsSegments);\n};\n","var util = require('../util');\nvar Model = require('./Model');\nvar defaultFns = require('./defaultFns');\n\nfunction NamedFns() {}\n\nModel.INITS.push(function(model) {\n  model.root._namedFns = new NamedFns();\n  model.root._fns = new Fns(model);\n  model.on('all', fnListener);\n  function fnListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    var map = model.root._fns.fromMap;\n    for (var path in map) {\n      var fn = map[path];\n      if (pass.$fn === fn) continue;\n      if (util.mayImpactAny(fn.inputsSegments, segments)) {\n        // Mutation affecting input path\n        fn.onInput(pass);\n      } else if (util.mayImpact(fn.fromSegments, segments)) {\n        // Mutation affecting output path\n        fn.onOutput(pass);\n      }\n    }\n  }\n});\n\nModel.prototype.fn = function(name, fns) {\n  this.root._namedFns[name] = fns;\n};\n\nfunction parseStartArguments(model, args, hasPath) {\n  var last = args.pop();\n  var fns, name;\n  if (typeof last === 'string') {\n    name = last;\n  } else {\n    fns = last;\n  }\n  var path;\n  if (hasPath) {\n    path = model.path(args.shift());\n  }\n  var options;\n  if (!model.isPath(args[args.length - 1])) {\n    options = args.pop();\n  }\n  var i = args.length;\n  while (i--) {\n    args[i] = model.path(args[i]);\n  }\n  return {\n    name: name\n  , path: path\n  , inputPaths: args\n  , fns: fns\n  , options: options\n  };\n}\n\nModel.prototype.evaluate = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseStartArguments(this, args, false);\n  return this.root._fns.get(parsed.name, parsed.inputPaths, parsed.fns, parsed.options);\n};\n\nModel.prototype.start = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseStartArguments(this, args, true);\n  return this.root._fns.start(parsed.name, parsed.path, parsed.inputPaths, parsed.fns, parsed.options);\n};\n\nModel.prototype.stop = function(subpath) {\n  var path = this.path(subpath);\n  this._stop(path);\n};\nModel.prototype._stop = function(fromPath) {\n  this.root._fns.stop(fromPath);\n};\n\nModel.prototype.stopAll = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._stopAll(segments);\n};\nModel.prototype._stopAll = function(segments) {\n  var fns = this.root._fns.fromMap;\n  for (var from in fns) {\n    var fromSegments = fns[from].fromSegments;\n    if (util.contains(segments, fromSegments)) {\n      this._stop(from);\n    }\n  }\n};\n\nfunction FromMap() {}\nfunction Fns(model) {\n  this.model = model;\n  this.nameMap = model.root._namedFns;\n  this.fromMap = new FromMap();\n}\n\nFns.prototype.get = function(name, inputPaths, fns, options) {\n  fns || (fns = this.nameMap[name] || defaultFns[name]);\n  var fn = new Fn(this.model, name, null, inputPaths, fns, options);\n  return fn.get();\n};\n\nFns.prototype.start = function(name, path, inputPaths, fns, options) {\n  fns || (fns = this.nameMap[name] || defaultFns[name]);\n  var fn = new Fn(this.model, name, path, inputPaths, fns, options);\n  this.fromMap[path] = fn;\n  return fn.onInput();\n};\n\nFns.prototype.stop = function(path) {\n  var fn = this.fromMap[path];\n  delete this.fromMap[path];\n  return fn;\n};\n\nFns.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var fn = this.fromMap[from];\n    // Don't try to bundle non-named functions that were started via\n    // model.start directly instead of by name\n    if (!fn.name) continue;\n    var args = [fn.from].concat(fn.inputPaths);\n    if (fn.options) args.push(fn.options);\n    args.push(fn.name);\n    out.push(args);\n  }\n  return out;\n};\n\nfunction Fn(model, name, from, inputPaths, fns, options) {\n  this.model = model.pass({$fn: this});\n  this.name = name;\n  this.from = from;\n  this.inputPaths = inputPaths;\n  this.options = options;\n  if (!fns) {\n    throw new TypeError('Model function not found: ' + name);\n  }\n  this.getFn = fns.get || fns;\n  this.setFn = fns.set;\n  this.fromSegments = from && from.split('.');\n  this.inputsSegments = [];\n  for (var i = 0; i < this.inputPaths.length; i++) {\n    var segments = this.inputPaths[i].split('.');\n    this.inputsSegments.push(segments);\n  }\n\n  // Copy can be 'output', 'input', 'both', or 'none'\n  var copy = (options && options.copy) || 'output';\n  this.copyInput = (copy === 'input' || copy === 'both');\n  this.copyOutput = (copy === 'output' || copy === 'both');\n\n  // Mode can be 'diffDeep', 'diff', 'arrayDeep', or 'array'\n  this.mode = (options && options.mode) || 'diffDeep';\n}\n\nFn.prototype.apply = function(fn, inputs) {\n  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {\n    var input = this.model._get(this.inputsSegments[i]);\n    inputs.push(this.copyInput ? util.deepCopy(input) : input);\n  }\n  return fn.apply(this.model, inputs);\n};\n\nFn.prototype.get = function() {\n  return this.apply(this.getFn, []);\n};\n\nFn.prototype.set = function(value, pass) {\n  if (!this.setFn) return;\n  var out = this.apply(this.setFn, [value]);\n  if (!out) return;\n  var inputsSegments = this.inputsSegments;\n  var model = this.model.pass(pass, true);\n  for (var key in out) {\n    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];\n    this._setValue(model, inputsSegments[key], value);\n  }\n};\n\nFn.prototype.onInput = function(pass) {\n  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();\n  this._setValue(this.model.pass(pass, true), this.fromSegments, value);\n  return value;\n};\n\nFn.prototype.onOutput = function(pass) {\n  var value = this.model._get(this.fromSegments);\n  return this.set(value, pass);\n};\n\nFn.prototype._setValue = function(model, segments, value) {\n  if (this.mode === 'diffDeep') {\n    model._setDiffDeep(segments, value);\n  } else if (this.mode === 'arrayDeep') {\n    model._setArrayDiffDeep(segments, value);\n  } else if (this.mode === 'array') {\n    model._setArrayDiff(segments, value);\n  } else {\n    model._setDiff(segments, value);\n  }\n};\n","module.exports = require('./Model');\nvar util = require('../util');\n\n// Extend model on both server and client //\nrequire('./unbundle');\nrequire('./events');\nrequire('./paths');\nrequire('./collections');\nrequire('./mutators');\nrequire('./setDiff');\n\nrequire('./connection');\nrequire('./subscriptions');\nrequire('./Query');\nrequire('./contexts');\n\nrequire('./fn');\nrequire('./filter');\nrequire('./refList');\nrequire('./ref');\n\n// Extend model for server //\nutil.serverRequire(module, './bundle');\nutil.serverRequire(module, './connection.server');\n","var util = require('../util');\nvar Model = require('./Model');\n\nModel.prototype._mutate = function(segments, fn, cb) {\n  cb = this.wrapCallback(cb);\n  var collectionName = segments[0];\n  var id = segments[1];\n  if (!collectionName || !id) {\n    var message = fn.name + ' must be performed under a collection ' +\n      'and document id. Invalid path: ' + segments.join('.');\n    return cb(new Error(message));\n  }\n  var doc = this.getOrCreateDoc(collectionName, id);\n  var docSegments = segments.slice(2);\n  return fn(doc, docSegments, cb);\n};\n\nModel.prototype.set = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._set(segments, value, cb);\n};\nModel.prototype._set = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function set(doc, docSegments, fnCb) {\n    var previous = doc.set(docSegments, value, fnCb);\n    // On setting the entire doc, remote docs sometimes do a copy to add the\n    // id without it being stored in the database by ShareJS\n    if (docSegments.length === 0) value = doc.get(docSegments);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, set, cb);\n};\n\nModel.prototype.setEach = function() {\n  var subpath, object, cb;\n  if (arguments.length === 1) {\n    object = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    object = arguments[1];\n  } else {\n    subpath = arguments[0];\n    object = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setEach(segments, object, cb);\n};\nModel.prototype._setEach = function(segments, object, cb) {\n  segments = this._dereference(segments);\n  var group = util.asyncGroup(this.wrapCallback(cb));\n  for (var key in object) {\n    var value = object[key];\n    this._set(segments.concat(key), value, group());\n  }\n};\n\nModel.prototype.add = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._add(segments, value, cb);\n};\nModel.prototype._add = function(segments, value, cb) {\n  if (typeof value !== 'object') {\n    var message = 'add requires an object value. Invalid value: ' + value;\n    cb = this.wrapCallback(cb);\n    return cb(new Error(message));\n  }\n  var id = value.id || this.id();\n  value.id = id;\n  this._set(segments.concat(id), value, cb);\n  return id;\n};\n\nModel.prototype.setNull = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setNull(segments, value, cb);\n};\nModel.prototype._setNull = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function setNull(doc, docSegments, fnCb) {\n    var previous = doc.get(docSegments);\n    if (previous != null) {\n      fnCb();\n      return previous;\n    }\n    doc.set(docSegments, value, fnCb);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return value;\n  }\n  return this._mutate(segments, setNull, cb);\n};\n\nModel.prototype.del = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._del(segments, cb);\n};\nModel.prototype._del = function(segments, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function del(doc, docSegments, fnCb) {\n    var previous = doc.del(docSegments, fnCb);\n    // When deleting an entire document, also remove the reference to the\n    // document object from its collection\n    if (segments.length === 2) {\n      var collectionName = segments[0];\n      var id = segments[1];\n      model.root.collections[collectionName].remove(id);\n    }\n    model.emit('change', segments, [void 0, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, del, cb);\n};\n\nModel.prototype.increment = function() {\n  var subpath, byNumber, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else if (typeof arguments[0] === 'number') {\n      byNumber = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'number') {\n        byNumber = arguments[0];\n      } else {\n        subpath = arguments[0];\n      }\n    } else {\n      subpath = arguments[0];\n      byNumber = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    byNumber = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._increment(segments, byNumber, cb);\n};\nModel.prototype._increment = function(segments, byNumber, cb) {\n  segments = this._dereference(segments);\n  if (byNumber == null) byNumber = 1;\n  var model = this;\n  function increment(doc, docSegments, fnCb) {\n    var value = doc.increment(docSegments, byNumber, fnCb);\n    var previous = value - byNumber;\n    model.emit('change', segments, [value, previous, model._pass]);\n    return value;\n  }\n  return this._mutate(segments, increment, cb);\n};\n\nModel.prototype.push = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._push(segments, value, cb);\n};\nModel.prototype._push = function(segments, value, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function push(doc, docSegments, fnCb) {\n    var length = doc.push(docSegments, value, fnCb);\n    model.emit('insert', segments, [length - 1, [value], model._pass]);\n    return length;\n  }\n  return this._mutate(segments, push, cb);\n};\n\nModel.prototype.unshift = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._unshift(segments, value, cb);\n};\nModel.prototype._unshift = function(segments, value, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function unshift(doc, docSegments, fnCb) {\n    var length = doc.unshift(docSegments, value, fnCb);\n    model.emit('insert', segments, [0, [value], model._pass]);\n    return length;\n  }\n  return this._mutate(segments, unshift, cb);\n};\n\nModel.prototype.insert = function() {\n  var subpath, index, values, cb;\n  if (arguments.length === 1) {\n    throw new Error('Not enough arguments for insert');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    values = arguments[1];\n  } else if (arguments.length === 3) {\n    subpath = arguments[0];\n    index = arguments[1];\n    values = arguments[2];\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    values = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._insert(segments, +index, values, cb);\n};\nModel.prototype._insert = function(segments, index, values, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function insert(doc, docSegments, fnCb) {\n    var inserted = (Array.isArray(values)) ? values : [values];\n    var length = doc.insert(docSegments, index, inserted, fnCb);\n    model.emit('insert', segments, [index, inserted, model._pass]);\n    return length;\n  }\n  return this._mutate(segments, insert, cb);\n};\n\nModel.prototype.pop = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._pop(segments, cb);\n};\nModel.prototype._pop = function(segments, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function pop(doc, docSegments, fnCb) {\n    var arr = doc.get(docSegments);\n    var length = arr && arr.length;\n    if (!length) {\n      fnCb();\n      return;\n    }\n    var value = doc.pop(docSegments, fnCb);\n    model.emit('remove', segments, [length - 1, [value], model._pass]);\n    return value;\n  }\n  return this._mutate(segments, pop, cb);\n};\n\nModel.prototype.shift = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._shift(segments, cb);\n};\nModel.prototype._shift = function(segments, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function shift(doc, docSegments, fnCb) {\n    var arr = doc.get(docSegments);\n    var length = arr && arr.length;\n    if (!length) {\n      fnCb();\n      return;\n    }\n    var value = doc.shift(docSegments, fnCb);\n    model.emit('remove', segments, [0, [value], model._pass]);\n    return value;\n  }\n  return this._mutate(segments, shift, cb);\n};\n\nModel.prototype.remove = function() {\n  var subpath, index, howMany, cb;\n  if (arguments.length === 1) {\n    index = arguments[0];\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n      } else {\n        subpath = arguments[0];\n      }\n    } else {\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n        howMany = arguments[1];\n      } else {\n        subpath = arguments[0];\n        index = arguments[1];\n      }\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n        howMany = arguments[1];\n      } else {\n        subpath = arguments[0];\n        index = arguments[1];\n      }\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      howMany = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    howMany = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  if (index == null) index = segments.pop();\n  return this._remove(segments, +index, howMany, cb);\n};\nModel.prototype._remove = function(segments, index, howMany, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  if (howMany == null) howMany = 1;\n  var model = this;\n  function remove(doc, docSegments, fnCb) {\n    var removed = doc.remove(docSegments, index, howMany, fnCb);\n    model.emit('remove', segments, [index, removed, model._pass]);\n    return removed;\n  }\n  return this._mutate(segments, remove, cb);\n};\n\nModel.prototype.move = function() {\n  var subpath, from, to, howMany, cb;\n  if (arguments.length === 1) {\n    throw new Error('Not enough arguments for move');\n  } else if (arguments.length === 2) {\n    from = arguments[0];\n    to = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      from = arguments[0];\n      to = arguments[1];\n      cb = arguments[2];\n    } else if (typeof arguments[0] === 'number') {\n      from = arguments[0];\n      to = arguments[1];\n      howMany = arguments[2];\n    } else {\n      subpath = arguments[0];\n      from = arguments[1];\n      to = arguments[2];\n    }\n  } else if (arguments.length === 4) {\n    if (typeof arguments[3] === 'function') {\n      cb = arguments[3];\n      if (typeof arguments[0] === 'number') {\n        from = arguments[0];\n        to = arguments[1];\n        howMany = arguments[2];\n      } else {\n        subpath = arguments[0];\n        from = arguments[1];\n        to = arguments[2];\n      }\n    } else {\n      subpath = arguments[0];\n      from = arguments[1];\n      to = arguments[2];\n      howMany = arguments[3];\n    }\n  } else {\n    subpath = arguments[0];\n    from = arguments[1];\n    to = arguments[2];\n    howMany = arguments[3];\n    cb = arguments[4];\n  }\n  var segments = this._splitPath(subpath);\n  return this._move(segments, from, to, howMany, cb);\n};\nModel.prototype._move = function(segments, from, to, howMany, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  if (howMany == null) howMany = 1;\n  var model = this;\n  function move(doc, docSegments, fnCb) {\n    // Cast to numbers\n    from = +from;\n    to = +to;\n    // Convert negative indices into positive\n    if (from < 0 || to < 0) {\n      var len = doc.get(docSegments).length;\n      if (from < 0) from += len;\n      if (to < 0) to += len;\n    }\n    var moved = doc.move(docSegments, from, to, howMany, fnCb);\n    model.emit('move', segments, [from, to, moved.length, model._pass]);\n    return moved;\n  }\n  return this._mutate(segments, move, cb);\n};\n\nModel.prototype.stringInsert = function() {\n  var subpath, index, text, cb;\n  if (arguments.length === 1) {\n    throw new Error('Not enough arguments for stringInsert');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    text = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      index = arguments[0];\n      text = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      text = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    text = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._stringInsert(segments, index, text, cb);\n};\nModel.prototype._stringInsert = function(segments, index, text, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function stringInsert(doc, docSegments, fnCb) {\n    var previous = doc.stringInsert(docSegments, index, text, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$stringInsert: {index: index, text: text}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n    return;\n  }\n  return this._mutate(segments, stringInsert, cb);\n};\n\nModel.prototype.stringRemove = function() {\n  var subpath, index, howMany, cb;\n  if (arguments.length === 1) {\n    throw new Error('Not enough arguments for stringRemove');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    howMany = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      index = arguments[0];\n      howMany = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      howMany = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    howMany = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._stringRemove(segments, index, howMany, cb);\n};\nModel.prototype._stringRemove = function(segments, index, howMany, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function stringRemove(doc, docSegments, fnCb) {\n    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$stringRemove: {index: index, howMany: howMany}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n    return;\n  }\n  return this._mutate(segments, stringRemove, cb);\n};\n","var Model = require('./Model');\n\nexports.mixin = {};\n\nModel.prototype._splitPath = function(subpath) {\n  var path = this.path(subpath);\n  return (path && path.split('.')) || [];\n};\n\n/**\n * Returns the path equivalent to the path of the current scoped model plus\n * (optionally) a suffix subpath\n *\n * @optional @param {String} subpath\n * @return {String} absolute path\n * @api public\n */\nModel.prototype.path = function(subpath) {\n  if (subpath == null || subpath === '') return (this._at) ? this._at : '';\n  if (typeof subpath === 'string' || typeof subpath === 'number') {\n    return (this._at) ? this._at + '.' + subpath : '' + subpath;\n  }\n  if (typeof subpath.path === 'function') return subpath.path();\n};\n\nModel.prototype.isPath = function(subpath) {\n  return this.path(subpath) != null;\n};\n\nModel.prototype.scope = function(path) {\n  var model = this._child();\n  model._at = path;\n  return model;\n};\n\n/**\n * Create a model object scoped to a particular path.\n * Example:\n *     var user = model.at('users.1');\n *     user.set('username', 'brian');\n *     user.on('push', 'todos', function(todo) {\n *       // ...\n *     });\n *\n *  @param {String} segment\n *  @return {Model} a scoped model\n *  @api public\n */\nModel.prototype.at = function(subpath) {\n  var path = this.path(subpath);\n  return this.scope(path);\n};\n\n/**\n * Returns a model scope that is a number of levels above the current scoped\n * path. Number of levels defaults to 1, so this method called without\n * arguments returns the model scope's parent model scope.\n *\n * @optional @param {Number} levels\n * @return {Model} a scoped model\n */\nModel.prototype.parent = function(levels) {\n  if (levels == null) levels = 1;\n  var segments = this._splitPath();\n  var len = Math.max(0, segments.length - levels);\n  var path = segments.slice(0, len).join('.');\n  return this.scope(path);\n};\n\n/**\n * Returns the last property segment of the current model scope path\n *\n * @optional @param {String} path\n * @return {String}\n */\nModel.prototype.leaf = function(path) {\n  if (!path) path = this.path();\n  var i = path.lastIndexOf('.');\n  return path.slice(i + 1);\n};\n","var util = require('../util');\nvar Model = require('./Model');\n\nModel.INITS.push(function(model) {\n  var root = model.root;\n  root._refs = new Refs(root);\n  addIndexListeners(root);\n  addListener(root, 'change', refChange);\n  addListener(root, 'load', refLoad);\n  addListener(root, 'unload', refUnload);\n  addListener(root, 'insert', refInsert);\n  addListener(root, 'remove', refRemove);\n  addListener(root, 'move', refMove);\n});\n\nfunction addIndexListeners(model) {\n  model.on('insert', function refInsertIndex(segments, eventArgs) {\n    var index = eventArgs[0];\n    var howMany = eventArgs[1].length;\n    function patchInsert(refIndex) {\n      return (index <= refIndex) ? refIndex + howMany : refIndex;\n    }\n    onIndexChange(segments, patchInsert);\n  });\n  model.on('remove', function refRemoveIndex(segments, eventArgs) {\n    var index = eventArgs[0];\n    var howMany = eventArgs[1].length;\n    function patchRemove(refIndex) {\n      return (index <= refIndex) ? refIndex - howMany : refIndex;\n    }\n    onIndexChange(segments, patchRemove);\n  });\n  model.on('move', function refMoveIndex(segments, eventArgs) {\n    var from = eventArgs[0];\n    var to = eventArgs[1];\n    var howMany = eventArgs[2];\n    function patchMove(refIndex) {\n      // If the index was moved itself\n      if (from <= refIndex && refIndex < from + howMany) {\n        return refIndex + to - from;\n      }\n      // Remove part of a move\n      if (from <= refIndex) refIndex -= howMany;\n      // Insert part of a move\n      if (to <= refIndex) refIndex += howMany;\n      return refIndex;\n    }\n    onIndexChange(segments, patchMove);\n  });\n  function onIndexChange(segments, patch) {\n    var fromMap = model._refs.fromMap;\n    for (var from in fromMap) {\n      var ref = fromMap[from];\n      if (!(ref.updateIndices &&\n        util.contains(segments, ref.toSegments) &&\n        ref.toSegments.length > segments.length)) continue;\n      var index = +ref.toSegments[segments.length];\n      var patched = patch(index);\n      if (index === patched) continue;\n      model._refs.remove(from);\n      ref.toSegments[segments.length] = '' + patched;\n      ref.to = ref.toSegments.join('.');\n      model._refs._add(ref);\n    }\n  }\n}\n\nfunction refChange(model, dereferenced, eventArgs, segments) {\n  var value = eventArgs[0];\n  // Detect if we are deleting vs. setting to undefined\n  if (value === void 0) {\n    var parentSegments = segments.slice();\n    var last = parentSegments.pop();\n    var parent = model._get(parentSegments);\n    if (!parent || !(last in parent)) {\n      model._del(dereferenced);\n      return;\n    }\n  }\n  model._set(dereferenced, value);\n}\nfunction refLoad(model, dereferenced, eventArgs) {\n  var value = eventArgs[0];\n  model._set(dereferenced, value);\n}\nfunction refUnload(model, dereferenced, eventArgs) {\n  model._del(dereferenced);\n}\nfunction refInsert(model, dereferenced, eventArgs) {\n  var index = eventArgs[0];\n  var values = eventArgs[1];\n  model._insert(dereferenced, index, values);\n}\nfunction refRemove(model, dereferenced, eventArgs) {\n  var index = eventArgs[0];\n  var howMany = eventArgs[1].length;\n  model._remove(dereferenced, index, howMany);\n}\nfunction refMove(model, dereferenced, eventArgs) {\n  var from = eventArgs[0];\n  var to = eventArgs[1];\n  var howMany = eventArgs[2];\n  model._move(dereferenced, from, to, howMany);\n}\n\nfunction addListener(model, type, fn) {\n  model.on(type, refListener);\n  function refListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    // Find cases where an event is emitted on a path where a reference\n    // is pointing. All original mutations happen on the fully dereferenced\n    // location, so this detection only needs to happen in one direction\n    var toMap = model._refs.toMap;\n    var subpath;\n    for (var i = 0, len = segments.length; i < len; i++) {\n      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];\n      // If a ref is found pointing to a matching subpath, re-emit on the\n      // place where the reference is coming from as if the mutation also\n      // occured at that path\n      var refs = toMap[subpath];\n      if (!refs) continue;\n      var remaining = segments.slice(i + 1);\n      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {\n        var ref = refs[refIndex];\n        var dereferenced = ref.fromSegments.concat(remaining);\n        // The value may already be up to date via object reference. If so,\n        // simply re-emit the event. Otherwise, perform the same mutation on\n        // the ref's path\n        if (model._get(dereferenced) === model._get(segments)) {\n          model.emit(type, dereferenced, eventArgs);\n        } else {\n          var setterModel = ref.model.pass(pass, true);\n          setterModel._dereference = noopDereference;\n          fn(setterModel, dereferenced, eventArgs, segments);\n        }\n      }\n    }\n    // If a ref points to a child of a matching subpath, get the value in\n    // case it has changed and set if different\n    var parentToMap = model._refs.parentToMap;\n    var refs = parentToMap[subpath];\n    if (!refs) return;\n    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {\n      var ref = refs[refIndex];\n      var value = model._get(ref.toSegments);\n      var previous = model._get(ref.fromSegments);\n      if (previous !== value) {\n        var setterModel = ref.model.pass(pass, true);\n        setterModel._dereference = noopDereference;\n        setterModel._set(ref.fromSegments, value);\n      }\n    }\n  }\n}\n\nModel.prototype._canRefTo = function(value) {\n  return this.isPath(value) || (value && typeof value.ref === 'function');\n};\n\nModel.prototype.ref = function() {\n  var from, to, options;\n  if (arguments.length === 1) {\n    to = arguments[0];\n  } else if (arguments.length === 2) {\n    if (this._canRefTo(arguments[1])) {\n      from = arguments[0];\n      to = arguments[1];\n    } else {\n      to = arguments[0];\n      options = arguments[1];\n    }\n  } else {\n    from = arguments[0];\n    to = arguments[1];\n    options = arguments[2];\n  }\n  var fromPath = this.path(from);\n  var toPath = this.path(to);\n  // Make ref to reffable object, such as query or filter\n  if (!toPath) return to.ref(fromPath);\n  var fromSegments = fromPath.split('.');\n  if (fromSegments.length < 2) {\n    throw new Error('ref must be performed under a collection ' +\n      'and document id. Invalid path: ' + fromPath);\n  }\n  this.root._refs.remove(fromPath);\n  var value = this.get(to);\n  this._set(fromSegments, value);\n  this.root._refs.add(fromPath, toPath, options);\n  return this.scope(fromPath);\n};\n\nModel.prototype.removeRef = function(subpath) {\n  var segments = this._splitPath(subpath);\n  var fromPath = segments.join('.');\n  this._removeRef(segments, fromPath);\n};\nModel.prototype._removeRef = function(segments, fromPath) {\n  this.root._refs.remove(fromPath);\n  this.root._refLists.remove(fromPath);\n  this._del(segments);\n};\n\nModel.prototype.removeAllRefs = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._removeAllRefs(segments);\n};\nModel.prototype._removeAllRefs = function(segments) {\n  this._removeMapRefs(segments, this.root._refs.fromMap);\n  this._removeMapRefs(segments, this.root._refLists.fromMap);\n};\nModel.prototype._removeMapRefs = function(segments, map) {\n  for (var from in map) {\n    var fromSegments = map[from].fromSegments;\n    if (util.contains(segments, fromSegments)) {\n      this._removeRef(fromSegments, from);\n    }\n  }\n};\n\nModel.prototype.dereference = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._dereference(segments).join('.');\n};\n\nModel.prototype._dereference = function(segments, forArrayMutator, ignore) {\n  if (segments.length === 0) return segments;\n  var refs = this.root._refs.fromMap;\n  var refLists = this.root._refLists.fromMap;\n  var doAgain;\n  do {\n    var subpath = '';\n    doAgain = false;\n    for (var i = 0, len = segments.length; i < len; i++) {\n      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];\n\n      var ref = refs[subpath];\n      if (ref) {\n        var remaining = segments.slice(i + 1);\n        segments = ref.toSegments.concat(remaining);\n        doAgain = true;\n        break;\n      }\n\n      var refList = refLists[subpath];\n      if (refList && refList !== ignore) {\n        var belowDescendant = i + 2 < len;\n        var belowChild = i + 1 < len;\n        if (!(belowDescendant || forArrayMutator && belowChild)) continue;\n        segments = refList.dereference(segments, i);\n        doAgain = true;\n        break;\n      }\n    }\n  } while (doAgain);\n  // If a dereference fails, return a path that will result in a null value\n  // instead of a path to everything in the model\n  if (segments.length === 0) return ['$null'];\n  return segments;\n};\n\nfunction noopDereference(segments) {\n  return segments;\n}\n\nfunction Ref(model, from, to, options) {\n  this.model = model && model.pass({$ref: this});\n  this.from = from;\n  this.to = to;\n  this.fromSegments = from.split('.');\n  this.toSegments = to.split('.');\n  this.parentTos = [];\n  for (var i = 1, len = this.toSegments.length; i < len; i++) {\n    var parentTo = this.toSegments.slice(0, i).join('.');\n    this.parentTos.push(parentTo);\n  }\n  this.updateIndices = options && options.updateIndices;\n}\nfunction FromMap() {}\nfunction ToMap() {}\n\nfunction Refs(model) {\n  this.model = model;\n  this.fromMap = new FromMap();\n  this.toMap = new ToMap();\n  this.parentToMap = new ToMap();\n}\n\nRefs.prototype.add = function(from, to, options) {\n  var ref = new Ref(this.model, from, to, options);\n  return this._add(ref);\n};\n\nRefs.prototype._add = function(ref) {\n  this.fromMap[ref.from] = ref;\n  listMapAdd(this.toMap, ref.to, ref);\n  for (var i = 0, len = ref.parentTos.length; i < len; i++) {\n    listMapAdd(this.parentToMap, ref.parentTos[i], ref);\n  }\n  return ref;\n};\n\nRefs.prototype.remove = function(from) {\n  var ref = this.fromMap[from];\n  if (!ref) return;\n  delete this.fromMap[from];\n  listMapRemove(this.toMap, ref.to, ref);\n  for (var i = 0, len = ref.parentTos.length; i < len; i++) {\n    listMapRemove(this.parentToMap, ref.parentTos[i], ref);\n  }\n  return ref;\n};\n\nRefs.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var ref = this.fromMap[from];\n    out.push([ref.from, ref.to]);\n  }\n  return out;\n};\n\nfunction listMapAdd(map, name, item) {\n  map[name] || (map[name] = []);\n  map[name].push(item);\n}\n\nfunction listMapRemove(map, name, item) {\n  var items = map[name];\n  if (!items) return;\n  var index = items.indexOf(item);\n  if (index === -1) return;\n  items.splice(index, 1);\n  if (!items.length) delete map[name];\n}\n","var util = require('../util');\nvar Model = require('./Model');\n\nModel.INITS.push(function(model) {\n  var root = model.root;\n  root._refLists = new RefLists(root);\n  for (var type in Model.MUTATOR_EVENTS) {\n    addListener(root, type);\n  }\n});\n\nfunction addListener(model, type) {\n  model.on(type, refListListener);\n  function refListListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    // Check for updates on or underneath paths\n    var fromMap = model._refLists.fromMap;\n    for (var from in fromMap) {\n      var refList = fromMap[from];\n      if (pass.$refList === refList) continue;\n      refList.onMutation(type, segments, eventArgs);\n    }\n  }\n}\n\n/**\n * @param {String} type\n * @param {Array} segments\n * @param {Array} eventArgs\n * @param {RefList} refList\n */\nfunction patchFromEvent(type, segments, eventArgs, refList) {\n  var fromLength = refList.fromSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // Mutation on the `from` output itself\n  if (segmentsLength === fromLength) {\n    if (type === 'insert') {\n      var index = eventArgs[0];\n      var values = eventArgs[1];\n      var ids = setNewToValues(model, refList, values);\n      model._insert(refList.idsSegments, index, ids);\n      return;\n    }\n\n    if (type === 'remove') {\n      var index = eventArgs[0];\n      var howMany = eventArgs[1].length;\n      var ids = model._remove(refList.idsSegments, index, howMany);\n      // Delete the appropriate items underneath `to` if the `deleteRemoved`\n      // option was set true\n      if (refList.deleteRemoved) {\n        for (var i = 0; i < ids.length; i++) {\n          var item = refList.itemById(ids[i]);\n          model._del(refList.toSegmentsByItem(item));\n        }\n      }\n      return;\n    }\n\n    if (type === 'move') {\n      var from = eventArgs[0];\n      var to = eventArgs[1];\n      var howMany = eventArgs[2];\n      model._move(refList.idsSegments, from, to, howMany);\n      return;\n    }\n\n    // Change of the entire output\n    var values = (type === 'change') ?\n      eventArgs[0] : model._get(refList.fromSegments);\n    // Set ids to empty list if output is set to null\n    if (!values) {\n      model._set(refList.idsSegments, []);\n      return;\n    }\n    // If the entire output is set, create a list of ids based on the output,\n    // and update the corresponding items\n    var ids = setNewToValues(model, refList, values);\n    model._set(refList.idsSegments, ids);\n    return;\n  }\n\n  // If mutation is on a parent of `from`, we might need to re-create the\n  // entire refList output\n  if (segmentsLength < fromLength) {\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  var index = segments[fromLength];\n  var value = model._get(refList.fromSegments.concat(index));\n  var toSegments = refList.toSegmentsByItem(value);\n\n  // Mutation underneath a child of the `from` object.\n  if (segmentsLength > fromLength + 1) {\n    throw new Error('Mutation on descendant of refList `from`' +\n      ' should have been dereferenced: ' + segments.join('.'));\n  }\n\n  // Otherwise, mutation of a child of the `from` object\n\n  // If changing the item itself, it will also have to be re-set on the\n  // original object\n  if (type === 'change') {\n    model._set(toSegments, value);\n    updateIdForValue(model, refList, index, value);\n    return;\n  }\n  if (type === 'insert' || type === 'remove' || type === 'move') {\n    throw new Error('Array mutation on child of refList `from`' +\n      'should have been dereferenced: ' + segments.join('.'));\n  }\n}\n\n/**\n * @private\n * @param {Model} model\n * @param {RefList} refList\n * @param {Array} values\n */\nfunction setNewToValues(model, refList, values, fn) {\n  var ids = [];\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n    var id = refList.idByItem(value);\n    if (id === void 0 && typeof value === 'object') {\n      id = value.id = model.id();\n    }\n    var toSegments = refList.toSegmentsByItem(value);\n    if (id === void 0 || toSegments === void 0) {\n      throw new Error('Unable to add item to refList: ' + value);\n    }\n    if (model._get(toSegments) !== value) {\n      model._set(toSegments, value);\n    }\n    ids.push(id);\n  }\n  return ids;\n}\nfunction updateIdForValue(model, refList, index, value) {\n  var id = refList.idByItem(value);\n  var outSegments = refList.idsSegments.concat(index);\n  model._set(outSegments, id);\n}\n\nfunction patchToEvent(type, segments, eventArgs, refList) {\n  var toLength = refList.toSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // Mutation on the `to` object itself\n  if (segmentsLength === toLength) {\n    if (type === 'insert') {\n      var insertIndex = eventArgs[0];\n      var values = eventArgs[1];\n      for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var indices = refList.indicesByItem(value);\n        if (!indices) continue;\n        for (var j = 0; j < indices.length; j++) {\n          var outSegments = refList.fromSegments.concat(indices[j]);\n          model._set(outSegments, value);\n        }\n      }\n      return;\n    }\n\n    if (type === 'remove') {\n      var removeIndex = eventArgs[0];\n      var values = eventArgs[1];\n      var howMany = values.length;\n      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {\n        var indices = refList.indicesByItem(values[i]);\n        if (!indices) continue;\n        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {\n          var outSegments = refList.fromSegments.concat(indices[j]);\n          model._set(outSegments, void 0);\n        }\n      }\n      return;\n    }\n\n    if (type === 'move') {\n      // Moving items in the `to` object should have no effect on the output\n      return;\n    }\n  }\n\n  // Mutation on or above the `to` object\n  if (segmentsLength <= toLength) {\n    // If the entire `to` object is updated, we need to re-create the\n    // entire refList output and apply what is different\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  // Mutation underneath a child of the `to` object. The item will already\n  // be up to date, since it is under an object reference. Just re-emit\n  if (segmentsLength > toLength + 1) {\n    var value = model._get(segments.slice(0, toLength + 1));\n    var indices = refList.indicesByItem(value);\n    if (!indices) return;\n    var remaining = segments.slice(toLength + 1);\n    for (var i = 0; i < indices.length; i++) {\n      var index = indices[i];\n      var dereferenced = refList.fromSegments.concat(index, remaining);\n      dereferenced = model._dereference(dereferenced, null, refList);\n      eventArgs = eventArgs.slice();\n      eventArgs[eventArgs.length - 1] = model._pass;\n      model.emit(type, dereferenced, eventArgs);\n    }\n    return;\n  }\n\n  // Otherwise, mutation of a child of the `to` object\n\n  // If changing the item itself, it will also have to be re-set on the\n  // array created by the refList\n  if (type === 'change' || type === 'load' || type === 'unload') {\n    var value, previous;\n    if (type === 'change') {\n      value = eventArgs[0];\n      previous = eventArgs[1];\n    } else if (type === 'load') {\n      value = eventArgs[0];\n      previous = void 0;\n    } else if (type === 'unload') {\n      value = void 0;\n      previous = eventArgs[0];\n    }\n    var newIndices = refList.indicesByItem(value);\n    var oldIndices = refList.indicesByItem(previous);\n    if (!newIndices && !oldIndices) return;\n    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {\n      // The changed item used to refer to some indices, but no longer does\n      for (var i = 0; i < oldIndices.length; i++) {\n        var outSegments = refList.fromSegments.concat(oldIndices[i]);\n        model._set(outSegments, void 0);\n      }\n    }\n    if (newIndices) {\n      for (var i = 0; i < newIndices.length; i++) {\n        var outSegments = refList.fromSegments.concat(newIndices[i]);\n        model._set(outSegments, value);\n      }\n    }\n    return;\n  }\n\n  var value = model._get(segments.slice(0, toLength + 1));\n  var indices = refList.indicesByItem(value);\n  if (!indices) return;\n\n  if (type === 'insert' || type === 'remove' || type === 'move') {\n    // Array mutations will have already been updated via an object\n    // reference, so only re-emit\n    for (var i = 0; i < indices.length; i++) {\n      var dereferenced = refList.fromSegments.concat(indices[i]);\n      dereferenced = model._dereference(dereferenced, null, refList);\n      eventArgs = eventArgs.slice();\n      eventArgs[eventArgs.length - 1] = model._pass;\n      model.emit(type, dereferenced, eventArgs);\n    }\n  }\n}\nfunction equivalentArrays(a, b) {\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction patchIdsEvent(type, segments, eventArgs, refList) {\n  var idsLength = refList.idsSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // An array mutation of the ids should be mirrored with a like change in\n  // the output array\n  if (segmentsLength === idsLength) {\n    if (type === 'insert') {\n      var index = eventArgs[0];\n      var inserted = eventArgs[1];\n      var values = [];\n      for (var i = 0; i < inserted.length; i++) {\n        var value = refList.itemById(inserted[i]);\n        values.push(value);\n      }\n      model._insert(refList.fromSegments, index, values);\n      return;\n    }\n\n    if (type === 'remove') {\n      var index = eventArgs[0];\n      var howMany = eventArgs[1].length;\n      model._remove(refList.fromSegments, index, howMany);\n      return;\n    }\n\n    if (type === 'move') {\n      var from = eventArgs[0];\n      var to = eventArgs[1];\n      var howMany = eventArgs[2];\n      model._move(refList.fromSegments, from, to, howMany);\n      return;\n    }\n  }\n\n  // Mutation on the `ids` list itself\n  if (segmentsLength <= idsLength) {\n    // If the entire `ids` array is updated, we need to re-create the\n    // entire refList output and apply what is different\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  // Otherwise, direct mutation of a child in the `ids` object or mutation\n  // underneath an item in the `ids` list. Update the item for the appropriate\n  // id if it has changed\n  var index = segments[idsLength];\n  var id = refList.idByIndex(index);\n  var item = refList.itemById(id);\n  var itemSegments = refList.fromSegments.concat(index);\n  if (model._get(itemSegments) !== item) {\n    model._set(itemSegments, item);\n  }\n}\n\nModel.prototype.refList = function() {\n  var from, to, ids, options;\n  if (arguments.length === 2) {\n    to = arguments[0];\n    ids = arguments[1];\n  } else if (arguments.length === 3) {\n    if (this.isPath(arguments[2])) {\n      from = arguments[0];\n      to = arguments[1];\n      ids = arguments[2];\n    } else {\n      to = arguments[0];\n      ids = arguments[1];\n      options = arguments[2];\n    }\n  } else {\n    from = arguments[0];\n    to = arguments[1];\n    ids = arguments[2];\n    options = arguments[3];\n  }\n  var fromPath = this.path(from);\n  var toPath;\n  if (Array.isArray(to)) {\n    toPath = [];\n    for (var i = 0; i < to.length; i++) {\n      toPath.push(this.path(to[i]));\n    }\n  } else {\n    toPath = this.path(to);\n  }\n  var idsPath = this.path(ids);\n  var refList = this.root._refLists.add(fromPath, toPath, idsPath, options);\n  this.pass({$refList: refList})._setArrayDiff(refList.fromSegments, refList.get());\n  return this.scope(fromPath);\n};\n\nfunction RefList(model, from, to, ids, options) {\n  this.model = model && model.pass({$refList: this});\n  this.from = from;\n  this.to = to;\n  this.ids = ids;\n  this.fromSegments = from && from.split('.');\n  this.toSegments = to && to.split('.');\n  this.idsSegments = ids && ids.split('.');\n  this.options = options;\n  this.deleteRemoved = options && options.deleteRemoved;\n}\n\n// The default implementation assumes that the ids array is a flat list of\n// keys on the to object. Ideally, this mapping could be customized via\n// inheriting from RefList and overriding these methods without having to\n// modify the above event handling code.\n//\n// In the default refList implementation, `key` and `id` are equal.\n//\n// Terms in the below methods:\n//   `item`  - Object on the `to` path, which gets mirrored on the `from` path\n//   `key`   - The property under `to` at which an item is located\n//   `id`    - String or object in the array at the `ids` path\n//   `index` - The index of an id, which corresponds to an index on `from`\nRefList.prototype.get = function() {\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return [];\n  var items = this.model._get(this.toSegments);\n  var out = [];\n  for (var i = 0; i < ids.length; i++) {\n    var key = ids[i];\n    out.push(items && items[key]);\n  }\n  return out;\n};\nRefList.prototype.dereference = function(segments, i) {\n  var remaining = segments.slice(i + 1);\n  var key = this.idByIndex(remaining[0]);\n  if (key == null) return [];\n  remaining[0] = key;\n  return this.toSegments.concat(remaining);\n};\nRefList.prototype.toSegmentsByItem = function(item) {\n  var key = this.idByItem(item);\n  if (key === void 0) return;\n  return this.toSegments.concat(key);\n};\nRefList.prototype.idByItem = function(item) {\n  if (item && item.id) return item.id;\n  var items = this.model._get(this.toSegments);\n  for (var key in items) {\n    if (item === items[key]) return key;\n  }\n};\nRefList.prototype.indicesByItem = function(item) {\n  var id = this.idByItem(item);\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return;\n  var indices;\n  var index = -1;\n  while (true) {\n    index = ids.indexOf(id, index + 1);\n    if (index === -1) break;\n    if (indices) {\n      indices.push(index);\n    } else {\n      indices = [index];\n    }\n  }\n  return indices;\n};\nRefList.prototype.itemById = function(id) {\n  return this.model._get(this.toSegments.concat(id));\n};\nRefList.prototype.idByIndex = function(index) {\n  return this.model._get(this.idsSegments.concat(index));\n};\nRefList.prototype.onMutation = function(type, segments, eventArgs) {\n  if (util.mayImpact(this.toSegments, segments)) {\n    patchToEvent(type, segments, eventArgs, this);\n  } else if (util.mayImpact(this.idsSegments, segments)) {\n    patchIdsEvent(type, segments, eventArgs, this);\n  } else if (util.mayImpact(this.fromSegments, segments)) {\n    patchFromEvent(type, segments, eventArgs, this);\n  }\n};\n\nfunction FromMap() {}\n\nfunction RefLists(model) {\n  this.model = model;\n  this.fromMap = new FromMap();\n}\n\nRefLists.prototype.add = function(from, to, ids, options) {\n  var refList = new RefList(this.model, from, to, ids, options);\n  this.fromMap[from] = refList;\n  return refList;\n};\n\nRefLists.prototype.remove = function(from) {\n  var refList = this.fromMap[from];\n  delete this.fromMap[from];\n  return refList;\n};\n\nRefLists.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var refList = this.fromMap[from];\n    out.push([refList.from, refList.to, refList.ids, refList.options]);\n  }\n  return out;\n};\n","var util = require('../util');\nvar Model = require('./Model');\nvar arrayDiff = require('arraydiff');\n\nModel.prototype.setDiff = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setDiff(segments, value, cb);\n};\nModel.prototype._setDiff = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function setDiff(doc, docSegments, fnCb) {\n    var previous = doc.get(docSegments);\n    if (util.equal(previous, value)) {\n      fnCb();\n      return previous;\n    }\n    doc.set(docSegments, value, fnCb);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, setDiff, cb);\n};\n\nModel.prototype.setDiffDeep = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setDiffDeep(segments, value, cb);\n};\nModel.prototype._setDiffDeep = function(segments, value, cb) {\n  var before = this._get(segments);\n  cb = this.wrapCallback(cb);\n  var group = util.asyncGroup(cb);\n  var finished = group();\n  diffDeep(this, segments, before, value, group);\n  finished();\n};\nfunction diffDeep(model, segments, before, after, group) {\n  if (typeof before !== 'object' || !before ||\n      typeof after !== 'object' || !after) {\n    // Set the entire value if not diffable\n    model._set(segments, after, group());\n    return;\n  }\n  if (Array.isArray(before) && Array.isArray(after)) {\n    var diff = arrayDiff(before, after, util.deepEqual);\n    if (!diff.length) return;\n    // If the only change is a single item replacement, diff the item instead\n    if (\n      diff.length === 2 &&\n      diff[0].index === diff[1].index &&\n      diff[0] instanceof arrayDiff.RemoveDiff &&\n      diff[0].howMany === 1 &&\n      diff[1] instanceof arrayDiff.InsertDiff &&\n      diff[1].values.length === 1\n    ) {\n      var index = diff[0].index;\n      var itemSegments = segments.concat(index);\n      diffDeep(model, itemSegments, before[index], after[index], group);\n      return;\n    }\n    model._applyArrayDiff(segments, diff, group());\n    return;\n  }\n\n  // Delete keys that were in before but not after\n  for (var key in before) {\n    if (key in after) continue;\n    var itemSegments = segments.concat(key);\n    model._del(itemSegments, group());\n  }\n\n  // Diff each property in after\n  for (var key in after) {\n    if (util.deepEqual(before[key], after[key])) continue;\n    var itemSegments = segments.concat(key);\n    diffDeep(model, itemSegments, before[key], after[key], group);\n  }\n}\n\nModel.prototype.setArrayDiff = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setArrayDiff(segments, value, cb);\n};\nModel.prototype.setArrayDiffDeep = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setArrayDiffDeep(segments, value, cb);\n};\nModel.prototype._setArrayDiffDeep = function(segments, value, cb) {\n  return this._setArrayDiff(segments, value, cb, util.deepEqual);\n};\nModel.prototype._setArrayDiff = function(segments, value, cb, _equalFn) {\n  var before = this._get(segments);\n  if (before === value) return this.wrapCallback(cb)();\n  if (!Array.isArray(before) || !Array.isArray(value)) {\n    this._set(segments, value, cb);\n    return;\n  }\n  var diff = arrayDiff(before, value, _equalFn);\n  this._applyArrayDiff(segments, diff, cb);\n};\nModel.prototype._applyArrayDiff = function(segments, diff, cb) {\n  if (!diff.length) return this.wrapCallback(cb)();\n  segments = this._dereference(segments);\n  var model = this;\n  function applyArrayDiff(doc, docSegments, fnCb) {\n    var group = util.asyncGroup(fnCb);\n    for (var i = 0, len = diff.length; i < len; i++) {\n      var item = diff[i];\n      if (item instanceof arrayDiff.InsertDiff) {\n        // Insert\n        doc.insert(docSegments, item.index, item.values, group());\n        model.emit('insert', segments, [item.index, item.values, model._pass]);\n      } else if (item instanceof arrayDiff.RemoveDiff) {\n        // Remove\n        var removed = doc.remove(docSegments, item.index, item.howMany, group());\n        model.emit('remove', segments, [item.index, removed, model._pass]);\n      } else if (item instanceof arrayDiff.MoveDiff) {\n        // Move\n        var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());\n        model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);\n      }\n    }\n  }\n  return this._mutate(segments, applyArrayDiff, cb);\n};\n","(function (process){\nvar util = require('../util');\nvar Model = require('./Model');\nvar Query = require('./Query');\n\nModel.INITS.push(function(model, options) {\n  model.root.fetchOnly = options.fetchOnly;\n  model.root.unloadDelay = options.unloadDelay || (util.isServer) ? 0 : 1000;\n\n  // Keeps track of the count of fetches (that haven't been undone by an\n  // unfetch) per doc. Maps doc id to the fetch count.\n  model.root._fetchedDocs = new FetchedDocs();\n\n  // Keeps track of the count of subscribes (that haven't been undone by an\n  // unsubscribe) per doc. Maps doc id to the subscribe count.\n  model.root._subscribedDocs = new SubscribedDocs();\n\n  // Maps doc path to doc version\n  model.root._loadVersions = new LoadVersions();\n});\n\nfunction FetchedDocs() {}\nfunction SubscribedDocs() {}\nfunction LoadVersions() {}\n\nModel.prototype.fetch = function() {\n  this._forSubscribable(arguments, 'fetch');\n  return this;\n};\nModel.prototype.unfetch = function() {\n  this._forSubscribable(arguments, 'unfetch');\n  return this;\n};\nModel.prototype.subscribe = function() {\n  this._forSubscribable(arguments, 'subscribe');\n  return this;\n};\nModel.prototype.unsubscribe = function() {\n  this._forSubscribable(arguments, 'unsubscribe');\n  return this;\n};\n\nModel.prototype._forSubscribable = function(argumentsObject, method) {\n  var args, cb;\n  if (!argumentsObject.length) {\n    // Use this model's scope if no arguments\n    args = [null];\n  } else if (typeof argumentsObject[0] === 'function') {\n    // Use this model's scope if the first argument is a callback\n    args = [null];\n    cb = argumentsObject[0];\n  } else if (Array.isArray(argumentsObject[0])) {\n    // Items can be passed in as an array\n    args = argumentsObject[0];\n    cb = argumentsObject[1];\n  } else {\n    // Or as multiple arguments\n    args = Array.prototype.slice.call(argumentsObject);\n    var last = args[args.length - 1];\n    if (typeof last === 'function') cb = args.pop();\n  }\n\n  var group = util.asyncGroup(this.wrapCallback(cb));\n  var finished = group();\n  var docMethod = method + 'Doc';\n\n  for (var i = 0; i < args.length; i++) {\n    var item = args[i];\n    if (item instanceof Query) {\n      item[method](group());\n    } else {\n      var segments = this._dereference(this._splitPath(item));\n      if (segments.length === 2) {\n        // Do the appropriate method for a single document.\n        this[docMethod](segments[0], segments[1], group());\n      } else if (segments.length === 1) {\n        // Make a query to an entire collection.\n        var query = this.query(segments[0], {});\n        query[method](group());\n      } else if (segments.length === 0) {\n        group()(new Error('No path specified for ' + method));\n      } else {\n        group()(new Error('Cannot ' + method + ' to a path within a document: ' +\n          segments.join('.')));\n      }\n    }\n  }\n  process.nextTick(finished);\n};\n\n/**\n * @param {String}\n * @param {String} id\n * @param {Function} cb(err)\n * @param {Boolean} alreadyLoaded\n */\nModel.prototype.fetchDoc = function(collectionName, id, cb, alreadyLoaded) {\n  cb = this.wrapCallback(cb);\n\n  // Maintain a count of fetches so that we can unload the document when\n  // there are no remaining fetches or subscribes for that document\n  var path = collectionName + '.' + id;\n  this._context.fetchDoc(path, this._pass);\n  this.root._fetchedDocs[path] = (this.root._fetchedDocs[path] || 0) + 1;\n\n  var model = this;\n  var doc = this.getOrCreateDoc(collectionName, id);\n  if (alreadyLoaded) {\n    fetchDocCallback();\n  } else {\n    doc.shareDoc.fetch(fetchDocCallback);\n  }\n  function fetchDocCallback(err) {\n    if (err) return cb(err);\n    if (doc.shareDoc.version !== model.root._loadVersions[path]) {\n      model.root._loadVersions[path] = doc.shareDoc.version;\n      doc._updateCollectionData();\n      model.emit('load', [collectionName, id], [doc.get(), model._pass]);\n    }\n    cb();\n  }\n};\n\n/**\n * @param {String} collectionName\n * @param {String} id of the document we want to subscribe to\n * @param {Function} cb(err)\n */\nModel.prototype.subscribeDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n\n  var path = collectionName + '.' + id;\n  this._context.subscribeDoc(path, this._pass);\n  var count = this.root._subscribedDocs[path] = (this.root._subscribedDocs[path] || 0) + 1;\n  // Already requested a subscribe, so just return\n  if (count > 1) return cb();\n\n  // Subscribe if currently unsubscribed\n  var model = this;\n  var doc = this.getOrCreateDoc(collectionName, id);\n  if (this.root.fetchOnly) {\n    // Only fetch if the document isn't already loaded\n    if (doc.get() === void 0) {\n      doc.shareDoc.fetch(subscribeDocCallback);\n    } else {\n      subscribeDocCallback();\n    }\n  } else {\n    doc.shareDoc.subscribe(subscribeDocCallback);\n  }\n  function subscribeDocCallback(err) {\n    if (err) return cb(err);\n    if (!doc.createdLocally && doc.shareDoc.version !== model.root._loadVersions[path]) {\n      model.root._loadVersions[path] = doc.shareDoc.version;\n      doc._updateCollectionData();\n      model.emit('load', [collectionName, id], [doc.get(), model._pass]);\n    }\n    cb();\n  }\n};\n\nModel.prototype.unfetchDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n  var path = collectionName + '.' + id;\n  this._context.unfetchDoc(path, this._pass);\n  var fetchedDocs = this.root._fetchedDocs;\n\n  // No effect if the document has no fetch count\n  if (!fetchedDocs[path]) return cb();\n\n  var model = this;\n  if (this.root.unloadDelay && !this._pass.$query) {\n    setTimeout(finishUnfetchDoc, this.root.unloadDelay);\n  } else {\n    finishUnfetchDoc();\n  }\n  function finishUnfetchDoc() {\n    var count = --fetchedDocs[path];\n    if (count) return cb(null, count);\n    delete fetchedDocs[path];\n    model._maybeUnloadDoc(collectionName, id, path);\n    cb(null, 0);\n  }\n};\n\nModel.prototype.unsubscribeDoc = function(collectionName, id, cb) {\n  cb = this.wrapCallback(cb);\n  var path = collectionName + '.' + id;\n  this._context.unsubscribeDoc(path, this._pass);\n  var subscribedDocs = this.root._subscribedDocs;\n\n  // No effect if the document is not currently subscribed\n  if (!subscribedDocs[path]) return cb();\n\n  var model = this;\n  if (this.root.unloadDelay && !this._pass.$query) {\n    setTimeout(finishUnsubscribeDoc, this.root.unloadDelay);\n  } else {\n    finishUnsubscribeDoc();\n  }\n  function finishUnsubscribeDoc() {\n    var count = --subscribedDocs[path];\n    // If there are more remaining subscriptions, only decrement the count\n    // and callback with how many subscriptions are remaining\n    if (count) return cb(null, count);\n\n    // If there is only one remaining subscription, actually unsubscribe\n    delete subscribedDocs[path];\n    if (model.root.fetchOnly) {\n      unsubscribeDocCallback();\n    } else {\n      var shareDoc = model.root.shareConnection.get(collectionName, id);\n      if (!shareDoc) {\n        return cb(new Error('Share document not found for: ' + path));\n      }\n      shareDoc.unsubscribe(unsubscribeDocCallback);\n    }\n  }\n  function unsubscribeDocCallback(err) {\n    model._maybeUnloadDoc(collectionName, id, path);\n    if (err) return cb(err);\n    cb(null, 0);\n  }\n};\n\n/**\n * Removes the document from the local model if the model no longer has any\n * remaining fetches or subscribes on path.\n * Called from Model.prototype.unfetchDoc and Model.prototype.unsubscribeDoc as\n * part of attempted cleanup.\n * @param {String} collectionName\n * @param {String} id\n * @param {String} path\n */\nModel.prototype._maybeUnloadDoc = function(collectionName, id, path) {\n  var doc = this.getDoc(collectionName, id);\n  if (!doc) return;\n  // Remove the document from the local model if it no longer has any\n  // remaining fetches or subscribes\n  if (this.root._fetchedDocs[path] || this.root._subscribedDocs[path]) return;\n  var previous = doc.get();\n  this.root.collections[collectionName].remove(id);\n\n  // Remove doc from memory in Share as well\n  if (doc.shareDoc) doc.shareDoc.destroy();\n\n  delete this.root._loadVersions[path];\n  this.emit('unload', [collectionName, id], [previous, this._pass]);\n};\n\n}).call(this,require(\"g5I+bs\"))","var Model = require('./Model');\n\nModel.prototype.unbundle = function(data) {\n  // Re-create and subscribe queries; re-create documents associated with queries\n  this._initQueries(data.queries);\n\n  // Re-create other documents\n  for (var collectionName in data.collections) {\n    var collection = data.collections[collectionName];\n    for (var id in collection) {\n      var doc = this.getOrCreateDoc(collectionName, id, collection[id]);\n      if (doc.shareDoc) {\n        this._loadVersions[collectionName + '.' + id] = doc.shareDoc.version;\n      }\n    }\n  }\n\n  for (var contextId in data.contexts) {\n    var contextData = data.contexts[contextId];\n    var contextModel = this.context(contextId);\n    // Re-init fetchedDocs counts\n    for (var path in contextData.fetchedDocs) {\n      contextModel._context.fetchDoc(path, contextModel._pass);\n      this._fetchedDocs[path] = (this._fetchedDocs[path] || 0) +\n        contextData.fetchedDocs[path];\n    }\n    // Subscribe to document subscriptions\n    for (var path in contextData.subscribedDocs) {\n      var subscribed = contextData.subscribedDocs[path];\n      while (subscribed--) {\n        contextModel.subscribe(path);\n      }\n    }\n  }\n\n  // Re-create refs\n  for (var i = 0; i < data.refs.length; i++) {\n    var item = data.refs[i];\n    this.ref(item[0], item[1]);\n  }\n  // Re-create refLists\n  for (var i = 0; i < data.refLists.length; i++) {\n    var item = data.refLists[i];\n    this.refList(item[0], item[1], item[2], item[3]);\n  }\n  // Re-create fns\n  for (var i = 0; i < data.fns.length; i++) {\n    var item = data.fns[i];\n    this.start.apply(this, item);\n  }\n  // Re-create filters\n  for (var i = 0; i < data.filters.length; i++) {\n    var item = data.filters[i];\n    var filter = this._filters.add(item[1], item[2], item[3], item[4], item[5]);\n    filter.ref(item[0]);\n  }\n};\n","var EventEmitter = require('events').EventEmitter;\nvar Model = require('./Model');\nvar util = require('./util');\n\nmodule.exports = Racer;\n\nfunction Racer() {\n  EventEmitter.call(this);\n}\n\nutil.mergeInto(Racer.prototype, EventEmitter.prototype);\n\n// Make classes accessible for use by plugins and tests\nRacer.prototype.Model = Model;\nRacer.prototype.util = util;\n\n// Support plugins on racer instances\nRacer.prototype.use = util.use;\nRacer.prototype.serverUse = util.serverUse;\n\nRacer.prototype.createModel = function(data) {\n  var model = new Model();\n  if (data) {\n    model.createConnection(data);\n    model.unbundle(data);\n  }\n  return model;\n};\n\nutil.serverRequire(module, './Racer.server');\n","var Racer = require('./Racer');\nmodule.exports = new Racer();\n","(function (process){\nvar deepIs = require('deep-is');\n\nvar isServer = process.title !== 'browser';\nexports.isServer = isServer;\n\nexports.asyncGroup = asyncGroup;\nexports.castSegments = castSegments;\nexports.contains = contains;\nexports.copy = copy;\nexports.copyObject = copyObject;\nexports.deepCopy = deepCopy;\nexports.deepEqual = deepIs;\nexports.equal = equal;\nexports.equalsNaN = equalsNaN;\nexports.isArrayIndex = isArrayIndex;\nexports.lookup = lookup;\nexports.mergeInto = mergeInto;\nexports.mayImpact = mayImpact;\nexports.mayImpactAny = mayImpactAny;\nexports.serverRequire = serverRequire;\nexports.serverUse = serverUse;\nexports.use = use;\n\nfunction asyncGroup(cb) {\n  var group = new AsyncGroup(cb);\n  return function asyncGroupAdd() {\n    return group.add();\n  };\n}\n\n/**\n * @constructor\n * @param {Function} cb(err)\n */\nfunction AsyncGroup(cb) {\n  this.cb = cb;\n  this.isDone = false;\n  this.count = 0;\n}\nAsyncGroup.prototype.add = function() {\n  this.count++;\n  var self = this;\n  return function(err) {\n    self.count--;\n    if (self.isDone) return;\n    if (err) {\n      self.isDone = true;\n      self.cb(err);\n      return;\n    }\n    if (self.count > 0) return;\n    self.isDone = true;\n    self.cb();\n  };\n};\n\nfunction castSegments(segments) {\n  // Cast number path segments from strings to numbers\n  for (var i = segments.length; i--;) {\n    var segment = segments[i];\n    if (typeof segment === 'string' && isArrayIndex(segment)) {\n      segments[i] = +segment;\n    }\n  }\n  return segments;\n}\n\nfunction contains(segments, testSegments) {\n  for (var i = 0; i < segments.length; i++) {\n    if (segments[i] !== testSegments[i]) return false;\n  }\n  return true;\n}\n\nfunction copy(value) {\n  if (value instanceof Date) return new Date(value);\n  if (typeof value === 'object') {\n    if (value === null) return null;\n    if (Array.isArray(value)) return value.slice();\n    return copyObject(value);\n  }\n  return value;\n}\n\nfunction copyObject(object) {\n  var out = new object.constructor();\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      out[key] = object[key];\n    }\n  }\n  return out;\n}\n\nfunction deepCopy(value) {\n  if (value instanceof Date) return new Date(value);\n  if (typeof value === 'object') {\n    if (value === null) return null;\n    if (Array.isArray(value)) {\n      var array = [];\n      for (var i = value.length; i--;) {\n        array[i] = deepCopy(value[i]);\n      }\n      return array;\n    }\n    var object = new value.constructor();\n    for (var key in value) {\n      if (value.hasOwnProperty(key)) {\n        object[key] = deepCopy(value[key]);\n      }\n    }\n    return object;\n  }\n  return value;\n}\n\nfunction equal(a, b) {\n  return (a === b) || (equalsNaN(a) && equalsNaN(b));\n}\n\nfunction equalsNaN(x) {\n  return x !== x;\n}\n\nfunction isArrayIndex(segment) {\n  return (/^[0-9]+$/).test(segment);\n}\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\nfunction mayImpactAny(segmentsList, testSegments) {\n  for (var i = 0, len = segmentsList.length; i < len; i++) {\n    if (mayImpact(segmentsList[i], testSegments)) return true;\n  }\n  return false;\n}\n\nfunction mayImpact(segments, testSegments) {\n  var len = Math.min(segments.length, testSegments.length);\n  for (var i = 0; i < len; i++) {\n    if (segments[i] !== testSegments[i]) return false;\n  }\n  return true;\n}\n\nfunction mergeInto(to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to;\n}\n\nfunction serverRequire(module, id) {\n  if (!isServer) return;\n  return module.require(id);\n}\n\nfunction serverUse(module, id, options) {\n  if (!isServer) return this;\n  var plugin = module.require(id);\n  return this.use(plugin, options);\n}\n\nfunction use(plugin, options) {\n  // Don't include a plugin more than once\n  var plugins = this._plugins || (this._plugins = []);\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(this, options);\n  }\n  return this;\n}\n\n}).call(this,require(\"g5I+bs\"))","if (typeof require === 'function') {\n  var serializeObject = require('serialize-object');\n}\n\n// UPDATE_PROPERTIES map HTML attribute names to an Element DOM property that\n// should be used for setting on bindings updates instead of s'test'Attribute.\n//\n// https://github.com/jquery/jquery/blob/1.x-master/src/attributes/prop.js\n// https://github.com/jquery/jquery/blob/master/src/attributes/prop.js\n// http://webbugtrack.blogspot.com/2007/08/bug-242-setattribute-doesnt-always-work.html\nvar UPDATE_PROPERTIES = {\n  checked: 'checked'\n, disabled: 'disabled'\n, selected: 'selected'\n, type: 'type'\n, value: 'value'\n, 'class': 'className'\n, 'for': 'htmlFor'\n, tabindex: 'tabIndex'\n, readonly: 'readOnly'\n, maxlength: 'maxLength'\n, cellspacing: 'cellSpacing'\n, cellpadding: 'cellPadding'\n, rowspan: 'rowSpan'\n, colspan: 'colSpan'\n, usemap: 'useMap'\n, frameborder: 'frameBorder'\n, contenteditable: 'contentEditable'\n, enctype: 'encoding'\n, id: 'id'\n, title: 'title'\n};\n// CREATE_PROPERTIES map HTML attribute names to an Element DOM property that\n// should be used for setting on Element rendering instead of setAttribute.\n// input.defaultChecked and input.defaultValue affect the attribute, so we want\n// to use these for initial dynamic rendering. For binding updates,\n// input.checked and input.value are modified.\nvar CREATE_PROPERTIES = {};\nmergeInto(UPDATE_PROPERTIES, CREATE_PROPERTIES);\nCREATE_PROPERTIES.checked = 'defaultChecked';\nCREATE_PROPERTIES.value = 'defaultValue';\n\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nvar VOID_ELEMENTS = {\n  area: true\n, base: true\n, br: true\n, col: true\n, embed: true\n, hr: true\n, img: true\n, input: true\n, keygen: true\n, link: true\n, menuitem: true\n, meta: true\n, param: true\n, source: true\n, track: true\n, wbr: true\n};\n\nvar NAMESPACE_URIS = {\n  svg: 'http://www.w3.org/2000/svg'\n, xlink: 'http://www.w3.org/1999/xlink'\n, xmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\nexports.CREATE_PROPERTIES = CREATE_PROPERTIES;\nexports.UPDATE_PROPERTIES = UPDATE_PROPERTIES;\nexports.VOID_ELEMENTS = VOID_ELEMENTS;\nexports.NAMESPACE_URIS = NAMESPACE_URIS;\n\n// Template Classes\nexports.Template = Template;\nexports.Doctype = Doctype;\nexports.Text = Text;\nexports.DynamicText = DynamicText;\nexports.Comment = Comment;\nexports.DynamicComment = DynamicComment;\nexports.Html = Html;\nexports.DynamicHtml = DynamicHtml;\nexports.Element = Element;\nexports.DynamicElement = DynamicElement;\nexports.Block = Block;\nexports.ConditionalBlock = ConditionalBlock;\nexports.EachBlock = EachBlock;\n\nexports.Attribute = Attribute;\nexports.DynamicAttribute = DynamicAttribute;\n\n// Binding Classes\nexports.Binding = Binding;\nexports.NodeBinding = NodeBinding;\nexports.AttributeBinding = AttributeBinding;\nexports.RangeBinding = RangeBinding;\n\nfunction Template(content, source) {\n  this.content = content;\n  this.source = source;\n}\nTemplate.prototype.toString = function() {\n  return this.source;\n};\nTemplate.prototype.get = function(context, unescaped) {\n  return contentHtml(this.content, context, unescaped);\n};\nTemplate.prototype.getFragment = function(context, binding) {\n  var fragment = document.createDocumentFragment();\n  this.appendTo(fragment, context, binding);\n  return fragment;\n};\nTemplate.prototype.appendTo = function(parent, context) {\n  context.pause();\n  appendContent(parent, this.content, context);\n  context.unpause();\n};\nTemplate.prototype.attachTo = function(parent, node, context) {\n  context.pause();\n  var node = attachContent(parent, node, this.content, context);\n  context.unpause();\n  return node;\n};\nTemplate.prototype.update = function() {};\nTemplate.prototype.stringify = function(value) {\n  return (value == null) ? '' : value + '';\n};\nTemplate.prototype.module = 'templates';\nTemplate.prototype.type = 'Template';\nTemplate.prototype.serialize = function() {\n  return serializeObject.instance(this, this.content, this.source);\n};\n\n\nfunction Doctype(name, publicId, systemId) {\n  this.name = name;\n  this.publicId = publicId;\n  this.systemId = systemId;\n}\nDoctype.prototype = new Template();\nDoctype.prototype.get = function() {\n  var publicText = (this.publicId) ?\n    ' PUBLIC \"' + this.publicId  + '\"' :\n    '';\n  var systemText = (this.systemId) ?\n    (this.publicId) ?\n      ' \"' + this.systemId + '\"' :\n      ' SYSTEM \"' + this.systemId + '\"' :\n    '';\n  return '<!DOCTYPE ' + this.name + publicText + systemText + '>';\n};\nDoctype.prototype.appendTo = function() {\n  // Doctype could be created via:\n  //   document.implementation.createDocumentType(this.name, this.publicId, this.systemId)\n  // However, it does not appear possible or useful to append it to the\n  // document fragment. Therefore, just don't render it in the browser\n};\nDoctype.prototype.attachTo = function(parent, node) {\n  if (!node || node.nodeType !== 10) {\n    throw attachError(parent, node);\n  }\n  return node.nextSibling;\n};\nDoctype.prototype.type = 'Doctype';\nDoctype.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.publicId, this.systemId);\n};\n\nfunction Text(data) {\n  this.data = data;\n  this.escaped = escapeHtml(data);\n}\nText.prototype = new Template();\nText.prototype.get = function(context, unescaped) {\n  return (unescaped) ? this.data : this.escaped;\n};\nText.prototype.appendTo = function(parent) {\n  var node = document.createTextNode(this.data);\n  parent.appendChild(node);\n};\nText.prototype.attachTo = function(parent, node) {\n  return attachText(parent, node, this.data, this);\n};\nText.prototype.type = 'Text';\nText.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\n\nfunction DynamicText(expression) {\n  this.expression = expression;\n}\nDynamicText.prototype = new Template();\nDynamicText.prototype.get = function(context, unescaped) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    do {\n      value = value.get(context, unescaped);\n    } while (value instanceof Template);\n    return value;\n  }\n  var data = this.stringify(value);\n  return (unescaped) ? data : escapeHtml(data);\n};\nDynamicText.prototype.appendTo = function(parent, context) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    value.appendTo(parent, context);\n    return;\n  }\n  var data = this.stringify(value);\n  var node = document.createTextNode(data);\n  parent.appendChild(node);\n  addNodeBinding(this, context, node);\n};\nDynamicText.prototype.attachTo = function(parent, node, context) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    return value.attachTo(parent, node, context);\n  }\n  var data = this.stringify(value);\n  return attachText(parent, node, data, this, context);\n};\nDynamicText.prototype.update = function(context, binding) {\n  binding.node.data = this.stringify(this.expression.get(context));\n};\nDynamicText.prototype.type = 'DynamicText';\nDynamicText.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression);\n};\n\nfunction attachText(parent, node, data, template, context) {\n  if (!node) {\n    var newNode = document.createTextNode(data);\n    parent.appendChild(newNode);\n    addNodeBinding(template, context, newNode);\n    return;\n  }\n  if (node.nodeType === 3) {\n    // Proceed if nodes already match\n    if (node.data === data) {\n      addNodeBinding(template, context, node);\n      return node.nextSibling;\n    }\n    data = normalizeLineBreaks(data);\n    // Split adjacent text nodes that would have been merged together in HTML\n    var nextNode = splitData(node, data.length);\n    if (node.data !== data) {\n      throw attachError(parent, node);\n    }\n    addNodeBinding(template, context, node);\n    return nextNode;\n  }\n  // An empty text node might not be created at the end of some text\n  if (data === '') {\n    var newNode = document.createTextNode('');\n    parent.insertBefore(newNode, node || null);\n    addNodeBinding(template, context, newNode);\n    return node;\n  }\n  throw attachError(parent, node);\n}\n\nfunction Comment(data, hooks) {\n  this.data = data;\n  this.hooks = hooks;\n}\nComment.prototype = new Template();\nComment.prototype.get = function() {\n  return '<!--' + this.data + '-->';\n};\nComment.prototype.appendTo = function(parent, context) {\n  var node = document.createComment(this.data);\n  parent.appendChild(node);\n  emitHooks(this.hooks, context, node);\n};\nComment.prototype.attachTo = function(parent, node, context) {\n  return attachComment(parent, node, this.data, this, context);\n};\nComment.prototype.type = 'Comment';\nComment.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data, this.hooks);\n}\n\nfunction DynamicComment(expression, hooks) {\n  this.expression = expression;\n  this.hooks = hooks;\n}\nDynamicComment.prototype = new Template();\nDynamicComment.prototype.get = function(context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  return '<!--' + data + '-->';\n};\nDynamicComment.prototype.appendTo = function(parent, context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  var node = document.createComment(data);\n  parent.appendChild(node);\n  addNodeBinding(this, context, node);\n};\nDynamicComment.prototype.attachTo = function(parent, node, context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  return attachComment(parent, node, data, this, context);\n};\nDynamicComment.prototype.update = function(context, binding) {\n  var value = getUnescapedValue(this.expression, context);\n  binding.node.data = this.stringify(value);\n};\nDynamicComment.prototype.type = 'DynamicComment';\nDynamicComment.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.hooks);\n}\n\nfunction attachComment(parent, node, data, template, context) {\n  // Sometimes IE fails to create Comment nodes from HTML or innerHTML.\n  // This is an issue inside of <select> elements, for example.\n  if (!node || node.nodeType !== 8) {\n    var newNode = document.createComment(data);\n    parent.insertBefore(newNode, node || null);\n    addNodeBinding(template, context, newNode);\n    return node;\n  }\n  // Proceed if nodes already match\n  if (node.data === data) {\n    addNodeBinding(template, context, node);\n    return node.nextSibling;\n  }\n  throw attachError(parent, node);\n}\n\nfunction addNodeBinding(template, context, node) {\n  if (template.expression) {\n    context.addBinding(new NodeBinding(template, context, node));\n  }\n  emitHooks(template.hooks, context, node);\n}\n\nfunction Html(data) {\n  this.data = data;\n}\nHtml.prototype = new Template();\nHtml.prototype.get = function() {\n  return this.data;\n};\nHtml.prototype.appendTo = function(parent) {\n  var fragment = createHtmlFragment(parent, this.data);\n  parent.appendChild(fragment);\n};\nHtml.prototype.attachTo = function(parent, node) {\n  return attachHtml(parent, node, this.data);\n};\nHtml.prototype.type = \"Html\";\nHtml.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\n\nfunction DynamicHtml(expression) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n}\nDynamicHtml.prototype = new Template();\nDynamicHtml.prototype.get = function(context) {\n  var value = getUnescapedValue(this.expression, context);\n  return this.stringify(value);\n};\nDynamicHtml.prototype.appendTo = function(parent, context, binding) {\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  var fragment = createHtmlFragment(parent, html);\n  parent.appendChild(start);\n  parent.appendChild(fragment);\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end);\n};\nDynamicHtml.prototype.attachTo = function(parent, node, context) {\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  parent.insertBefore(start, node || null);\n  node = attachHtml(parent, node, html);\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end);\n  return node;\n};\nDynamicHtml.prototype.update = function(context, binding) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  var fragment = createHtmlFragment(parent, html);\n  var innerOnly = true;\n  replaceRange(context, start, end, fragment, binding, innerOnly);\n};\nDynamicHtml.prototype.type = 'DynamicHtml';\nDynamicHtml.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression);\n};\n\nfunction createHtmlFragment(parent, html) {\n  if (parent && parent.nodeType === 1) {\n    var range = document.createRange();\n    range.selectNodeContents(parent);\n    return range.createContextualFragment(html);\n  }\n  var div = document.createElement('div');\n  var range = document.createRange();\n  div.innerHTML = html;\n  range.selectNodeContents(div);\n  return range.extractContents();\n}\nfunction attachHtml(parent, node, html) {\n  var fragment = createHtmlFragment(parent, html);\n  for (var i = 0, len = fragment.childNodes.length; i < len; i++) {\n    if (!node) throw attachError(parent, node);\n    node = node.nextSibling;\n  }\n  return node;\n}\n\nfunction Attribute(data, ns) {\n  this.data = data;\n  this.ns = ns;\n}\nAttribute.prototype.get = Attribute.prototype.getBound = function(context) {\n  return this.data;\n};\nAttribute.prototype.module = Template.prototype.module;\nAttribute.prototype.type = 'Attribute';\nAttribute.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data, this.ns);\n};\n\nfunction DynamicAttribute(expression, ns) {\n  // In attributes, expression may be an instance of Template or Expression\n  this.expression = expression;\n  this.ns = ns;\n  this.elementNs = null;\n}\nDynamicAttribute.prototype = new Attribute();\nDynamicAttribute.prototype.get = function(context) {\n  return getUnescapedValue(this.expression, context);\n};\nDynamicAttribute.prototype.getBound = function(context, element, name, elementNs) {\n  this.elementNs = elementNs;\n  context.addBinding(new AttributeBinding(this, context, element, name));\n  return getUnescapedValue(this.expression, context);\n};\nDynamicAttribute.prototype.update = function(context, binding) {\n  var value = getUnescapedValue(this.expression, context);\n  var element = binding.element;\n  var propertyName = !this.elementNs && UPDATE_PROPERTIES[binding.name];\n  if (propertyName) {\n    if (propertyName === 'value' && (element.value === value || element.valueAsNumber === value)) return;\n    if (value === void 0) value = null;\n    element[propertyName] = value;\n    return;\n  }\n  if (value === false || value == null) {\n    if (this.ns) {\n      element.removeAttributeNS(this.ns, binding.name);\n    } else {\n      element.removeAttribute(binding.name);\n    }\n    return;\n  }\n  if (value === true) value = binding.name;\n  if (this.ns) {\n    element.setAttributeNS(this.ns, binding.name, value);\n  } else {\n    element.setAttribute(binding.name, value);\n  }\n};\nDynamicAttribute.prototype.type = 'DynamicAttribute';\nDynamicAttribute.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.ns);\n};\n\nfunction getUnescapedValue(expression, context) {\n  var unescaped = true;\n  var value = expression.get(context, unescaped);\n  while (value instanceof Template) {\n    value = value.get(context, unescaped);\n  }\n  return value;\n}\n\nfunction Element(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {\n  this.tagName = tagName;\n  this.attributes = attributes;\n  this.content = content;\n  this.hooks = hooks;\n  this.selfClosing = selfClosing;\n  this.notClosed = notClosed;\n  this.ns = ns;\n\n  this.endTag = getEndTag(tagName, selfClosing, notClosed);\n  this.startClose = getStartClose(selfClosing);\n  var lowerTagName = tagName && tagName.toLowerCase();\n  this.unescapedContent = (lowerTagName === 'script' || lowerTagName === 'style');\n}\nElement.prototype = new Template();\nElement.prototype.getTagName = function() {\n  return this.tagName;\n};\nElement.prototype.getEndTag = function() {\n  return this.endTag;\n};\nElement.prototype.get = function(context) {\n  var tagName = this.getTagName(context);\n  var endTag = this.getEndTag(tagName);\n  var tagItems = [tagName];\n  for (var key in this.attributes) {\n    var value = this.attributes[key].get(context);\n    if (value === true) {\n      tagItems.push(key);\n    } else if (value !== false && value != null) {\n      tagItems.push(key + '=\"' + escapeAttribute(value) + '\"');\n    }\n  }\n  var startTag = '<' + tagItems.join(' ') + this.startClose;\n  if (this.content) {\n    var inner = contentHtml(this.content, context, this.unescapedContent);\n    return startTag + inner + endTag;\n  }\n  return startTag + endTag;\n};\nElement.prototype.appendTo = function(parent, context) {\n  var tagName = this.getTagName(context);\n  var element = (this.ns) ?\n    document.createElementNS(this.ns, tagName) :\n    document.createElement(tagName);\n  for (var key in this.attributes) {\n    var attribute = this.attributes[key];\n    var value = attribute.getBound(context, element, key, this.ns);\n    if (value === false || value == null) continue;\n    var propertyName = !this.ns && CREATE_PROPERTIES[key];\n    if (propertyName) {\n      element[propertyName] = value;\n      continue;\n    }\n    if (value === true) value = key;\n    if (attribute.ns) {\n      element.setAttributeNS(attribute.ns, key, value);\n    } else {\n      element.setAttribute(key, value);\n    }\n  }\n  if (this.content) appendContent(element, this.content, context);\n  parent.appendChild(element);\n  emitHooks(this.hooks, context, element);\n};\nElement.prototype.attachTo = function(parent, node, context) {\n  var tagName = this.getTagName(context);\n  if (\n    !node ||\n    node.nodeType !== 1 ||\n    node.tagName.toLowerCase() !== tagName.toLowerCase()\n  ) {\n    throw attachError(parent, node);\n  }\n  for (var key in this.attributes) {\n    // Get each attribute to create bindings\n    this.attributes[key].getBound(context, node, key, this.ns);\n    // TODO: Ideally, this would also check that the node's current attributes\n    // are equivalent, but there are some tricky edge cases\n  }\n  if (this.content) attachContent(node, node.firstChild, this.content, context);\n  emitHooks(this.hooks, context, node);\n  return node.nextSibling;\n};\nElement.prototype.type = 'Element';\nElement.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.tagName\n  , this.attributes\n  , this.content\n  , this.hooks\n  , this.selfClosing\n  , this.notClosed\n  , this.ns\n  );\n};\n\nfunction DynamicElement(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {\n  this.tagName = tagName;\n  this.attributes = attributes;\n  this.content = content;\n  this.hooks = hooks;\n  this.selfClosing = selfClosing;\n  this.notClosed = notClosed;\n  this.ns = ns;\n\n  this.startClose = getStartClose(selfClosing);\n  this.unescapedContent = false;\n}\nDynamicElement.prototype = new Element();\nDynamicElement.prototype.getTagName = function(context) {\n  return getUnescapedValue(this.tagName, context);\n};\nDynamicElement.prototype.getEndTag = function(tagName) {\n  return getEndTag(tagName, this.selfClosing, this.notClosed);\n};\nDynamicElement.prototype.type = 'DynamicElement';\n\nfunction getStartClose(selfClosing) {\n  return (selfClosing) ? ' />' : '>';\n}\n\nfunction getEndTag(tagName, selfClosing, notClosed) {\n  var lowerTagName = tagName && tagName.toLowerCase();\n  var isVoid = VOID_ELEMENTS[lowerTagName];\n  return (isVoid || selfClosing || notClosed) ? '' : '</' + tagName + '>';\n}\n\nfunction getAttributeValue(element, name) {\n  var propertyName = UPDATE_PROPERTIES[name];\n  return (propertyName) ? element[propertyName] : element.getAttribute(name);\n}\n\nfunction emitHooks(hooks, context, value) {\n  if (!hooks) return;\n  context.queue(function queuedHooks() {\n    for (var i = 0, len = hooks.length; i < len; i++) {\n      hooks[i].emit(context, value);\n    }\n  });\n}\n\nfunction Block(expression, content) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n  this.content = content;\n}\nBlock.prototype = new Template();\nBlock.prototype.get = function(context, unescaped) {\n  var blockContext = context.child(this.expression);\n  return contentHtml(this.content, blockContext, unescaped);\n};\nBlock.prototype.appendTo = function(parent, context, binding) {\n  var blockContext = context.child(this.expression);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var condition = this.getCondition(context);\n  parent.appendChild(start);\n  appendContent(parent, this.content, blockContext);\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end, null, condition);\n};\nBlock.prototype.attachTo = function(parent, node, context) {\n  var blockContext = context.child(this.expression);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var condition = this.getCondition(context);\n  parent.insertBefore(start, node || null);\n  node = attachContent(parent, node, this.content, blockContext);\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end, null, condition);\n  return node;\n};\nBlock.prototype.type = 'Block';\nBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.content);\n};\nBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var condition = this.getCondition(context);\n  if (condition === binding.condition) return;\n  binding.condition = condition;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var fragment = this.getFragment(context, binding);\n  replaceRange(context, start, end, fragment, binding);\n};\nBlock.prototype.getCondition = function(context) {\n  // We do an identity check to see if the value has changed before updating.\n  // With objects, the object would still be the same, so this identity check\n  // would fail to update enough. Thus, return NaN, which never equals anything\n  // including itself, so that we always update on objects.\n  //\n  // We could also JSON stringify or use some other hashing approach. However,\n  // that could be really expensive on gets of things that never change, and\n  // is probably not a good tradeoff. Perhaps there should be a separate block\n  // type that is only used in the case of dynamic updates\n  var value = this.expression.get(context);\n  return (typeof value === 'object') ? NaN : value;\n};\n\nfunction ConditionalBlock(expressions, contents) {\n  this.expressions = expressions;\n  this.beginning = expressions.join('; ');\n  this.ending = '/' + this.beginning;\n  this.contents = contents;\n}\nConditionalBlock.prototype = new Block();\nConditionalBlock.prototype.get = function(context, unescaped) {\n  var condition = this.getCondition(context);\n  if (condition == null) return '';\n  var expression = this.expressions[condition];\n  var blockContext = context.child(expression);\n  return contentHtml(this.contents[condition], blockContext, unescaped);\n};\nConditionalBlock.prototype.appendTo = function(parent, context, binding) {\n  var start = document.createComment(this.beginning);\n  var end = document.createComment(this.ending);\n  parent.appendChild(start);\n  var condition = this.getCondition(context);\n  if (condition != null) {\n    var expression = this.expressions[condition];\n    var blockContext = context.child(expression);\n    appendContent(parent, this.contents[condition], blockContext);\n  }\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end, null, condition);\n};\nConditionalBlock.prototype.attachTo = function(parent, node, context) {\n  var start = document.createComment(this.beginning);\n  var end = document.createComment(this.ending);\n  parent.insertBefore(start, node || null);\n  var condition = this.getCondition(context);\n  if (condition != null) {\n    var expression = this.expressions[condition];\n    var blockContext = context.child(expression);\n    node = attachContent(parent, node, this.contents[condition], blockContext);\n  }\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end, null, condition);\n  return node;\n};\nConditionalBlock.prototype.type = 'ConditionalBlock';\nConditionalBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expressions, this.contents);\n};\nConditionalBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var condition = this.getCondition(context);\n  if (condition === binding.condition) return;\n  binding.condition = condition;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var fragment = this.getFragment(context, binding);\n  replaceRange(context, start, end, fragment, binding);\n};\nConditionalBlock.prototype.getCondition = function(context) {\n  for (var i = 0, len = this.expressions.length; i < len; i++) {\n    if (this.expressions[i].truthy(context)) {\n      return i;\n    }\n  }\n};\n\nfunction EachBlock(expression, content, elseContent) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n  this.content = content;\n  this.elseContent = elseContent;\n}\nEachBlock.prototype = new Block();\nEachBlock.prototype.get = function(context, unescaped) {\n  var items = this.expression.get(context);\n  if (items && items.length) {\n    var html = '';\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      html += contentHtml(this.content, itemContext, unescaped);\n    }\n    return html;\n  } else if (this.elseContent) {\n    return contentHtml(this.elseContent, context, unescaped);\n  }\n  return '';\n};\nEachBlock.prototype.appendTo = function(parent, context, binding) {\n  var items = this.expression.get(context);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  parent.appendChild(start);\n  if (items && items.length) {\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      this.appendItemTo(parent, itemContext, start);\n    }\n  } else if (this.elseContent) {\n    appendContent(parent, this.elseContent, context);\n  }\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end);\n};\nEachBlock.prototype.appendItemTo = function(parent, context, itemFor, binding) {\n  var before = parent.lastChild;\n  var start, end;\n  appendContent(parent, this.content, context);\n  if (before === parent.lastChild) {\n    start = end = document.createComment('empty');\n    parent.appendChild(start);\n  } else {\n    start = (before && before.nextSibling) || parent.firstChild;\n    end = parent.lastChild;\n  }\n  updateRange(context, binding, this, start, end, itemFor);\n};\nEachBlock.prototype.attachTo = function(parent, node, context) {\n  var items = this.expression.get(context);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  parent.insertBefore(start, node || null);\n  if (items && items.length) {\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      node = this.attachItemTo(parent, node, itemContext, start);\n    }\n  } else if (this.elseContent) {\n    node = attachContent(parent, node, this.elseContent, context);\n  }\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end);\n  return node;\n};\nEachBlock.prototype.attachItemTo = function(parent, node, context, itemFor) {\n  var start, end;\n  var oldPrevious = node && node.previousSibling;\n  var nextNode = attachContent(parent, node, this.content, context);\n  if (nextNode === node) {\n    start = end = document.createComment('empty');\n    parent.insertBefore(start, node || null);\n  } else {\n    start = (oldPrevious && oldPrevious.nextSibling) || parent.firstChild;\n    end = (nextNode && nextNode.previousSibling) || parent.lastChild;\n  }\n  updateRange(context, null, this, start, end, itemFor);\n  return nextNode;\n};\nEachBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var start = binding.start;\n  var end = binding.end;\n  if (binding.itemFor) {\n    var fragment = document.createDocumentFragment();\n    this.appendItemTo(fragment, context, binding.itemFor, binding);\n  } else {\n    var fragment = this.getFragment(context, binding);\n  }\n  replaceRange(context, start, end, fragment, binding);\n};\nEachBlock.prototype.insert = function(context, binding, index, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // In case we are inserting all of the items, update instead. This is needed\n  // when we were previously rendering elseContent so that it is replaced\n  if (index === 0 && this.expression.get(context).length === howMany) {\n    return this.update(context, binding);\n  }\n  var node = indexStartNode(binding, index);\n  var fragment = document.createDocumentFragment();\n  for (var i = index, len = index + howMany; i < len; i++) {\n    var itemContext = context.eachChild(this.expression, i);\n    this.appendItemTo(fragment, itemContext, binding.start);\n  }\n  parent.insertBefore(fragment, node || null);\n};\nEachBlock.prototype.remove = function(context, binding, index, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // In case we are removing all of the items, update instead. This is needed\n  // when elseContent should be rendered\n  if (index === 0 && this.expression.get(context).length === 0) {\n    return this.update(context, binding);\n  }\n  var node = indexStartNode(binding, index);\n  var i = 0;\n  while (node) {\n    if (node === binding.end) return;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (howMany === i++) return;\n    }\n    var nextNode = node.nextSibling;\n    parent.removeChild(node);\n    emitRemoved(context, node, binding);\n    node = nextNode;\n  }\n};\nEachBlock.prototype.move = function(context, binding, from, to, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  var node = indexStartNode(binding, from);\n  var fragment = document.createDocumentFragment();\n  var i = 0;\n  while (node) {\n    if (node === binding.end) break;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (howMany === i++) break;\n    }\n    var nextNode = node.nextSibling;\n    fragment.appendChild(node);\n    node = nextNode;\n  }\n  node = indexStartNode(binding, to);\n  parent.insertBefore(fragment, node || null);\n};\nEachBlock.prototype.type = 'EachBlock';\nEachBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.content, this.elseContent);\n};\n\nfunction indexStartNode(binding, index) {\n  var node = binding.start;\n  var i = 0;\n  while (node = node.nextSibling) {\n    if (node === binding.end) return node;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (index === i) return node;\n      i++;\n    }\n  }\n}\n\nfunction updateRange(context, binding, template, start, end, itemFor, condition) {\n  if (binding) {\n    binding.start = start;\n    binding.end = end;\n    binding.condition = condition;\n    setNodeBounds(binding, start, itemFor);\n  } else {\n    context.addBinding(new RangeBinding(template, context, start, end, itemFor, condition));\n  }\n}\nfunction setNodeBounds(binding, start, itemFor) {\n  if (itemFor) {\n    setNodeProperty(start, '$bindItemStart', binding);\n  } else {\n    setNodeProperty(start, '$bindStart', binding);\n  }\n}\n\nfunction appendContent(parent, content, context) {\n  for (var i = 0, len = content.length; i < len; i++) {\n    content[i].appendTo(parent, context);\n  }\n}\nfunction attachContent(parent, node, content, context) {\n  for (var i = 0, len = content.length; i < len; i++) {\n    node = content[i].attachTo(parent, node, context);\n  }\n  return node;\n}\nfunction contentHtml(content, context, unescaped) {\n  var html = '';\n  for (var i = 0, len = content.length; i < len; i++) {\n    html += content[i].get(context, unescaped);\n  }\n  return html;\n}\nfunction replaceRange(context, start, end, fragment, binding, innerOnly) {\n  // Note: the calling function must make sure to check that there is a parent\n  var parent = start.parentNode;\n  // Copy item binding from old start to fragment being inserted\n  if (start.$bindItemStart && fragment.firstChild) {\n    setNodeProperty(fragment.firstChild, '$bindItemStart', start.$bindItemStart);\n    start.$bindItemStart.start = fragment.firstChild;\n  }\n  // Fast path for single node replacements\n  if (start === end) {\n    parent.replaceChild(fragment, start);\n    emitRemoved(context, start, binding);\n    return;\n  }\n  // Remove all nodes from start to end\n  var node = (innerOnly) ? start.nextSibling : start;\n  var nextNode;\n  while (node) {\n    nextNode = node.nextSibling;\n    emitRemoved(context, node, binding);\n    if (innerOnly && node === end) {\n      nextNode = end;\n      break;\n    }\n    parent.removeChild(node);\n    if (node === end) break;\n    node = nextNode;\n  }\n  // This also works if nextNode is null, by doing an append\n  parent.insertBefore(fragment, nextNode || null);\n}\nfunction emitRemoved(context, node, ignore) {\n  context.removeNode(node);\n  emitRemovedBinding(context, ignore, node.$bindNode);\n  emitRemovedBinding(context, ignore, node.$bindStart);\n  emitRemovedBinding(context, ignore, node.$bindItemStart);\n  var attributes = node.$bindAttributes;\n  if (attributes) {\n    for (var key in attributes) {\n      context.removeBinding(attributes[key]);\n    }\n  }\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    emitRemoved(context, node, ignore);\n  }\n}\nfunction emitRemovedBinding(context, ignore, binding) {\n  if (binding && binding !== ignore) {\n    context.removeBinding(binding);\n  }\n}\n\nfunction attachError(parent, node) {\n  if (typeof console !== 'undefined') {\n    console.error('Attach failed for', node, 'within', parent);\n  }\n  return new Error('Attaching bindings failed, because HTML structure ' +\n    'does not match client rendering.'\n  );\n}\n\nfunction Binding() {\n  this.meta = null;\n}\nBinding.prototype.type = 'Binding';\nBinding.prototype.update = function() {\n  this.context.pause();\n  this.template.update(this.context, this);\n  this.context.unpause();\n};\nBinding.prototype.insert = function() {\n  this.update();\n};\nBinding.prototype.remove = function() {\n  this.update();\n};\nBinding.prototype.move = function() {\n  this.update();\n};\n\nfunction NodeBinding(template, context, node) {\n  this.template = template;\n  this.context = context;\n  this.node = node;\n  this.meta = null;\n  setNodeProperty(node, '$bindNode', this);\n}\nNodeBinding.prototype = new Binding();\nNodeBinding.prototype.type = 'NodeBinding';\n\nfunction AttributeBindingsMap() {}\nfunction AttributeBinding(template, context, element, name) {\n  this.template = template;\n  this.context = context;\n  this.element = element;\n  this.name = name;\n  this.meta = null;\n  var map = element.$bindAttributes ||\n    (element.$bindAttributes = new AttributeBindingsMap());\n  map[name] = this;\n}\nAttributeBinding.prototype = new Binding();\nAttributeBinding.prototype.type = 'AttributeBinding';\n\nfunction RangeBinding(template, context, start, end, itemFor, condition) {\n  this.template = template;\n  this.context = context;\n  this.start = start;\n  this.end = end;\n  this.itemFor = itemFor;\n  this.condition = condition;\n  this.meta = null;\n  setNodeBounds(this, start, itemFor);\n}\nRangeBinding.prototype = new Binding();\nRangeBinding.prototype.type = 'RangeBinding';\nRangeBinding.prototype.insert = function(index, howMany) {\n  this.context.pause();\n  if (this.template.insert) {\n    this.template.insert(this.context, this, index, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\nRangeBinding.prototype.remove = function(index, howMany) {\n  this.context.pause();\n  if (this.template.remove) {\n    this.template.remove(this.context, this, index, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\nRangeBinding.prototype.move = function(from, to, howMany) {\n  this.context.pause();\n  if (this.template.move) {\n    this.template.move(this.context, this, from, to, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\n\n\n//// Utility functions ////\n\nfunction noop() {}\n\nfunction mergeInto(from, to) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n}\n\nfunction escapeHtml(string) {\n  string = string + '';\n  return string.replace(/[&<]/g, function(match) {\n    return (match === '&') ? '&amp;' : '&lt;';\n  });\n}\n\nfunction escapeAttribute(string) {\n  string = string + '';\n  return string.replace(/[&\"]/g, function(match) {\n    return (match === '&') ? '&amp;' : '&quot;';\n  });\n}\n\n\n//// Shims & workarounds ////\n\n// General notes:\n//\n// In all cases, Node.insertBefore should have `|| null` after its second\n// argument. IE works correctly when the argument is ommitted or equal\n// to null, but it throws and error if it is equal to undefined.\n\nif (!Array.isArray) {\n  Array.isArray = function(value) {\n    return Object.prototype.toString.call(value) === '[object Array]';\n  };\n}\n\n// Equivalent to textNode.splitText, which is buggy in IE <=9\nfunction splitData(node, index) {\n  var newNode = node.cloneNode(false);\n  newNode.deleteData(0, index);\n  node.deleteData(index, node.length - index);\n  node.parentNode.insertBefore(newNode, node.nextSibling || null);\n  return newNode;\n}\n\n// Defined so that it can be overriden in IE <=8\nfunction setNodeProperty(node, key, value) {\n  return node[key] = value;\n}\n\nfunction normalizeLineBreaks(string) {\n  return string;\n}\n\n(function() {\n  // Don't try to shim in Node.js environment\n  if (typeof document === 'undefined') return;\n\n  var div = document.createElement('div');\n  div.innerHTML = '\\r\\n<br>\\n'\n  var windowsLength = div.firstChild.data.length;\n  var unixLength = div.lastChild.data.length;\n  if (windowsLength === 1 && unixLength === 1) {\n    normalizeLineBreaks = function(string) {\n      return string.replace(/\\r\\n/g, '\\n');\n    };\n  } else if (windowsLength === 2 && unixLength === 2) {\n    normalizeLineBreaks = function(string) {\n      return string.replace(/(^|[^\\r])(\\n+)/g, function(match, value, newLines) {\n        for (var i = newLines.length; i--;) {\n          value += '\\r\\n';\n        }\n        return value;\n      });\n    };\n  }\n\n  // TODO: Shim createHtmlFragment for old IE\n\n  // TODO: Shim setAttribute('style'), which doesn't work in IE <=7\n  // http://webbugtrack.blogspot.com/2007/10/bug-245-setattribute-style-does-not.html\n\n  // TODO: Investigate whether input name attribute works in IE <=7. We could\n  // override Element::appendTo to use IE's alternative createElement syntax:\n  // document.createElement('<input name=\"xxx\">')\n  // http://webbugtrack.blogspot.com/2007/10/bug-235-createelement-is-broken-in-ie.html\n\n  // In IE, input.defaultValue doesn't work correctly, so use input.value,\n  // which mistakenly but conveniently sets both the value property and attribute.\n  //\n  // Surprisingly, in IE <=7, input.defaultChecked must be used instead of\n  // input.checked before the input is in the document.\n  // http://webbugtrack.blogspot.com/2007/11/bug-299-setattribute-checked-does-not.html\n  var input = document.createElement('input');\n  input.defaultValue = 'x';\n  if (input.value !== 'x') {\n    CREATE_PROPERTIES.value = 'value';\n  }\n\n  try {\n    // TextNodes are not expando in IE <=8\n    document.createTextNode('').$try = 0;\n  } catch (err) {\n    setNodeProperty = function(node, key, value) {\n      // If trying to set a property on a TextNode, create a proxy CommentNode\n      // and set the property on that node instead. Put the proxy after the\n      // TextNode if marking the end of a range, and before otherwise.\n      if (node.nodeType === 3) {\n        var proxyNode = node.previousSibling;\n        if (!proxyNode || proxyNode.$bindProxy !== node) {\n          proxyNode = document.createComment('proxy');\n          proxyNode.$bindProxy = node;\n          node.parentNode.insertBefore(proxyNode, node || null);\n        }\n        return proxyNode[key] = value;\n      }\n      // Set the property directly on other node types\n      return node[key] = value;\n    };\n  }\n})();\n","exports.instance = serializeInstance;\nexports.args = serializeArgs;\nexports.value = serializeValue;\n\nfunction serializeInstance(instance) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return 'new ' + instance.module + '.' + instance.type +\n    '(' + serializeArgs(args) + ')';\n}\n\nfunction serializeArgs(args) {\n  // Map each argument into its string representation\n  var items = [];\n  for (var i = args.length; i--;) {\n    var item = serializeValue(args[i]);\n    items.unshift(item);\n  }\n  // Remove trailing null values, assuming they are optional\n  for (var i = items.length; i--;) {\n    var item = items[i];\n    if (item !== 'void 0' && item !== 'null') break;\n    items.pop();\n  }\n  return items.join(', ');\n}\n\nfunction serializeValue(input) {\n  if (input && input.serialize) {\n    return input.serialize();\n\n  } else if (typeof input === 'undefined') {\n    return 'void 0';\n\n  } else if (input === null) {\n    return 'null';\n\n  } else if (typeof input === 'string') {\n    return formatString(input);\n\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return input + '';\n\n  } else if (Array.isArray(input)) {\n    var items = [];\n    for (var i = 0; i < input.length; i++) {\n      var value = serializeValue(input[i]);\n      items.push(value);\n    }\n    return '[' + items.join(', ') + ']';\n\n  } else if (typeof input === 'object') {\n    var items = [];\n    for (var key in input) {\n      var value = serializeValue(input[key]);\n      items.push(formatString(key) + ': ' + value);\n    }\n    return '{' + items.join(', ') + '}';\n  }\n}\nfunction formatString(value) {\n  var escaped = value.replace(/['\\r\\n\\\\]/g, function(match) {\n    return (match === '\\'') ? '\\\\\\'' :\n      (match === '\\r') ? '\\\\r' :\n      (match === '\\n') ? '\\\\n' :\n      (match === '\\\\') ? '\\\\\\\\' :\n      '';\n  });\n  return '\\'' + escaped + '\\'';\n}\n","var Doc = require('./doc').Doc;\nvar Query = require('./query').Query;\nvar emitter = require('./emitter');\n\n\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\nvar Connection = exports.Connection = function (socket) {\n  emitter.EventEmitter.call(this);\n\n  // Map of collection -> docName -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n  this.collections = {};\n\n  // Each query is created with an id that the server uses when it sends us\n  // info about the query (updates, etc).\n  //this.nextQueryId = (Math.random() * 1000) |0;\n  this.nextQueryId = 1;\n\n  // Map from query ID -> query object.\n  this.queries = {};\n\n  // State of the connection. The correspoding events are emmited when this\n  // changes. Available states are:\n  // - 'connecting'   The connection has been established, but we don't have our\n  //                  client ID yet\n  // - 'connected'    We have connected and recieved our client ID. Ready for data.\n  // - 'disconnected' The connection is closed, but it will reconnect automatically.\n  // - 'stopped'      The connection is closed, and should not reconnect.\n  this.state = 'disconnected';\n\n  // This is a helper variable the document uses to see whether we're currently\n  // in a 'live' state. It is true if we're connected, or if you're using\n  // browserchannel and connecting.\n  this.canSend = false;\n\n  // Private variable to support clearing of op retry interval\n  this._retryInterval = null;\n\n  // Reset some more state variables.\n  this.reset();\n\n  this.debug = false;\n\n  // I'll store the most recent 100 messages so when errors occur we can see\n  // what happened.\n  this.messageBuffer = [];\n\n  this.bindToSocket(socket);\n}\nemitter.mixin(Connection);\n\n\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(msg). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\nConnection.prototype.bindToSocket = function(socket) {\n  if (this.socket) {\n    delete this.socket.onopen\n    delete this.socket.onclose\n    delete this.socket.onmessage\n    delete this.socket.onerror\n  }\n\n  // TODO: Check that the socket is in the 'connecting' state.\n\n  this.socket = socket;\n  // This logic is replicated in setState - consider calling setState here\n  // instead.\n  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';\n  this.canSend = this.state === 'connecting' && socket.canSendWhileConnecting;\n  this._setupRetry();\n\n  var connection = this\n\n  socket.onmessage = function(msg) {\n    var data = msg.data;\n\n    // Fall back to supporting old browserchannel 1.x API which implemented the\n    // websocket API incorrectly. This will be removed at some point\n    if (!data) data = msg;\n\n    // Some transports don't need parsing.\n    if (typeof data === 'string') data = JSON.parse(data);\n\n    if (connection.debug) console.log('RECV', JSON.stringify(data));\n\n    connection.messageBuffer.push({\n      t: (new Date()).toTimeString(),\n      recv:JSON.stringify(data)\n    });\n    while (connection.messageBuffer.length > 100) {\n      connection.messageBuffer.shift();\n    }\n\n    try {\n      connection.handleMessage(data);\n    } catch (err) {\n      connection.emit('error', err, data);\n      // We could also restart the connection here, although that might result\n      // in infinite reconnection bugs.\n    }\n  }\n\n  socket.onopen = function() {\n    connection._setState('connecting');\n  };\n\n  socket.onerror = function(e) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', e);\n  };\n\n  socket.onclose = function(reason) {\n    // reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n    connection._setState('disconnected', reason);\n    if (reason === 'Closed' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n    }\n  };\n};\n\n\n/**\n * @param {object} msg\n * @param {String} msg.a action\n */\nConnection.prototype.handleMessage = function(msg) {\n  // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n  switch (msg.a) {\n    case 'init':\n      // Client initialization packet. This bundle of joy contains our client\n      // ID.\n      if (msg.protocol !== 0) throw new Error('Invalid protocol version');\n      if (typeof msg.id != 'string') throw new Error('Invalid client id');\n\n      this.id = msg.id;\n      this._setState('connected');\n      break;\n\n    case 'qfetch':\n    case 'qsub':\n    case 'q':\n    case 'qunsub':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[msg.id];\n      if (query) query._onMessage(msg);\n      break;\n\n    case 'bs':\n      // Bulk subscribe response. The responses for each document are contained within.\n      var result = msg.s;\n      for (var cName in result) {\n        for (var docName in result[cName]) {\n          var doc = this.get(cName, docName);\n          if (!doc) {\n            console.warn('Message for unknown doc. Ignoring.', msg);\n            break;\n          }\n\n          var msg = result[cName][docName];\n          if (typeof msg === 'object') {\n            doc._handleSubscribe(msg.error, msg);\n          } else {\n            // The msg will be true if we simply resubscribed.\n            doc._handleSubscribe(null, null);\n          }\n        }\n      }\n      break;\n\n    default:\n      // Document message. Pull out the referenced document and forward the\n      // message.\n      var doc = this.getExisting(msg.c, msg.d);\n      if (doc) doc._onMessage(msg);\n  }\n};\n\n\nConnection.prototype.reset = function() {\n  this.id = null;\n  this.seq = 1;\n};\n\n\nConnection.prototype._setupRetry = function() {\n  if (!this.canSend) {\n    clearInterval(this._retryInterval);\n    this._retryInterval = null;\n    return;\n  }\n  if (this._retryInterval != null) return;\n\n  var connection = this;\n  this._retryInterval = setInterval(function() {\n    for (var collectionName in connection.collections) {\n      var collection = connection.collections[collectionName];\n      for (var docName in collection) {\n        collection[docName].retry();\n      }\n    }\n  }, 1000);\n};\n\n\n// Set the connection's state. The connection is basically a state machine.\nConnection.prototype._setState = function(newState, data) {\n  if (this.state === newState) return;\n\n  // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n  if (\n    (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped') ||\n    (newState === 'connected' && this.state !== 'connecting')\n  ) {\n    throw new Error(\"Cannot transition directly from \" + this.state + \" to \" + newState);\n  }\n\n  this.state = newState;\n  this.canSend =\n    (newState === 'connecting' && this.socket.canSendWhileConnecting) ||\n    (newState === 'connected');\n  this._setupRetry();\n\n  if (newState === 'disconnected') this.reset();\n\n  this.emit(newState, data);\n\n  // Group all subscribes together to help server make more efficient calls\n  this.bsStart();\n  // Emit the event to all queries\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    query._onConnectionStateChanged(newState, data);\n  }\n  // Emit the event to all documents\n  for (var c in this.collections) {\n    var collection = this.collections[c];\n    for (var docName in collection) {\n      collection[docName]._onConnectionStateChanged(newState, data);\n    }\n  }\n  this.bsEnd();\n};\n\nConnection.prototype.bsStart = function() {\n  this.subscribeData = this.subscribeData || {};\n};\n\nConnection.prototype.bsEnd = function() {\n  // Only send bulk subscribe if not empty\n  if (hasKeys(this.subscribeData)) {\n    this.send({a:'bs', s:this.subscribeData});\n  }\n  this.subscribeData = null;\n};\n\nConnection.prototype.sendSubscribe = function(doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  if (this.subscribeData) {\n    // Bulk subscribe\n    var data = this.subscribeData;\n    if (!data[doc.collection]) data[doc.collection] = {};\n    data[doc.collection][doc.name] = version || null;\n  } else {\n    // Send single subscribe message\n    var msg = {a: 'sub', c: doc.collection, d: doc.name};\n    if (version != null) msg.v = version;\n    this.send(msg);\n  }\n};\n\nConnection.prototype.sendFetch = function(doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var msg = {a: 'fetch', c: doc.collection, d: doc.name};\n  if (version != null) msg.v = version;\n  this.send(msg);\n};\n\nConnection.prototype.sendUnsubscribe = function(doc) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var msg = {a: 'unsub', c: doc.collection, d: doc.name};\n  this.send(msg);\n};\n\nConnection.prototype.sendOp = function(doc, data) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var msg = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.name,\n    v: doc.version,\n    src: data.src,\n    seq: data.seq\n  };\n  if (data.op) msg.op = data.op;\n  if (data.create) msg.create = data.create;\n  if (data.del) msg.del = data.del;\n  this.send(msg);\n};\n\n\n/**\n * Sends a message down the socket\n */\nConnection.prototype.send = function(msg) {\n  if (this.debug) console.log(\"SEND\", JSON.stringify(msg));\n\n  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});\n  while (this.messageBuffer.length > 100) {\n    this.messageBuffer.shift();\n  }\n\n  if (!this.socket.canSendJSON) {\n    msg = JSON.stringify(msg);\n  }\n  this.socket.send(msg);\n};\n\n\n/**\n * Closes the socket and emits 'disconnected'\n */\nConnection.prototype.disconnect = function() {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function(collection, name) {\n  if (this.collections[collection]) return this.collections[collection][name];\n};\n\n\n/**\n * @deprecated\n */\nConnection.prototype.getOrCreate = function(collection, name, data) {\n  console.trace('getOrCreate is deprecated. Use get() instead');\n  return this.get(collection, name, data);\n};\n\n\n/**\n * Get or create a document.\n *\n * @param collection\n * @param name\n * @param [data] ingested into document if created\n * @return {Doc}\n */\nConnection.prototype.get = function(collection, name, data) {\n  var collectionObject = this.collections[collection];\n  if (!collectionObject)\n    collectionObject = this.collections[collection] = {};\n\n  var doc = collectionObject[name];\n  if (!doc) {\n    doc = collectionObject[name] = new Doc(this, collection, name);\n    this.emit('doc', doc);\n  }\n\n  // Even if the document isn't new, its possible the document was created\n  // manually and then tried to be re-created with data (suppose a query\n  // returns with data for the document). We should hydrate the document\n  // immediately if we can because the query callback will expect the document\n  // to have data.\n  if (data && data.data !== undefined && !doc.state) {\n    doc.ingestData(data);\n  }\n\n  return doc;\n};\n\n\n/**\n * Remove document from this.collections\n *\n * @private\n */\nConnection.prototype._destroyDoc = function(doc) {\n  var collectionObject = this.collections[doc.collection];\n  if (!collectionObject) return;\n\n  delete collectionObject[doc.name];\n\n  // Delete the collection container if its empty. This could be a source of\n  // memory leaks if you slowly make a billion collections, which you probably\n  // won't do anyway, but whatever.\n  if (!hasKeys(collectionObject))\n    delete this.collections[doc.collection];\n};\n\nConnection.prototype._addDoc = function(doc) {\n  var collectionObject = this.collections[doc.collection];\n  if (!collectionObject) {\n    collectionObject = this.collections[doc.collection] = {};\n  }\n  if (collectionObject[doc.name] !== doc) {\n    collectionObject[doc.name] = doc;\n  }\n};\n\n\nfunction hasKeys(object) {\n  for (var key in object) return true;\n  return false;\n};\n\n\n// Helper for createFetchQuery and createSubscribeQuery, below.\nConnection.prototype._createQuery = function(type, collection, q, options, callback) {\n  if (type !== 'fetch' && type !== 'sub')\n    throw new Error('Invalid query type: ' + type);\n\n  if (!options) options = {};\n  var id = this.nextQueryId++;\n  var query = new Query(type, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query._execute();\n  return query;\n};\n\n// Internal function. Use query.destroy() to remove queries.\nConnection.prototype._destroyQuery = function(query) {\n  delete this.queries[query.id];\n};\n\n// The query options object can contain the following fields:\n//\n// docMode: What to do with documents that are in the result set. Can be\n//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates\n//   that the server should send document snapshots to the client for all query\n//   results. These will be hydrated into the document objects before the query\n//   result callbacks are returned. Subscribe mode gets document snapshots and\n//   automatically subscribes the client to all results. Note that the\n//   documents *WILL NOT* be automatically unsubscribed when the query is\n//   destroyed. (ShareJS doesn't have enough information to do that safely).\n//   Beware of memory leaks when using this option.\n//\n// poll: Forcably enable or disable polling mode. Polling mode will reissue the query\n//   every time anything in the collection changes (!!) so, its quite\n//   expensive.  It is automatically enabled for paginated and sorted queries.\n//   By default queries run with polling mode disabled; which will only check\n//   changed documents to test if they now match the specified query.\n//   Set to false to disable polling mode, or true to enable it. If you don't\n//   specify a poll option, polling mode is enabled or disabled automatically\n//   by the query's backend.\n//\n// backend: Set the backend source for the query. You can attach different\n//   query backends to livedb and pick which one the query should hit using\n//   this parameter.\n//\n// results: (experimental) Initial list of resultant documents. This is\n//   useful for rehydrating queries when you're using autoFetch / autoSubscribe\n//   so the server doesn't have to send over snapshots for documents the client\n//   already knows about. This is experimental - the API may change in upcoming\n//   versions.\n\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The index is specific to the source, but if you're using mongodb it'll be\n// the collection to which the query is made.\n// The callback should have the signature function(error, results, extraData)\n// where results is a list of Doc objects.\nConnection.prototype.createFetchQuery = function(index, q, options, callback) {\n  return this._createQuery('fetch', index, q, options, callback);\n};\n\n// Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extraData)\n// where results is a list of Doc objects.\nConnection.prototype.createSubscribeQuery = function(index, q, options, callback) {\n  return this._createQuery('sub', index, q, options, callback);\n};\n","var types = require('../types').ottypes;\nvar emitter = require('./emitter');\n\n/**\n * A Doc is a client's view on a sharejs document.\n *\n * It is is uniquely identified by its `name` and `collection`.  Documents\n * should not be created directly. Create them with Connection.get()\n *\n *\n *\n * Subscriptions\n * -------------\n *\n * We can subscribe a document to stay in sync with the server.\n *   doc.subscribe(function(error) {\n *     doc.state // = 'ready'\n *     doc.subscribed // = true\n *   })\n * The server now sends us all changes concerning this document and these are\n * applied to our snapshot. If the subscription was successful the initial\n * snapshot and version sent by the server are loaded into the document.\n *\n * To stop listening to the changes we call `doc.unsubscribe()`.\n *\n * If we just want to load the data but not stay up-to-date, we call\n *   doc.fetch(function(error) {\n *     doc.snapshot // sent by server\n *   })\n *\n * TODO What happens when the document does not exist yet.\n *\n *\n *\n * Editing documents\n * ------------------\n *\n * To edit a document we have to create an editing context\n *   context = doc.context()\n * The context is an object exposing the type API of the documents OT type.\n *   doc.type = 'text'\n *   context.insert(0, 'In the beginning')\n *   doc.snapshot // 'In the beginning...'\n *\n * If a operation is applied on the snapshot the `_onOp` on the context is\n * called. The type implementation then usually triggers a corresponding event.\n *\n *\n *\n *\n * Events\n * ------\n *\n * You can use doc.on(eventName, callback) to subscribe to the following events:\n * - `before op (op, localContext)` Fired before an operation is applied to the\n *   snapshot. The document is already in locked state, so it is not allowed to\n *   submit further operations. It may be used to read the old snapshot just\n *   before applying an operation. The callback is passed the operation and the\n *   editing context if the operation originated locally and `false` otherwise\n * - `after op (op, localContext)` Fired after an operation has been applied to\n *   the snapshot. The arguments are the same as for `before op`\n * - `op (op, localContext)` The same as `after op` unless incremental updates\n *   are enabled. In this case it is fired after every partial operation with\n *   this operation as the first argument. When fired the document is in a\n *   locked state which only allows reading operations.\n * - `subscribed (error)` The document was subscribed\n * - `created (localContext)` The document was created. That means its type was\n *   set and it has some initial data.\n * - `del (localContext, snapshot)` Fired after the document is deleted, that is\n *   the snapshot is null. It is passed the snapshot before delteion as an\n *   arguments\n * - `error`\n *\n * TODO rename `op` to `after partial op`\n */\nvar Doc = exports.Doc = function(connection, collection, name) {\n  emitter.EventEmitter.call(this);\n\n  this.connection = connection;\n\n  this.collection = collection;\n  this.name = name;\n\n  this.version = this.type = null;\n  this.snapshot = undefined;\n\n  // **** State in document:\n\n  // The action the document tries to perform with the server\n  //\n  // - subscribe\n  // - unsubscribe\n  // - fetch\n  // - submit: send an operation\n  this.action = null;\n\n  // The data the document object stores can be in one of the following three states:\n  //   - No data. (null) We honestly don't know whats going on.\n  //   - Floating ('floating'): we have a locally created document that hasn't\n  //     been created on the server yet)\n  //   - Live ('ready') (we have data thats current on the server at some version).\n  this.state = null;\n\n  // Our subscription status. Either we're subscribed on the server, or we aren't.\n  this.subscribed = false;\n  // Either we want to be subscribed (true), we want a new snapshot from the\n  // server ('fetch'), or we don't care (false). This is also used when we\n  // disconnect & reconnect to decide what to do.\n  this.wantSubscribe = false;\n  // This list is used for subscribe and unsubscribe, since we'll only want to\n  // do one thing at a time.\n  this._subscribeCallbacks = [];\n\n\n  // *** end state stuff.\n\n  // This doesn't provide any standard API access right now.\n  this.provides = {};\n\n  // The editing contexts. These are usually instances of the type API when the\n  // document is ready for edits.\n  this.editingContexts = [];\n\n  // The op that is currently roundtripping to the server, or null.\n  //\n  // When the connection reconnects, the inflight op is resubmitted.\n  //\n  // This has the same format as an entry in pendingData, which is:\n  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}\n  this.inflightData = null;\n\n  // All ops that are waiting for the server to acknowledge this.inflightData\n  // This used to just be a single operation, but creates & deletes can't be\n  // composed with regular operations.\n  //\n  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}\n  this.pendingData = [];\n\n  // The OT type of this document.\n  //\n  // The document also responds to the api provided by the type\n  this.type = null;\n\n  // For debouncing getLatestOps calls\n  this._getLatestTimeout = null;\n};\nemitter.mixin(Doc);\n\n/**\n * Unsubscribe and remove all editing contexts\n */\nDoc.prototype.destroy = function(callback) {\n  var doc = this;\n  this.unsubscribe(function() {\n    // Don't care if there's an error unsubscribing.\n\n    if (doc.hasPending()) {\n      doc.once('nothing pending', function() {\n        doc.connection._destroyDoc(doc);\n      });\n    } else {\n      doc.connection._destroyDoc(doc);\n    }\n    doc.removeContexts();\n    if (callback) callback();\n  });\n};\n\n\n// ****** Manipulating the document snapshot, version and type.\n\n// Set the document's type, and associated properties. Most of the logic in\n// this function exists to update the document based on any added & removed API\n// methods.\n//\n// @param newType OT type provided by the ottypes library or its name or uri\nDoc.prototype._setType = function(newType) {\n  if (typeof newType === 'string') {\n    if (!types[newType]) throw new Error(\"Missing type \" + newType + ' ' + this.collection + ' ' + this.name);\n    newType = types[newType];\n  }\n  this.removeContexts();\n\n  // Set the new type\n  this.type = newType;\n\n  // If we removed the type from the object, also remove its snapshot.\n  if (!newType) {\n    this.provides = {};\n    this.snapshot = undefined;\n  } else if (newType.api) {\n    // Register the new type's API.\n    this.provides = newType.api.provides;\n  }\n};\n\n// Injest snapshot data. This data must include a version, snapshot and type.\n// This is used both to ingest data that was exported with a webpage and data\n// that was received from the server during a fetch.\n//\n// @param data.v    version\n// @param data.data\n// @param data.type\n// @fires ready\nDoc.prototype.ingestData = function(data) {\n  if (typeof data.v !== 'number') {\n    throw new Error('Missing version in ingested data ' + this.collection + ' ' + this.name);\n  }\n  if (this.state) {\n    // Silently ignore if doc snapshot version is equal or newer\n    // TODO: Investigate whether this should happen in practice or not\n    if (this.version >= data.v) return;\n    console.warn('Ignoring ingest data for', this.collection, this.name,\n      '\\n  in state:', this.state, '\\n  version:', this.version,\n      '\\n  snapshot:\\n', this.snapshot, '\\n  incoming data:\\n', data);\n    return;\n  }\n\n  this.version = data.v;\n  // data.data is what the server will actually send. data.snapshot is the old\n  // field name - supported now for backwards compatibility.\n  this.snapshot = data.data;\n  this._setType(data.type);\n\n  this.state = 'ready';\n  this.emit('ready');\n};\n\n// Get and return the current document snapshot.\nDoc.prototype.getSnapshot = function() {\n  return this.snapshot;\n};\n\n// The callback will be called at a time when the document has a snapshot and\n// you can start applying operations. This may be immediately.\nDoc.prototype.whenReady = function(fn) {\n  if (this.state === 'ready') {\n    fn();\n  } else {\n    this.once('ready', fn);\n  }\n};\n\nDoc.prototype.hasPending = function() {\n  return this.action != null || this.inflightData != null || !!this.pendingData.length;\n};\n\nDoc.prototype._emitNothingPending = function() {\n  if (this.hasPending()) return;\n  this.emit('nothing pending');\n};\n\n\n// **** Helpers for network messages\n\n// This function exists so connection can call it directly for bulk subscribes.\n// It could just make a temporary object literal, thats pretty slow.\nDoc.prototype._handleSubscribe = function(err, data) {\n  if (err && err !== 'Already subscribed') {\n    console.error('Could not subscribe:', err, this.collection, this.name);\n    this.emit('error', err);\n    // There's probably a reason we couldn't subscribe. Don't retry.\n    this._setWantSubscribe(false, null, err);\n    return;\n  }\n  if (data) this.ingestData(data);\n  this.subscribed = true;\n  this._clearAction();\n  this.emit('subscribe');\n  this._finishSub();\n};\n\n// This is called by the connection when it receives a message for the document.\nDoc.prototype._onMessage = function(msg) {\n  if (!(msg.c === this.collection && msg.d === this.name)) {\n    // This should never happen - its a sanity check for bugs in the connection code.\n    var err = 'Got message for wrong document.';\n    console.error(err, this.collection, this.name, msg);\n    throw new Error(err);\n  }\n\n  // msg.a = the action.\n  switch (msg.a) {\n    case 'fetch':\n      // We're done fetching. This message has no other information.\n      if (msg.data) this.ingestData(msg.data);\n      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;\n      this._clearAction();\n      this._finishSub(msg.error);\n      break;\n\n    case 'sub':\n      // Subscribe reply.\n      this._handleSubscribe(msg.error, msg.data);\n      break;\n\n    case 'unsub':\n      // Unsubscribe reply\n      this.subscribed = false;\n      this.emit('unsubscribe');\n\n      this._clearAction();\n      this._finishSub(msg.error);\n      break;\n\n    case 'ack':\n      // Acknowledge a locally submitted operation.\n      //\n      // Usually we do nothing here - all the interesting logic happens when we\n      // get sent our op back in the op stream (which happens even if we aren't\n      // subscribed)\n      if (msg.error && msg.error !== 'Op already submitted') {\n        // The server has rejected an op from the client for an unexpected reason.\n        // We'll send the error message to the user and try to roll back the change.\n        if (this.inflightData) {\n          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');\n          this._tryRollback(this.inflightData);\n          this._clearInflightOp(msg.error);\n        } else {\n          // I managed to get into this state once. I'm not sure how it happened.\n          // The op was maybe double-acknowledged?\n          console.warn('Second acknowledgement message (error) received', msg, this);\n        }\n      }\n      break;\n\n    case 'op':\n      if (this.inflightData &&\n          msg.src === this.inflightData.src &&\n          msg.seq === this.inflightData.seq) {\n        // This one is mine. Accept it as acknowledged.\n        this._opAcknowledged(msg);\n        break;\n      }\n\n      if (this.version == null || msg.v > this.version) {\n        // This will happen in normal operation if we become subscribed to a\n        // new document via a query. It can also happen if we get an op for\n        // a future version beyond the version we are expecting next. This\n        // could happen if the server doesn't publish an op for whatever reason\n        // or because of a race condition. In any case, we can send a fetch\n        // command to catch back up.\n        this._getLatestOps();\n        break;\n      }\n\n      if (msg.v < this.version) {\n        // This will happen naturally in the following (or similar) cases:\n        //\n        // Client is not subscribed to document.\n        // -> client submits an operation (v=10)\n        // -> client subscribes to a query which matches this document. Says we\n        //    have v=10 of the doc.\n        //\n        // <- server acknowledges the operation (v=11). Server acknowledges the\n        //    operation because the doc isn't subscribed\n        // <- server processes the query, which says the client only has v=10.\n        //    Server subscribes at v=10 not v=11, so we get another copy of the\n        //    v=10 operation.\n        //\n        // In this case, we can safely ignore the old (duplicate) operation.\n        break;\n      }\n\n      if (this.inflightData) xf(this.inflightData, msg);\n\n      for (var i = 0; i < this.pendingData.length; i++) {\n        xf(this.pendingData[i], msg);\n      }\n\n      this.version++;\n      this._otApply(msg, false);\n      break;\n\n    case 'meta':\n      console.warn('Unhandled meta op:', msg);\n      break;\n\n    default:\n      console.warn('Unhandled document message:', msg);\n      break;\n  }\n};\n\nDoc.prototype._getLatestOps = function() {\n  var doc = this;\n  var debounced = false;\n  if (doc._getLatestTimeout) {\n    debounced = true;\n  } else {\n    // Send a fetch command, which will get us the missing ops to catch back up\n    // or the full doc if our version is currently null\n    doc.connection.sendFetch(doc, doc.version);\n  }\n  // Debounce calls, since we are likely to get multiple future operations\n  // in a rapid sequence\n  clearTimeout(doc._getLatestTimeout);\n  doc._getLatestTimeout = setTimeout(function() {\n    doc._getLatestTimeout = null;\n    // Send another fetch at the end of the final timeout interval if we were\n    // debounced to make sure we didn't miss anything\n    if (debounced) {\n      doc.connection.sendFetch(doc, doc.version);\n    }\n  }, 5000);\n  return;\n};\n\n// Called whenever (you guessed it!) the connection state changes. This will\n// happen when we get disconnected & reconnect.\nDoc.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend) {\n    this.flush();\n  } else {\n    this.subscribed = false;\n    this._clearAction();\n  }\n};\n\nDoc.prototype._clearAction = function() {\n  this.action = null;\n  this.flush();\n  this._emitNothingPending();\n};\n\n// Send the next pending op to the server, if we can.\n//\n// Only one operation can be in-flight at a time. If an operation is already on\n// its way, or we're not currently connected, this method does nothing.\nDoc.prototype.flush = function() {\n  // Ignore if we can't send or we are already sending an op\n  if (!this.connection.canSend || this.inflightData) return;\n\n  // Pump and dump any no-ops from the front of the pending op list.\n  var opData;\n  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {\n    var callbacks = opData.callbacks;\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](opData.error);\n    }\n    this.pendingData.shift();\n  }\n\n  // Send first pending op unless paused\n  if (!this.paused && this.pendingData.length) {\n    this._sendOpData();\n    return;\n  }\n\n  // Ignore if an action is already in process\n  if (this.action) return;\n  // Once all ops are sent, perform subscriptions and fetches\n  var version = (this.state === 'ready') ? this.version : null;\n\n  if (this.subscribed && !this.wantSubscribe) {\n    this.action = 'unsubscribe';\n    this.connection.sendUnsubscribe(this);\n\n  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {\n    this.action = 'fetch';\n    this.connection.sendFetch(this, version);\n\n  } else if (!this.subscribed && this.wantSubscribe) {\n    this.action = 'subscribe';\n    this.connection.sendSubscribe(this, version);\n  }\n};\n\n\n// ****** Subscribing, unsubscribing and fetching\n\n// Value is true, false or 'fetch'.\nDoc.prototype._setWantSubscribe = function(value, callback, err) {\n  if (this.subscribed === this.wantSubscribe &&\n      (this.subscribed === value || value === 'fetch' && this.subscribed)) {\n    if (callback) callback(err);\n    return;\n  }\n\n  // If we want to subscribe, don't weaken it to a fetch.\n  if (value !== 'fetch' || this.wantSubscribe !== true) {\n    this.wantSubscribe = value;\n  }\n\n  if (callback) this._subscribeCallbacks.push(callback);\n  this.flush();\n};\n\n// Open the document. There is no callback and no error handling if you're\n// already connected.\n//\n// Only call this once per document.\nDoc.prototype.subscribe = function(callback) {\n  this._setWantSubscribe(true, callback);\n};\n\n// Unsubscribe. The data will stay around in local memory, but we'll stop\n// receiving updates.\nDoc.prototype.unsubscribe = function(callback) {\n  this._setWantSubscribe(false, callback);\n};\n\n// Call to request fresh data from the server.\nDoc.prototype.fetch = function(callback) {\n  this._setWantSubscribe('fetch', callback);\n};\n\n// Called when our subscribe, fetch or unsubscribe messages are acknowledged.\nDoc.prototype._finishSub = function(err) {\n  if (!this._subscribeCallbacks.length) return;\n  for (var i = 0; i < this._subscribeCallbacks.length; i++) {\n    this._subscribeCallbacks[i](err);\n  }\n  this._subscribeCallbacks.length = 0;\n};\n\n\n// Operations\n\n\n// ************ Dealing with operations.\n\n// Helper function to set opData to contain a no-op.\nvar setNoOp = function(opData) {\n  delete opData.op;\n  delete opData.create;\n  delete opData.del;\n};\n\nvar isNoOp = function(opData) {\n  return !opData.op && !opData.create && !opData.del;\n}\n\n// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.\nvar tryCompose = function(type, data1, data2) {\n  if (data1.create && data2.del) {\n    setNoOp(data1);\n  } else if (data1.create && data2.op) {\n    // Compose the data into the create data.\n    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;\n    data1.create.data = type.apply(data, data2.op);\n  } else if (isNoOp(data1)) {\n    data1.create = data2.create;\n    data1.del = data2.del;\n    data1.op = data2.op;\n  } else if (data1.op && data2.op && type.compose) {\n    data1.op = type.compose(data1.op, data2.op);\n  } else {\n    return false;\n  }\n  return true;\n};\n\n// Transform server op data by a client op, and vice versa. Ops are edited in place.\nvar xf = function(client, server) {\n  // In this case, we're in for some fun. There are some local operations\n  // which are totally invalid - either the client continued editing a\n  // document that someone else deleted or a document was created both on the\n  // client and on the server. In either case, the local document is way\n  // invalid and the client's ops are useless.\n  //\n  // The client becomes a no-op, and we keep the server op entirely.\n  if (server.create || server.del) return setNoOp(client);\n  if (client.create) throw new Error('Invalid state. This is a bug. ' + this.collection + ' ' + this.name);\n\n  // The client has deleted the document while the server edited it. Kill the\n  // server's op.\n  if (client.del) return setNoOp(server);\n\n  // We only get here if either the server or client ops are no-op. Carry on,\n  // nothing to see here.\n  if (!server.op || !client.op) return;\n\n  // They both edited the document. This is the normal case for this function -\n  // as in, most of the time we'll end up down here.\n  //\n  // You should be wondering why I'm using client.type instead of this.type.\n  // The reason is, if we get ops at an old version of the document, this.type\n  // might be undefined or a totally different type. By pinning the type to the\n  // op data, we make sure the right type has its transform function called.\n  if (client.type.transformX) {\n    var result = client.type.transformX(client.op, server.op);\n    client.op = result[0];\n    server.op = result[1];\n  } else {\n    var _c = client.type.transform(client.op, server.op, 'left');\n    var _s = client.type.transform(server.op, client.op, 'right');\n    client.op = _c; server.op = _s;\n  }\n};\n\n/**\n * Applies the operation to the snapshot\n *\n * If the operation is create or delete it emits `create` or `del`.  Then the\n * operation is applied to the snapshot and `op` and `after op` are emitted.  If\n * the type supports incremental updates and `this.incremental` is true we fire\n * `op` after every small operation.\n *\n * This is the only function to fire the above mentioned events.\n *\n * @private\n */\nDoc.prototype._otApply = function(opData, context) {\n  this.locked = true;\n\n  if (opData.create) {\n    // If the type is currently set, it means we tried creating the document\n    // and someone else won. client create x server create = server create.\n    var create = opData.create;\n    this._setType(create.type);\n    this.snapshot = this.type.create(create.data);\n\n    // This is a bit heavyweight, but I want the created event to fire outside of the lock.\n    this.once('unlock', function() {\n      this.emit('create', context);\n    });\n  } else if (opData.del) {\n    // The type should always exist in this case. del x _ = del\n    var oldSnapshot = this.snapshot;\n    this._setType(null);\n    this.once('unlock', function() {\n      this.emit('del', context, oldSnapshot);\n    });\n  } else if (opData.op) {\n    if (!this.type) throw new Error('Document does not exist. ' + this.collection + ' ' + this.name);\n\n    var type = this.type;\n\n    var op = opData.op;\n\n    // The context needs to be told we're about to edit, just in case it needs\n    // to store any extra data. (text-tp2 has this constraint.)\n    for (var i = 0; i < this.editingContexts.length; i++) {\n      var c = this.editingContexts[i];\n      if (c != context && c._beforeOp) c._beforeOp(opData.op);\n    }\n\n    this.emit('before op', op, context);\n\n    // This exists so clients can pull any necessary data out of the snapshot\n    // before it gets changed.  Previously we kept the old snapshot object and\n    // passed it to the op event handler. However, apply no longer guarantees\n    // the old object is still valid.\n    //\n    // Because this could be totally unnecessary work, its behind a flag. set\n    // doc.incremental to enable.\n    if (this.incremental && type.incrementalApply) {\n      var _this = this;\n      type.incrementalApply(this.snapshot, op, function(o, snapshot) {\n        _this.snapshot = snapshot;\n        _this.emit('op', o, context);\n      });\n    } else {\n      // This is the most common case, simply applying the operation to the local snapshot.\n      this.snapshot = type.apply(this.snapshot, op);\n      this.emit('op', op, context);\n    }\n  }\n  // Its possible for none of the above cases to match, in which case the op is\n  // a no-op. This will happen when a document has been deleted locally and\n  // remote ops edit the document.\n\n\n  this.locked = false;\n  this.emit('unlock');\n\n  if (opData.op) {\n    var contexts = this.editingContexts;\n    // Notify all the contexts about the op (well, all the contexts except\n    // the one which initiated the submit in the first place).\n    // NOTE Handle this with events?\n    for (var i = 0; i < contexts.length; i++) {\n      var c = contexts[i];\n      if (c != context && c._onOp) c._onOp(opData.op);\n    }\n    for (var i = 0; i < contexts.length; i++) {\n      if (contexts[i].shouldBeRemoved) contexts.splice(i--, 1);\n    }\n\n    return this.emit('after op', opData.op, context);\n  }\n};\n\n\n\n// ***** Sending operations\n\nDoc.prototype.retry = function() {\n  if (!this.inflightData) return;\n  var threshold = 5000 * Math.pow(2, this.inflightData.retries);\n  if (this.inflightData.sentAt < Date.now() - threshold) {\n    this.connection.emit('retry', this);\n    this._sendOpData();\n  }\n};\n\n// Actually send op data to the server.\nDoc.prototype._sendOpData = function() {\n  // Wait until we have a src id from the server\n  var src = this.connection.id;\n  if (!src) return;\n\n  // When there is no inflightData, send the first item in pendingData. If\n  // there is inflightData, try sending it again\n  if (!this.inflightData) {\n    // Send first pending op\n    this.inflightData = this.pendingData.shift();\n  }\n  var data = this.inflightData;\n  if (!data) {\n    throw new Error('no data to send on call to _sendOpData');\n  }\n\n  // Track data for retrying ops\n  data.sentAt = Date.now();\n  data.retries = (data.retries == null) ? 0 : data.retries + 1;\n\n  // The src + seq number is a unique ID representing this operation. This tuple\n  // is used on the server to detect when ops have been sent multiple times and\n  // on the client to match acknowledgement of an op back to the inflightData.\n  // Note that the src could be different from this.connection.id after a\n  // reconnect, since an op may still be pending after the reconnection and\n  // this.connection.id will change. In case an op is sent multiple times, we\n  // also need to be careful not to override the original seq value.\n  if (data.seq == null) data.seq = this.connection.seq++;\n\n  this.connection.sendOp(this, data);\n\n  // src isn't needed on the first try, since the server session will have the\n  // same id, but it must be set on the inflightData in case it is sent again\n  // after a reconnect and the connection's id has changed by then\n  if (data.src == null) data.src = src;\n};\n\n\n// Queues the operation for submission to the server and applies it locally.\n//\n// Internal method called to do the actual work for submitOp(), create() and del().\n// @private\n//\n// @param opData\n// @param [opData.op]\n// @param [opData.del]\n// @param [opData.create]\n// @param [context] the editing context\n// @param [callback] called when operation is submitted\nDoc.prototype._submitOpData = function(opData, context, callback) {\n  if (typeof context === 'function') {\n    callback = context;\n    context = true; // The default context is true.\n  }\n  if (context == null) context = true;\n\n  if (this.locked) {\n    var err = \"Cannot call submitOp from inside an 'op' event handler. \" + this.collection + ' ' + this.name;\n    if (callback) return callback(err);\n    throw new Error(err);\n  }\n\n  // The opData contains either op, create, delete, or none of the above (a no-op).\n  if (opData.op) {\n    if (!this.type) {\n      var err = 'Document has not been created';\n      if (callback) return callback(err);\n      throw new Error(err);\n    }\n    // Try to normalize the op. This removes trailing skip:0's and things like that.\n    if (this.type.normalize) opData.op = this.type.normalize(opData.op);\n  }\n\n  if (!this.state) {\n    this.state = 'floating';\n  }\n\n  opData.type = this.type;\n  opData.callbacks = [];\n\n  // If the type supports composes, try to compose the operation onto the end\n  // of the last pending operation.\n  var operation;\n  var previous = this.pendingData[this.pendingData.length - 1];\n\n  if (previous && tryCompose(this.type, previous, opData)) {\n    operation = previous;\n  } else {\n    operation = opData;\n    this.pendingData.push(opData);\n  }\n  if (callback) operation.callbacks.push(callback);\n\n  this._otApply(opData, context);\n\n  // The call to flush is in a timeout so if submitOp() is called multiple\n  // times in a closure all the ops are combined before being sent to the\n  // server. It doesn't matter if flush is called a bunch of times.\n  var _this = this;\n  setTimeout((function() { _this.flush(); }), 0);\n};\n\n\n// *** Client OT entrypoints.\n\n// Submit an operation to the document.\n//\n// @param operation handled by the OT type\n// @param [context] editing context\n// @param [callback] called after operation submitted\n//\n// @fires before op, op, after op\nDoc.prototype.submitOp = function(op, context, callback) {\n  this._submitOpData({op: op}, context, callback);\n};\n\n// Create the document, which in ShareJS semantics means to set its type. Every\n// object implicitly exists in the database but has no data and no type. Create\n// sets the type of the object and can optionally set some initial data on the\n// object, depending on the type.\n//\n// @param type  OT type\n// @param data  initial\n// @param context  editing context\n// @param callback  called when operation submitted\nDoc.prototype.create = function(type, data, context, callback) {\n  if (typeof data === 'function') {\n    // Setting the context to be the callback function in this case so _submitOpData\n    // can handle the default value thing.\n    context = data;\n    data = undefined;\n  }\n\n  if (this.type) {\n    var err = 'Document already exists';\n    if (callback) return callback(err);\n    throw new Error(err);\n  }\n\n  var op = {create: {type:type, data:data}};\n  this._submitOpData(op, context, callback);\n};\n\n// Delete the document. This creates and submits a delete operation to the\n// server. Deleting resets the object's type to null and deletes its data. The\n// document still exists, and still has the version it used to have before you\n// deleted it (well, old version +1).\n//\n// @param context   editing context\n// @param callback  called when operation submitted\nDoc.prototype.del = function(context, callback) {\n  if (!this.type) {\n    var err = 'Document does not exist';\n    if (callback) return callback(err);\n    throw new Error(err);\n  }\n\n  this._submitOpData({del: true}, context, callback);\n};\n\n\n// Stops the document from sending any operations to the server.\nDoc.prototype.pause = function() {\n  this.paused = true;\n};\n\n// Continue sending operations to the server\nDoc.prototype.resume = function() {\n  this.paused = false;\n  this.flush();\n};\n\n\n// *** Receiving operations\n\n\n// This will be called when the server rejects our operations for some reason.\n// There's not much we can do here if the OT type is noninvertable, but that\n// shouldn't happen too much in real life because readonly documents should be\n// flagged as such. (I should probably figure out a flag for that).\n//\n// This does NOT get called if our op fails to reach the server for some reason\n// - we optimistically assume it'll make it there eventually.\nDoc.prototype._tryRollback = function(opData) {\n  // This is probably horribly broken.\n  if (opData.create) {\n    this._setType(null);\n\n    // I don't think its possible to get here if we aren't in a floating state.\n    if (this.state === 'floating')\n      this.state = null;\n    else\n      console.warn('Rollback a create from state ' + this.state);\n\n  } else if (opData.op && opData.type.invert) {\n    opData.op = opData.type.invert(opData.op);\n\n    // Transform the undo operation by any pending ops.\n    for (var i = 0; i < this.pendingData.length; i++) {\n      xf(this.pendingData[i], opData);\n    }\n\n    // ... and apply it locally, reverting the changes.\n    //\n    // This operation is applied to look like it comes from a remote context.\n    // I'm still not 100% sure about this functionality, because its really a\n    // local op. Basically, the problem is that if the client's op is rejected\n    // by the server, the editor window should update to reflect the undo.\n    this._otApply(opData, false);\n  } else if (opData.op || opData.del) {\n    // This is where an undo stack would come in handy.\n    this._setType(null);\n    this.version = null;\n    this.state = null;\n    this.subscribed = false;\n    this.emit('error', \"Op apply failed and the operation could not be reverted\");\n\n    // Trigger a fetch. In our invalid state, we can't really do anything.\n    this.fetch();\n    this.flush();\n  }\n};\n\nDoc.prototype._clearInflightOp = function(error) {\n  var callbacks = this.inflightData.callbacks;\n  for (var i = 0; i < callbacks.length; i++) {\n    callbacks[i](error || this.inflightData.error);\n  }\n\n  this.inflightData = null;\n  this.flush();\n  this._emitNothingPending();\n};\n\n// This is called when the server acknowledges an operation from the client.\nDoc.prototype._opAcknowledged = function(msg) {\n  // Our inflight op has been acknowledged, so we can throw away the inflight data.\n  // (We were only holding on to it incase we needed to resend the op.)\n  if (!this.state) {\n    throw new Error('opAcknowledged called from a null state. This should never happen. ' + this.collection + ' ' + this.name);\n  } else if (this.state === 'floating') {\n    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op. ' + this.collection + ' ' + this.name);\n\n    // Our create has been acknowledged. This is the same as ingesting some data.\n    this.version = msg.v;\n    this.state = 'ready';\n    var _this = this;\n    setTimeout(function() { _this.emit('ready'); }, 0);\n  } else {\n    // We already have a snapshot. The snapshot should be at the acknowledged\n    // version, because the server has sent us all the ops that have happened\n    // before acknowledging our op.\n\n    // This should never happen - something is out of order.\n    if (msg.v !== this.version) {\n      throw new Error('Invalid version from server. This can happen when you submit ops in a submitOp callback. Expected: ' + this.version + ' Message version: ' + msg.v + ' ' + this.collection + ' ' + this.name);\n    }\n  }\n\n  // The op was committed successfully. Increment the version number\n  this.version++;\n\n  this._clearInflightOp();\n};\n\n\n// Creates an editing context\n//\n// The context is an object responding to getSnapshot(), submitOp() and\n// destroy(). It also has all the methods from the OT type mixed in.\n// If the document is destroyed, the detach() method is called on the context.\nDoc.prototype.createContext = function() {\n  var type = this.type;\n  if (!type) throw new Error('Missing type ' + this.collection + ' ' + this.name);\n\n  // I could use the prototype chain to do this instead, but Object.create\n  // isn't defined on old browsers. This will be fine.\n  var doc = this;\n  var context = {\n    getSnapshot: function() {\n      return doc.snapshot;\n    },\n    submitOp: function(op, callback) {\n      doc.submitOp(op, context, callback);\n    },\n    destroy: function() {\n      if (this.detach) {\n        this.detach();\n        // Don't double-detach.\n        delete this.detach;\n      }\n      // It will be removed from the actual editingContexts list next time\n      // we receive an op on the document (and the list is iterated through).\n      //\n      // This is potentially dodgy, allowing a memory leak if you create &\n      // destroy a whole bunch of contexts without receiving or sending any ops\n      // to the document.\n      //\n      // NOTE Why can't we destroy contexts immediately?\n      delete this._onOp;\n      this.shouldBeRemoved = true;\n    },\n\n    // This is dangerous, but really really useful for debugging. I hope people\n    // don't depend on it.\n    _doc: this,\n  };\n\n  if (type.api) {\n    // Copy everything else from the type's API into the editing context.\n    for (var k in type.api) {\n      context[k] = type.api[k];\n    }\n  } else {\n    context.provides = {};\n  }\n\n  this.editingContexts.push(context);\n\n  return context;\n};\n\n\n/**\n * Destroy all editing contexts\n */\nDoc.prototype.removeContexts = function() {\n  for (var i = 0; i < this.editingContexts.length; i++) {\n    this.editingContexts[i].destroy();\n  }\n  this.editingContexts.length = 0;\n};\n","var EventEmitter = require('events').EventEmitter;\n\nexports.EventEmitter = EventEmitter;\nexports.mixin = mixin;\n\nfunction mixin(Constructor) {\n  for (var key in EventEmitter.prototype) {\n    Constructor.prototype[key] = EventEmitter.prototype[key];\n  }\n}\n","// Entry point for the client\n//\n// Usage:\n//\n//    <script src=\"dist/share.js\"></script>\n\nexports.Connection = require('./connection').Connection;\nexports.Doc = require('./doc').Doc;\nrequire('./textarea');\n\nvar types = require('../types');\nexports.ottypes = types.ottypes;\nexports.registerType = types.registerType;\n","var emitter = require('./emitter');\n\n// Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\nvar Query = exports.Query = function(type, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this);\n\n  // 'fetch' or 'sub'\n  this.type = type;\n\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n\n  // The query itself. For mongo, this should look something like {\"data.x\":5}\n  this.query = query;\n\n  // Resultant document action for the server. Fetch mode will automatically\n  // fetch all results. Subscribe mode will automatically subscribe all\n  // results. Results are never unsubscribed.\n  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.\n  if (this.docMode === 'subscribe') this.docMode = 'sub';\n\n  // Do we repoll the entire query whenever anything changes? (As opposed to\n  // just polling the changed item). This needs to be enabled to be able to use\n  // ordered queries (sortby:) and paginated queries. Set to undefined, it will\n  // be enabled / disabled automatically based on the query's properties.\n  this.poll = options.poll;\n\n  // The backend we actually hit. If this isn't defined, it hits the snapshot\n  // database. Otherwise this can be used to hit another configured query\n  // index.\n  this.backend = options.backend || options.source;\n\n  // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. If fetch is false, these documents will not\n  // have any data. You should manually call fetch() or subscribe() on them.\n  //\n  // Calling subscribe() might be a good idea anyway, as you won't be\n  // subscribed to the documents by default.\n  this.knownDocs = options.knownDocs || [];\n  this.results = [];\n\n  // Do we have some initial data?\n  this.ready = false;\n\n  this.callback = callback;\n};\nemitter.mixin(Query);\n\nQuery.prototype.action = 'qsub';\n\n// Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\nQuery.prototype._execute = function() {\n  if (!this.connection.canSend) return;\n\n  if (this.docMode) {\n    var collectionVersions = {};\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    for (var i = 0; i < this.knownDocs.length; i++) {\n      var doc = this.knownDocs[i];\n      if (doc.version == null) continue;\n      var c = collectionVersions[doc.collection] =\n        (collectionVersions[doc.collection] || {});\n      c[doc.name] = doc.version;\n    }\n  }\n\n  var msg = {\n    a: 'q' + this.type,\n    id: this.id,\n    c: this.collection,\n    o: {},\n    q: this.query,\n  };\n\n  if (this.docMode) {\n    msg.o.m = this.docMode;\n    // This should be omitted if empty, but whatever.\n    msg.o.vs = collectionVersions;\n  }\n  if (this.backend != null) msg.o.b = this.backend;\n  if (this.poll !== undefined) msg.o.p = this.poll;\n\n  this.connection.send(msg);\n};\n\n// Make a list of documents from the list of server-returned data objects\nQuery.prototype._dataToDocs = function(data) {\n  var results = [];\n  var lastType;\n  for (var i = 0; i < data.length; i++) {\n    var docData = data[i];\n\n    // Types are only put in for the first result in the set and every time the type changes in the list.\n    if (docData.type) {\n      lastType = docData.type;\n    } else {\n      docData.type = lastType;\n    }\n\n    // This will ultimately call doc.ingestData(), which is what populates\n    // the doc snapshot and version with the data returned by the query\n    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);\n    results.push(doc);\n  }\n  return results;\n};\n\n// Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection. You should unsubscribe from the query before\n// destroying it.\nQuery.prototype.destroy = function() {\n  if (this.connection.canSend && this.type === 'sub') {\n    this.connection.send({a:'qunsub', id:this.id});\n  }\n\n  this.connection._destroyQuery(this);\n};\n\nQuery.prototype._onConnectionStateChanged = function(state, reason) {\n  if (this.connection.state === 'connecting') {\n    this._execute();\n  }\n};\n\n// Internal method called from connection to pass server messages to the query.\nQuery.prototype._onMessage = function(msg) {\n  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {\n    console.warn('Invalid message sent to query', msg, this);\n    return;\n  }\n\n  if (msg.error) this.emit('error', msg.error);\n\n  switch (msg.a) {\n    case 'qfetch':\n      var results = msg.data ? this._dataToDocs(msg.data) : undefined;\n      if (this.callback) this.callback(msg.error, results, msg.extra);\n      // Once a fetch query gets its data, it is destroyed.\n      this.connection._destroyQuery(this);\n      break;\n\n    case 'q':\n      // Query diff data (inserts and removes)\n      if (msg.diff) {\n        // We need to go through the list twice. First, we'll ingest all the\n        // new documents and set them as subscribed.  After that we'll emit\n        // events and actually update our list. This avoids race conditions\n        // around setting documents to be subscribed & unsubscribing documents\n        // in event callbacks.\n        for (var i = 0; i < msg.diff.length; i++) {\n          var d = msg.diff[i];\n          if (d.type === 'insert') d.values = this._dataToDocs(d.values);\n        }\n\n        for (var i = 0; i < msg.diff.length; i++) {\n          var d = msg.diff[i];\n          switch (d.type) {\n            case 'insert':\n              var newDocs = d.values;\n              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n              this.emit('insert', newDocs, d.index);\n              break;\n            case 'remove':\n              var howMany = d.howMany || 1;\n              var removed = this.results.splice(d.index, howMany);\n              this.emit('remove', removed, d.index);\n              break;\n            case 'move':\n              var howMany = d.howMany || 1;\n              var docs = this.results.splice(d.from, howMany);\n              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n              this.emit('move', docs, d.from, d.to);\n              break;\n          }\n        }\n      }\n\n      if (msg.extra !== void 0) {\n        this.emit('extra', msg.extra);\n      }\n      break;\n    case 'qsub':\n      // This message replaces the entire result set with the set passed.\n      if (!msg.error) {\n        var previous = this.results;\n\n        // Then add everything in the new result set.\n        this.results = this.knownDocs = this._dataToDocs(msg.data);\n        this.extra = msg.extra;\n\n        this.ready = true;\n        this.emit('change', this.results, previous);\n      }\n      if (this.callback) {\n        this.callback(msg.error, this.results, this.extra);\n        delete this.callback;\n      }\n      break;\n  }\n};\n\n// Change the thing we're searching for. This isn't fully supported on the\n// backend (it destroys the old query and makes a new one) - but its\n// programatically useful and I might add backend support at some point.\nQuery.prototype.setQuery = function(q) {\n  if (this.type !== 'sub') throw new Error('cannot change a fetch query');\n\n  this.query = q;\n  if (this.connection.canSend) {\n    // There's no 'change' message to send to the server. Just resubscribe.\n    this.connection.send({a:'qunsub', id:this.id});\n    this._execute();\n  }\n};\n","/* This contains the textarea binding for ShareJS. This binding is really\n * simple, and a bit slow on big documents (Its O(N). However, it requires no\n * changes to the DOM and no heavy libraries like ace. It works for any kind of\n * text input field.\n *\n * You probably want to use this binding for small fields on forms and such.\n * For code editors or rich text editors or whatever, I recommend something\n * heavier.\n */\n\n var Doc = require('./doc').Doc;\n\n/* applyChange creates the edits to convert oldval -> newval.\n *\n * This function should be called every time the text element is changed.\n * Because changes are always localised, the diffing is quite easy. We simply\n * scan in from the start and scan in from the end to isolate the edited range,\n * then delete everything that was removed & add everything that was added.\n * This wouldn't work for complex changes, but this function should be called\n * on keystroke - so the edits will mostly just be single character changes.\n * Sometimes they'll paste text over other text, but even then the diff\n * generated by this algorithm is correct.\n *\n * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.\n */\nvar applyChange = function(ctx, oldval, newval) {\n  // Strings are immutable and have reference equality. I think this test is O(1), so its worth doing.\n  if (oldval === newval) return;\n\n  var commonStart = 0;\n  while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {\n    commonStart++;\n  }\n\n  var commonEnd = 0;\n  while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) &&\n      commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {\n    commonEnd++;\n  }\n\n  if (oldval.length !== commonStart + commonEnd) {\n    ctx.remove(commonStart, oldval.length - commonStart - commonEnd);\n  }\n  if (newval.length !== commonStart + commonEnd) {\n    ctx.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));\n  }\n};\n\n// Attach a textarea to a document's editing context.\n//\n// The context is optional, and will be created from the document if its not\n// specified.\nDoc.prototype.attachTextarea = function(elem, ctx) {\n  if (!ctx) ctx = this.createContext();\n\n  if (!ctx.provides.text) throw new Error('Cannot attach to non-text document');\n\n  elem.value = ctx.get();\n\n  // The current value of the element's text is stored so we can quickly check\n  // if its been changed in the event handlers. This is mostly for browsers on\n  // windows, where the content contains \\r\\n newlines. applyChange() is only\n  // called after the \\r\\n newlines are converted, and that check is quite\n  // slow. So we also cache the string before conversion so we can do a quick\n  // check incase the conversion isn't needed.\n  var prevvalue;\n\n  // Replace the content of the text area with newText, and transform the\n  // current cursor by the specified function.\n  var replaceText = function(newText, transformCursor) {\n    if (transformCursor) {\n      var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];\n    }\n\n    // Fixate the window's scroll while we set the element's value. Otherwise\n    // the browser scrolls to the element.\n    var scrollTop = elem.scrollTop;\n    elem.value = newText;\n    prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.\n    if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;\n\n    // Setting the selection moves the cursor. We'll just have to let your\n    // cursor drift if the element isn't active, though usually users don't\n    // care.\n    if (newSelection && window.document.activeElement === elem) {\n      elem.selectionStart = newSelection[0];\n      elem.selectionEnd = newSelection[1];\n    }\n  };\n\n  replaceText(ctx.get());\n\n\n  // *** remote -> local changes\n\n  ctx.onInsert = function(pos, text) {\n    var transformCursor = function(cursor) {\n      return pos < cursor ? cursor + text.length : cursor;\n    };\n\n    // Remove any window-style newline characters. Windows inserts these, and\n    // they mess up the generated diff.\n    var prev = elem.value.replace(/\\r\\n/g, '\\n');\n    replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);\n  };\n\n  ctx.onRemove = function(pos, length) {\n    var transformCursor = function(cursor) {\n      // If the cursor is inside the deleted region, we only want to move back to the start\n      // of the region. Hence the Math.min.\n      return pos < cursor ? cursor - Math.min(length, cursor - pos) : cursor;\n    };\n\n    var prev = elem.value.replace(/\\r\\n/g, '\\n');\n    replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);\n  };\n\n\n  // *** local -> remote changes\n\n  // This function generates operations from the changed content in the textarea.\n  var genOp = function(event) {\n    // In a timeout so the browser has time to propogate the event's changes to the DOM.\n    setTimeout(function() {\n      if (elem.value !== prevvalue) {\n        prevvalue = elem.value;\n        applyChange(ctx, ctx.get(), elem.value.replace(/\\r\\n/g, '\\n'));\n      }\n    }, 0);\n  };\n\n  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];\n  for (var i = 0; i < eventNames.length; i++) {\n    var e = eventNames[i];\n    if (elem.addEventListener) {\n      elem.addEventListener(e, genOp, false);\n    } else {\n      elem.attachEvent('on' + e, genOp);\n    }\n  }\n\n  ctx.detach = function() {\n    for (var i = 0; i < eventNames.length; i++) {\n      var e = eventNames[i];\n      if (elem.removeEventListener) {\n        elem.removeEventListener(e, genOp, false);\n      } else {\n        elem.detachEvent('on' + e, genOp);\n      }\n    }\n  };\n\n  return ctx;\n};\n","\nexports.ottypes = {};\nexports.registerType = function(type) {\n  if (type.name) exports.ottypes[type.name] = type;\n  if (type.uri) exports.ottypes[type.uri] = type;\n};\n\nexports.registerType(require('ot-json0').type);\nexports.registerType(require('ot-text').type);\nexports.registerType(require('ot-text-tp2').type);\n\n// The types register themselves on their respective types.\nrequire('./text-api');\nrequire('./text-tp2-api');\n\n// The JSON API is buggy!! Please submit a pull request fixing it if you want to use it.\n//require('./json-api');\n","// Text document API for the 'text' type.\n\n// The API implements the standard text API methods. In particular:\n//\n// - getLength() returns the length of the document in characters\n// - getText() returns a string of the document\n// - insert(pos, text, [callback]) inserts text at position pos in the document\n// - remove(pos, length, [callback]) removes length characters at position pos\n//\n// Events are implemented by just adding the appropriate methods to your\n// context object.\n// onInsert(pos, text): Called when text is inserted.\n// onRemove(pos, length): Called when text is removed.\n\nvar type = require('ot-text').type;\n\ntype.api = {\n  provides: {text: true},\n\n  // Returns the number of characters in the string\n  getLength: function() { return this.getSnapshot().length; },\n\n\n  // Returns the text content of the document\n  get: function() { return this.getSnapshot(); },\n\n  getText: function() {\n    console.warn(\"`getText()` is deprecated; use `get()` instead.\");\n    return this.get();\n  },\n\n  // Insert the specified text at the given position in the document\n  insert: function(pos, text, callback) {\n    return this.submitOp([pos, text], callback);\n  },\n\n  remove: function(pos, length, callback) {\n    return this.submitOp([pos, {d:length}], callback);\n  },\n\n  // When you use this API, you should implement these two methods\n  // in your editing context.\n  //onInsert: function(pos, text) {},\n  //onRemove: function(pos, removedLength) {},\n\n  _onOp: function(op) {\n    var pos = 0;\n    var spos = 0;\n    for (var i = 0; i < op.length; i++) {\n      var component = op[i];\n      switch (typeof component) {\n        case 'number':\n          pos += component;\n          spos += component;\n          break;\n        case 'string':\n          if (this.onInsert) this.onInsert(pos, component);\n          pos += component.length;\n          break;\n        case 'object':\n          if (this.onRemove) this.onRemove(pos, component.d);\n          spos += component.d;\n      }\n    }\n  }\n};\n","// Text document API for text-tp2\n\nvar type = require('ot-text-tp2').type;\nvar takeDoc = type._takeDoc;\nvar append = type._append;\n\nvar appendSkipChars = function(op, doc, pos, maxlength) {\n  while ((maxlength == null || maxlength > 0) && pos.index < doc.data.length) {\n    var part = takeDoc(doc, pos, maxlength, true);\n    if (maxlength != null && typeof part === 'string') {\n      maxlength -= part.length;\n    }\n    append(op, part.length || part);\n  }\n};\n\ntype.api = {\n  provides: {text: true},\n\n  // Number of characters in the string\n  getLength: function() { return this.getSnapshot().charLength; },\n\n  // Flatten the document into a string\n  get: function() {\n    var snapshot = this.getSnapshot();\n    var strings = [];\n\n    for (var i = 0; i < snapshot.data.length; i++) {\n      var elem = snapshot.data[i];\n      if (typeof elem == 'string') {\n        strings.push(elem);\n      }\n    }\n\n    return strings.join('');\n  },\n\n  getText: function() {\n    console.warn(\"`getText()` is deprecated; use `get()` instead.\");\n    return this.get();\n  },\n\n  // Insert text at pos\n  insert: function(pos, text, callback) {\n    if (pos == null) pos = 0;\n\n    var op = [];\n    var docPos = {index: 0, offset: 0};\n    var snapshot = this.getSnapshot();\n\n    // Skip to the specified position\n    appendSkipChars(op, snapshot, docPos, pos);\n\n    // Append the text\n    append(op, {i: text});\n    appendSkipChars(op, snapshot, docPos);\n    this.submitOp(op, callback);\n    return op;\n  },\n\n  // Remove length of text at pos\n  remove: function(pos, len, callback) {\n    var op = [];\n    var docPos = {index: 0, offset: 0};\n    var snapshot = this.getSnapshot();\n\n    // Skip to the position\n    appendSkipChars(op, snapshot, docPos, pos);\n\n    while (len > 0) {\n      var part = takeDoc(snapshot, docPos, len, true);\n\n      // We only need to delete actual characters. This should also be valid if\n      // we deleted all the tombstones in the document here.\n      if (typeof part === 'string') {\n        append(op, {d: part.length});\n        len -= part.length;\n      } else {\n        append(op, part);\n      }\n    }\n\n    appendSkipChars(op, snapshot, docPos);\n    this.submitOp(op, callback);\n    return op;\n  },\n\n  _beforeOp: function() {\n    // Its a shame we need this. This also currently relies on snapshots being\n    // cloned during apply(). This is used in _onOp below to figure out what\n    // text was _actually_ inserted and removed.\n    //\n    // Maybe instead we should do all the _onOp logic here and store the result\n    // then play the events when _onOp is actually called or something.\n    this.__prevSnapshot = this.getSnapshot();\n  },\n\n  _onOp: function(op) {\n    var textPos = 0;\n    var docPos = {index:0, offset:0};\n    // The snapshot we get here is the document state _AFTER_ the specified op\n    // has been applied. That means any deleted characters are now tombstones.\n    var prevSnapshot = this.__prevSnapshot;\n\n    for (var i = 0; i < op.length; i++) {\n      var component = op[i];\n      var part, remainder;\n\n      if (typeof component == 'number') {\n        // Skip\n        for (remainder = component;\n            remainder > 0;\n            remainder -= part.length || part) {\n\n          part = takeDoc(prevSnapshot, docPos, remainder);\n          if (typeof part === 'string')\n            textPos += part.length;\n        }\n      } else if (component.i != null) {\n        // Insert\n        if (typeof component.i == 'string') {\n          // ... and its an insert of text, not insert of tombstones\n          if (this.onInsert) this.onInsert(textPos, component.i);\n          textPos += component.i.length;\n        }\n      } else {\n        // Delete\n        for (remainder = component.d;\n            remainder > 0;\n            remainder -= part.length || part) {\n\n          part = takeDoc(prevSnapshot, docPos, remainder);\n          if (typeof part == 'string' && this.onRemove)\n            this.onRemove(textPos, part.length);\n        }\n      }\n    }\n  }\n};\n","var qs = require('qs')\nvar parseUrl = require('url').parse\nvar resolveUrl = require('url').resolve\nvar router = require('./router')\nvar currentPath = window.location.pathname + window.location.search\n\n// Replace the initial state with the current URL immediately,\n// so that it will be rendered if the state is later popped\nif (window.history.replaceState) {\n  window.history.replaceState({\n    $render: true,\n    $method: 'get'\n  }, null, window.location.href)\n}\n\nmodule.exports = History\n\nfunction History(app, routes) {\n  this.app = app\n  this.routes = routes\n\n  if (window.history.pushState) {\n    addListeners(this)\n    return\n  }\n  this.push = function(url) {\n    window.location.assign(url)\n  }\n  this.replace = function(url) {\n    window.location.replace(url)\n  }\n}\n\nHistory.prototype.push = function(url, render, state, e) {\n  this._update('pushState', url, render, state, e)\n}\n\nHistory.prototype.replace = function(url, render, state, e) {\n  this._update('replaceState', url, render, state, e)\n}\n\n// Rerender the current url locally\nHistory.prototype.refresh = function() {\n  var path = routePath(window.location.href)\n  // Note that we don't pass previous to avoid triggering transitions\n  router.render(this, {url: path, method: 'get'})\n}\n\nHistory.prototype.back = function() {\n  window.history.back()\n}\n\nHistory.prototype.forward = function() {\n  window.history.forward()\n}\n\nHistory.prototype.go = function(i) {\n  window.history.go(i)\n}\n\nHistory.prototype._update = function(historyMethod, relativeUrl, render, state, e) {\n  var url = resolveUrl(window.location.href, relativeUrl)\n  var path = routePath(url)\n\n  // TODO: history.push should set the window.location with external urls\n  if (!path) return\n  if (render == null) render = true\n  if (state == null) state = {}\n\n  // Update the URL\n  var options = renderOptions(e, path)\n  state.$render = true\n  state.$method = options.method\n  window.history[historyMethod](state, null, options.url)\n  currentPath = window.location.pathname + window.location.search\n  if (render) router.render(this, options, e)\n}\n\nHistory.prototype.page = function() {\n  var page = this.app.createPage()\n  var history = this\n\n  function redirect(url) {\n    if (url === 'back') return history.back()\n    // TODO: Add support for `basepath` option like Express\n    if (url === 'home') url = '\\\\'\n    history.replace(url, true)\n  }\n\n  page.redirect = redirect\n  return page\n}\n\n// Get the pathname if it is on the same protocol and domain\nfunction routePath(url) {\n  var match = parseUrl(url)\n  return match &&\n    match.protocol === window.location.protocol &&\n    match.host === window.location.host &&\n    match.pathname + (match.search || '')\n}\n\nfunction renderOptions(e, path) {\n  // If this is a form submission, extract the form data and\n  // append it to the url for a get or params.body for a post\n  if (e && e.type === 'submit') {\n    var form = e.target\n    var elements = form.elements\n    var query = []\n    for (var i = 0, len = elements.length, el; i < len; i++) {\n      el = elements[i]\n      var name = el.name\n      if (!name) continue\n      var value = el.value\n      query.push(encodeURIComponent(name) + '=' + encodeURIComponent(value))\n      if (name === '_method') {\n        var override = value.toLowerCase()\n        if (override === 'delete') override = 'del'\n      }\n    }\n    query = query.join('&')\n    if (form.method.toLowerCase() === 'post') {\n      var method = override || 'post'\n      var body = qs.parse(query)\n    } else {\n      method = 'get'\n      path += '?' + query\n    }\n  } else {\n    method = 'get'\n  }\n  return {\n    method: method\n  , url: path\n  , previous: window.location.pathname + window.location.search\n  , body: body\n  , form: form\n  , link: e && e._tracksLink\n  }\n}\n\nfunction addListeners(history) {\n\n  // Detect clicks on links\n  function onClick(e) {\n    var el = e.target\n\n    // Ignore command click, control click, and non-left click\n    if (e.metaKey || e.which !== 1) return\n\n    // Ignore if already prevented\n    if (e.defaultPrevented) return\n\n    // Also look up for parent links (<a><img></a>)\n    while (el) {\n      var url = el.href\n      if (url) {\n\n        // Ignore if created by Tracks\n        if (el.hasAttribute && el.hasAttribute('data-router-ignore')) return\n\n        // Ignore links meant to open in a different window or frame\n        if (el.target && el.target !== '_self') return\n\n        // Ignore hash links to the same page\n        var hashIndex = url.indexOf('#')\n        if (~hashIndex && url.slice(0, hashIndex) === window.location.href.replace(/#.*/, '')) {\n          return\n        }\n\n        e._tracksLink = el\n        history.push(url, true, null, e)\n        return\n      }\n\n      el = el.parentNode\n    }\n  }\n\n  function onSubmit(e) {\n    var target = e.target\n\n    // Ignore if already prevented\n    if (e.defaultPrevented) return\n\n    // Only handle if emitted on a form element that isn't multipart\n    if (target.tagName.toLowerCase() !== 'form') return\n    if (target.enctype === 'multipart/form-data') return\n\n    // Ignore if created by Tracks\n    if (target.hasAttribute && target.hasAttribute('data-router-ignore')) return\n\n    // Use the url from the form action, defaulting to the current url\n    var url = target.action || window.location.href\n    history.push(url, true, null, e)\n  }\n\n  function onPopState(e) {\n    // HACK: Chrome sometimes does a pop state before the app is set up properly\n    if (!history.app.page) return\n\n    var previous = currentPath\n    var state = e.state\n    currentPath = window.location.pathname + window.location.search\n\n    var options = {\n      previous: previous\n    , url: currentPath\n    }\n\n    if (state) {\n      if (!state.$render) return\n      options.method = state.$method\n      // Note that the post body is only sent on the initial reqest\n      // and it is empty if the state is later popped\n      return router.render(history, options)\n    }\n\n    // The state object will be null for states created by jump links.\n    // window.location.hash cannot be used, because it returns nothing\n    // if the url ends in just a hash character\n    var url = window.location.href\n      , hashIndex = url.indexOf('#')\n      , el, id\n    if (~hashIndex && currentPath !== previous) {\n      options.method = 'get'\n      router.render(history, options)\n      id = url.slice(hashIndex + 1)\n      if (el = document.getElementById(id) || document.getElementsByName(id)[0]) {\n        el.scrollIntoView()\n      }\n    }\n  }\n\n  document.addEventListener('click', onClick, true)\n  document.addEventListener('submit', onSubmit, false)\n  window.addEventListener('popstate', onPopState, true)\n}\n","var Route = require('../vendor/express/router/route')\nvar History = require('./History')\nvar router = module.exports = require('./router')\n\nrouter.setup = setup\n\nfunction setup(app) {\n  var routes = {\n    queue: {}\n  , transitional: {}\n  , app: app\n  }\n  app.history = new History(app, routes)\n\n  ;['get', 'post', 'put', 'del', 'enter', 'exit'].forEach(function(method) {\n    var queue = routes.queue[method] = []\n    var transitional = routes.transitional[method] = []\n\n    app[method] = function(pattern, callback) {\n      if (Array.isArray(pattern)) {\n        pattern.forEach(function(item) {\n          app[method](item, callback)\n        })\n        return app\n      }\n\n      if (router.isTransitional(pattern)) {\n        var from = pattern.from\n        var to = pattern.to\n        var forward = pattern.forward || (callback && callback.forward) || callback\n        var back = pattern.back || (callback && callback.back)\n\n        var fromRoute = new Route(method, from, back)\n        var toRoute = new Route(method, to, forward)\n        fromRoute.isTransitional = true\n        toRoute.isTransitional = true\n        transitional.push({\n          from: fromRoute\n        , to: toRoute\n        })\n        if (back) transitional.push({\n          from: toRoute\n        , to: fromRoute\n        })\n\n        return app\n      }\n\n      queue.push(new Route(method, pattern, callback))\n      return app\n    }\n  })\n}\n","var qs = require('qs')\nvar nodeUrl = require('url');\n\nmodule.exports = {\n  render: render\n, isTransitional: isTransitional\n, mapRoute: mapRoute\n}\n\nfunction isTransitional(pattern) {\n  return pattern.hasOwnProperty('from') && pattern.hasOwnProperty('to')\n}\n\nfunction mapRoute(from, params) {\n  var i = params.url.indexOf('?')\n  var queryString = (~i) ? params.url.slice(i) : ''\n  // If the route looks like /:a/:b?/:c/:d?\n  // and :b and :d are missing, return /a/c\n  // Thus, skip the / if the value is missing\n  var i = 0\n  var path = from.replace(/\\/(?:(?:\\:([^?\\/:*(]+)(?:\\([^)]+\\))?)|\\*)(\\?)?/g, onMatch)\n  function onMatch(match, key, optional) {\n    var value = key ? params[key] : params[i++]\n    return (optional && value == null) ? '' : '/' + encodeURIComponent(value)\n  }\n  return path + queryString\n}\n\nfunction render(history, options, e) {\n  var req = new RenderReq(history.app.page, history.routes, options, e)\n  req.routeTransitional(0, function() {\n    req.page = history.page()\n    req.routeQueue(0, function() {\n      // Cancel rendering by this app if no routes match\n      req.cancel()\n    })\n  })\n}\n\nfunction RenderReq(page, routes, options, e) {\n  this.page = page\n  this.options = options\n  this.e = e\n  this.setUrl(options.url.replace(/#.*/, ''))\n  var queryString = nodeUrl.parse(this.url).query;\n  this.query = queryString ? qs.parse(queryString) : {}\n  this.method = options.method\n  this.body = options.body || {}\n  this.setPrevious(options.previous)\n  this.transitional = routes.transitional[this.method]\n  this.queue = routes.queue[this.method]\n  this.app = routes.app\n}\n\nRenderReq.prototype.cancel = function() {\n  var options = this.options\n  // Don't do anything if this is the result of an event, since the\n  // appropriate action will happen by default\n  if (this.e || options.noNavigate) return\n  // Otherwise, manually perform appropriate action\n  if (options.form) {\n    options.form.setAttribute('data-router-ignore', '')\n    options.form.submit()\n  } else {\n    window.location.assign(options.url)\n  }\n}\n\nRenderReq.prototype.setUrl = function(url) {\n  this.url = url\n  this.path = url.replace(/\\?.*/, '')\n}\nRenderReq.prototype.setPrevious = function(previous) {\n  this.previous = previous\n  this.previousPath = previous && previous.replace(/\\?.*/, '')\n}\n\nRenderReq.prototype.routeTransitional = function(i, next) {\n  i || (i = 0)\n  var item\n  while (item = this.transitional[i++]) {\n    if (!item.to.match(this.path) || !item.from.match(this.previousPath)) continue\n    var req = this\n    var params = this.routeParams(item.to)\n    // Even though we don't need to do anything after a done, pass a\n    // no op function, so that routes can expect it to be defined\n    function done() {}\n    this.onMatch(item.to, params, function(err) {\n      if (err) return req.cancel()\n      req.routeTransitional(i, next)\n    }, done)\n    return\n  }\n  next()\n}\n\nRenderReq.prototype.routeQueue = function(i, next) {\n  i || (i = 0)\n  var route\n  while (route = this.queue[i++]) {\n    if (!route.match(this.path)) continue\n    var req = this\n    var params = this.routeParams(route)\n    this.onMatch(route, params, function(err) {\n      if (err) return req.cancel()\n      req.routeQueue(i, next)\n    })\n    return\n  }\n  next()\n}\n\nRenderReq.prototype.onMatch = function(route, params, next, done) {\n  if (!this.page) return next()\n  // Stop the default browser action, such as clicking a link or submitting a form\n  if (this.e) {\n    this.e.preventDefault()\n    this.e = null\n  }\n  this.page.params = params\n  if (route.isTransitional) {\n    this.app.onRoute(route.callbacks, this.page, next, done)\n  } else {\n    this.app.onRoute(route.callbacks, this.page, next)\n  }\n}\n\nRenderReq.prototype.routeParams = function(route) {\n  var routeParams = route.params\n  var params = routeParams.slice()\n\n  for (var key in routeParams) {\n    params[key] = routeParams[key]\n  }\n  params.previous = this.previous\n  params.url = this.url\n  params.body = this.body\n  params.query = this.query\n  params.method = this.method\n  return params\n}\n","\n/**\n * Module dependencies.\n */\n\nvar utils = require('../utils');\n\n/**\n * Expose `Route`.\n */\n\nmodule.exports = Route;\n\n/**\n * Initialize `Route` with the given HTTP `method`, `path`,\n * and an array of `callbacks` and `options`.\n *\n * Options:\n *\n *   - `sensitive`    enable case-sensitive routes\n *   - `strict`       enable strict matching for trailing slashes\n *\n * @param {String} method\n * @param {String} path\n * @param {Array} callbacks\n * @param {Object} options.\n * @api private\n */\n\nfunction Route(method, path, callbacks, options) {\n  options = options || {};\n  this.path = path;\n  this.method = method;\n  this.callbacks = callbacks;\n  this.regexp = utils.pathRegexp(path\n    , this.keys = []\n    , options.sensitive\n    , options.strict);\n}\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nRoute.prototype.match = function(path){\n  var keys = this.keys\n    , params = this.params = []\n    , m = this.regexp.exec(path);\n\n  if (!m) return false;\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n\n    var val = 'string' == typeof m[i]\n      ? decodeURIComponent(m[i])\n      : m[i];\n\n    if (key) {\n      params[key.name] = val;\n    } else {\n      params.push(val);\n    }\n  }\n\n  return true;\n};\n","\n/**\n * Module dependencies.\n */\n\n/**\n * toString ref.\n */\n\nvar toString = {}.toString;\n\n/**\n * Return ETag for `body`.\n *\n * @param {String|Buffer} body\n * @return {String}\n * @api private\n */\n\nexports.etag = function(body){\n  return '\"' + crc32.signed(body) + '\"';\n};\n\n/**\n * Make `locals()` bound to the given `obj`.\n *\n * This is used for `app.locals` and `res.locals`.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\nexports.locals = function(obj){\n  function locals(obj){\n    for (var key in obj) locals[key] = obj[key];\n    return obj;\n  };\n\n  return locals;\n};\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.isAbsolute = function(path){\n  if ('/' == path[0]) return true;\n  if (':' == path[1] && '\\\\' == path[2]) return true;\n};\n\n/**\n * Flatten the given `arr`.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.flatten = function(arr, ret){\n  var ret = ret || []\n    , len = arr.length;\n  for (var i = 0; i < len; ++i) {\n    if (Array.isArray(arr[i])) {\n      exports.flatten(arr[i], ret);\n    } else {\n      ret.push(arr[i]);\n    }\n  }\n  return ret;\n};\n\n/**\n * Normalize the given `type`, for example \"html\" becomes \"text/html\".\n *\n * @param {String} type\n * @return {Object}\n * @api private\n */\n\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n\n/**\n * Normalize `types`, for example \"html\" becomes \"text/html\".\n *\n * @param {Array} types\n * @return {Array}\n * @api private\n */\n\nexports.normalizeTypes = function(types){\n  var ret = [];\n\n  for (var i = 0; i < types.length; ++i) {\n    ret.push(exports.normalizeType(types[i]));\n  }\n\n  return ret;\n};\n\n/**\n * Return the acceptable type in `types`, if any.\n *\n * @param {Array} types\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.acceptsArray = function(types, str){\n  // accept anything when Accept is not present\n  if (!str) return types[0];\n\n  // parse\n  var accepted = exports.parseAccept(str)\n    , normalized = exports.normalizeTypes(types)\n    , len = accepted.length;\n\n  for (var i = 0; i < len; ++i) {\n    for (var j = 0, jlen = types.length; j < jlen; ++j) {\n      if (exports.accept(normalized[j], accepted[i])) {\n        return types[j];\n      }\n    }\n  }\n};\n\n/**\n * Check if `type(s)` are acceptable based on\n * the given `str`.\n *\n * @param {String|Array} type(s)\n * @param {String} str\n * @return {Boolean|String}\n * @api private\n */\n\nexports.accepts = function(type, str){\n  if ('string' == typeof type) type = type.split(/ *, */);\n  return exports.acceptsArray(type, str);\n};\n\n/**\n * Check if `type` array is acceptable for `other`.\n *\n * @param {Object} type\n * @param {Object} other\n * @return {Boolean}\n * @api private\n */\n\nexports.accept = function(type, other){\n  var t = type.value.split('/');\n  return (t[0] == other.type || '*' == other.type)\n    && (t[1] == other.subtype || '*' == other.subtype)\n    && paramsEqual(type.params, other.params);\n};\n\n/**\n * Check if accept params are equal.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Boolean}\n * @api private\n */\n\nfunction paramsEqual(a, b){\n  return !Object.keys(a).some(function(k) {\n    return a[k] != b[k];\n  });\n}\n\n/**\n * Parse accept `str`, returning\n * an array objects containing\n * `.type` and `.subtype` along\n * with the values provided by\n * `parseQuality()`.\n *\n * @param {Type} name\n * @return {Type}\n * @api private\n */\n\nexports.parseAccept = function(str){\n  return exports\n    .parseParams(str)\n    .map(function(obj){\n      var parts = obj.value.split('/');\n      obj.type = parts[0];\n      obj.subtype = parts[1];\n      return obj;\n    });\n};\n\n/**\n * Parse quality `str`, returning an\n * array of objects with `.value`,\n * `.quality` and optional `.params`\n *\n * @param {String} str\n * @return {Array}\n * @api private\n */\n\nexports.parseParams = function(str){\n  return str\n    .split(/ *, */)\n    .map(acceptParams)\n    .filter(function(obj){\n      return obj.quality;\n    })\n    .sort(function(a, b){\n      if (a.quality === b.quality) {\n        return a.originalIndex - b.originalIndex;\n      } else {\n        return b.quality - a.quality;\n      }\n    });\n};\n\n/**\n * Parse accept params `str` returning an\n * object with `.value`, `.quality` and `.params`.\n * also includes `.originalIndex` for stable sorting\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction acceptParams(str, index) {\n  var parts = str.split(/ *; */);\n  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };\n\n  for (var i = 1; i < parts.length; ++i) {\n    var pms = parts[i].split(/ *= */);\n    if ('q' == pms[0]) {\n      ret.quality = parseFloat(pms[1]);\n    } else {\n      ret.params[pms[0]] = pms[1];\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function(html) {\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Boolean} sensitive\n * @param  {Boolean} strict\n * @return {RegExp}\n * @api private\n */\n\nexports.pathRegexp = function(path, keys, sensitive, strict) {\n  if (toString.call(path) == '[object RegExp]') return path;\n  if (Array.isArray(path)) path = '(' + path.join('|') + ')';\n  path = path\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?(\\*)?/g, function(_, slash, format, key, capture, optional, star){\n      keys.push({ name: key, optional: !! optional });\n      slash = slash || '';\n      return ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + (optional ? slash : '')\n        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n        + (optional || '')\n        + (star ? '(/*)?' : '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n}\n","(function (global){\n\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n","/**\n * Created by durupina on 12/30/16.\n * Cytoscape functions for drawing causality graphs\n */\n\n// LOCAL FUNCTIONS\n\n/**\n * Codes edge types by color, line type etc.\n * @param edgeType\n * @returns {{color:'', linestyle:}}\n */\nfunction attributeMap(edgeType){\n    var attributes = {color: 'gray', lineStyle: 'solid'};\n\n    switch(edgeType){\n        case \"controls-state-change-of\":\n            attributes[\"color\"] = \"coral\";\n            attributes[\"lineStyle\"]= \"dashed\";\n            break;\n        case \"controls-transport-of\":\n            attributes[\"color\"] = \"blue\";\n            break;\n        case \"controls-phosphorylation-of\":\n            attributes[\"color\"] =  \"teal\";\n            break;\n        case \"controls-expression-of\":\n            attributes[\"color\"] =  \"deeppink\";\n            break;\n        case \"catalysis-precedes\":\n            attributes[\"color\"] =  \"red\";\n            break;\n        case \"in-complex-with\":\n            attributes[\"color\"] =  \"steelblue\";\n            break;\n        case \"interacts-with\":\n            attributes[\"color\"] =  \"aquamarine\";\n            break;\n        case \"neighbor-of\":\n            attributes[\"color\"] =  \"lime\";\n            break;\n        case \"consumption-controled-by\":\n            attributes[\"color\"] =  \"yellow\";\n            break;\n        case \"controls-production-of\":\n            attributes[\"color\"] =  \"purple\";\n            break;\n        case \"controls-transport-of-chemical\":\n            attributes[\"color\"] =  \"cornflowerblue\";\n            break;\n        case \"chemical-affects\":\n            attributes[\"color\"] =  \"darkviolet\";\n            break;\n        case \"reacts-with\":\n            attributes[\"color\"] =  \"deepskyblue\";\n            break;\n        case \"used-to-produce\":\n            attributes[\"color\"] =  \"green\";\n            break;\n        case \"upregulates-expression\":\n            attributes[\"lineStyle\"]= \"dashed\";\n            attributes[\"color\"] =  \"green\";\n            break;\n        case \"downregulates-expression\":\n            attributes[\"lineStyle\"]= \"dashed\";\n            attributes[\"color\"] =  \"red\";\n            break;\n        case \"phosphorylates\":\n            attributes[\"color\"] =  \"green\";\n            break;\n        case \"dephosphorylates\":\n            attributes[\"color\"] =  \"red\";\n            break;\n        default:\n            attributes[\"color\"] =  'gray';\n            break;\n    }\n\n    return attributes;\n}\n\n\n/***\n * Distribute sites around the node evenly\n */\nfunction computeSitePositions(node){\n\n    if(node.data(\"sites\")) {\n        var siteLength = node.data(\"sites\").length;\n\n        for (var i = 0; i < siteLength; i++) {\n            var site = node.data(\"sites\")[i];\n            var paddingCoef = 0.9 ;\n\n            var centerX = node.position(\"x\");\n            var centerY = node.position(\"y\");\n            var width = node.width() * paddingCoef;\n            var height = node.height();\n            var siteCenterX;\n            var siteCenterY;\n\n            var siteWidth = 15;\n            var siteHeight = 15;\n\n            //Draw sites at the top of the node\n            if(i % 2 == 0){\n                siteCenterX = centerX - width / 2 + siteWidth / 2  + width * i /siteLength ;\n                siteCenterY = centerY - height /  2;\n\n            }\n            else{ //Draw sites at the bottom of the node\n                siteCenterX = centerX - width / 2 + siteWidth / 2  + width * (i - 1) /siteLength ;\n                siteCenterY = centerY + height /  2;\n\n            }\n\n            //extend site information\n            node.data(\"sites\")[i].bbox = {'x': siteCenterX, 'y': siteCenterY, 'w': siteWidth, 'h': siteHeight};\n\n            //hack to update the bounding boxes of sites in the viewport\n            node.select();\n            node.unselect();\n        }\n\n    }\n}\n\n\n\n/***\n * Find the site that the user clicked and set it as selected\n * @param pos : mouse position\n * @param node : selected node\n * @returns selected site\n */\nfunction selectAndReturnSite(pos,  node){\n\n    if(!node.data(\"sites\"))\n        return null;\n\n    for(var i = 0; i < node.data(\"sites\").length; i++){\n        var site = node.data(\"sites\")[i];\n        if(pos.x >= (site.bbox.x - site.bbox.w/2) && pos.x <= (site.bbox.x + site.bbox.w/2) &&\n            pos.y >= (site.bbox.y - site.bbox.h/2) && pos.y <= (site.bbox.y + site.bbox.h/2)){\n            site.selected = true;\n            return site;\n        }\n    }\n    return null;\n}\n\n/***\n * Unselect all sites of a node\n * @param node\n */\nfunction unselectAllSites(node) {\n    if (!node.data(\"sites\"))\n        return;\n\n    node.data(\"sites\").forEach(function(site){\n        site.selected = false;\n    });\n}\n\n\n\n\n/***\n * @param modelCy: Cy elements stored in the model as json objects\n * @param doTopologyGrouping\n * @returns model cy elements converted into cytoscape format with edge ids added\n */\nmodule.exports.convertModelJsonToCyElements = function(modelCy, doTopologyGrouping){\n\n\n    var nodes = [];\n    var edges = [];\n\n    for(var obj in modelCy.nodes){\n        var node = modelCy.nodes[obj]\n            var nodeClone = _.clone(node);\n            nodes.push(nodeClone);\n    };\n\n\n\n    for(var obj in modelCy.edges){\n        var edge = modelCy.edges[obj];\n        var newEdge = _.clone(edge);\n        //need to set this explicitly otherwise cytoscape gives a random id\n        var id = edge.data.source + \"-\" + edge.data.target;\n        newEdge.data.id = id;\n        edges.push(newEdge);\n    };\n\n    var cyElements = {nodes: nodes, edges: edges};\n\n\n    if(doTopologyGrouping)\n        return groupTopology(cyElements);\n    else\n        return cyElements;\n\n}\n\nmodule.exports.runLayout = function(){\n    var options =  {\n        animate: false,\n        fit: true,\n        randomize: false,\n        nodeRepulsion: 4500,\n        idealEdgeLength: 50,\n        edgeElasticity: 0.45,\n        nestingFactor: 0.1,\n        gravity: 0.25,\n        numIter: 5000,\n        tile: true,\n        tilingPaddingVertical: 5,\n        tilingPaddingHorizontal: 5,\n        name: 'cose-bilkent'\n\n    };\n    cy.layout(options);\n\n\n}\n\nmodule.exports.createContainer = function(el, doTopologyGrouping, modelManager, callback) {\n\n    var modelCy = modelManager.getModelCy();\n\n    var cyElements = module.exports.convertModelJsonToCyElements(modelCy, doTopologyGrouping);\n\n\n    var cy = window.cy = cytoscape({\n        container: el,\n\n        boxSelectionEnabled: true,\n        autounselectify: false,\n\n\n        layout: {\n            animate: false,\n            fit: true,\n            randomize: false,\n            nodeRepulsion: 4500,\n            idealEdgeLength: 50,\n            edgeElasticity: 0.45,\n            nestingFactor: 0.1,\n            gravity: 0.25,\n            numIter: 5000,\n            tile: true,\n            tilingPaddingVertical: 5,\n            tilingPaddingHorizontal: 5,\n            name: 'cose-bilkent'\n\n        },\n\n        style: CgfStyleSheet,\n\n        elements: cyElements,\n\n        ready: function () {\n\n\n            cy.on('layoutstop', function() {\n                cy.nodes().forEach(function (node) {\n                    computeSitePositions(node);\n                });\n            });\n\n\n            if(callback) callback();\n\n            cy.on('drag', 'node', function (e) {\n                computeSitePositions(this);\n            });\n\n            cy.on('select', 'node', function(e){\n                this.css('background-color', '#FFCC66');\n\n            });\n\n            cy.on('unselect', 'node', function(e){\n                //get original background color\n                var backgroundColor = modelManager.getModelNodeAttribute(this.id(), 'css.backgroundColor');\n                if(!backgroundColor)\n                    backgroundColor = 'white';\n                this.css('background-color', backgroundColor);\n                unselectAllSites(this);\n            });\n\n            cy.on('tap', 'node', function(e) {\n\n                var site = selectAndReturnSite(e.cyPosition, e.cyTarget);\n\n                if(!site){ //node is clicked\n                    if(this.data('tooltipText')) { //there is content to show\n                        cy.$(('#' + this.id())).qtip({\n                            content: {\n                                text: function (event, api) {\n                                    return this.data('tooltipText');\n                                }\n                            },\n                            show: {\n                                ready: true\n                            },\n                            position: {\n                                my: 'center',\n                                at: 'center',\n                                adjust: {\n                                    cyViewport: true\n\n                                },\n                                effect: false\n                            },\n                            style: {\n                                classes: 'qtip-bootstrap',\n                                tip: {\n                                    corner: false,\n                                    width: 20,\n                                    height: 20\n                                }\n                            }\n                        });\n                    }\n                }\n                else if (site.siteInfo) { //site is clicked and it has information to display\n                    //Adjust the positions of qtip boxes\n                    var sitePosX = site.bbox.x - this.position(\"x\");\n                    var sitePosY = site.bbox.y - this.position(\"y\");\n\n                    var my;\n                    var at;\n\n                    if (sitePosX < 0 && sitePosY < 0) {\n                        my = \"bottom right\";\n                        at = \"top left\";\n                    }\n                    else if (sitePosX < 0 && sitePosY >= 0) {\n                        my = \"bottom right\";\n                        at = \"bottom left\";\n                    }\n                    else if (sitePosX >= 0 && sitePosY >= 0) {\n                        my = \"bottom left\";\n                        at = \"bottom right\";\n                    }\n                    else if (sitePosX >= 0 && sitePosY < 0) {\n                        my = \"bottom left\";\n                        at = \"top right\";\n                    }\n\n                    cy.$(('#' + this.id())).qtip({\n                        content: {\n                            text: function (event, api) {\n                                return site.siteInfo;\n                            }\n                        },\n                        show: {\n                            ready: true\n                        },\n                        position: {\n                            my: my,\n                            at: at,\n                            adjust: {\n                                cyViewport: true\n\n                            },\n                            effect: false\n                        },\n                        style: {\n                            classes: 'qtip-bootstrap',\n                            tip: {\n                                corner: false,\n                                width: 20,\n                                height: 20\n                            }\n                        }\n                    });\n                }\n\n            });\n\n            cy.on('tapend', 'node', function(e){\n                $('.qtip').remove();\n            });\n\n\n            cy.on('tapend', 'edge', function (e) {\n\n                var edge = this;\n\n                edge.qtip({\n                    content: function () {\n                        return \"<b style='text-align:center;font-size:16px;'>\" + edge.data(\"edgeType\") + \"</b>\";\n                    },\n                    show: {\n                        ready: true\n                    },\n                    position: {\n                        my: 'top center',\n                        at: 'bottom center',\n                        adjust: {\n                            cyViewport: true\n                        }\n                    },\n                    style: {\n                        classes: 'qtip-bootstrap',\n                        tip: {\n                            width: 16,\n                            height: 8\n                        }\n                    }\n                });\n            });\n        }\n\n\n    });\n\n\n}\n\n/***\n * Style sheet for causality graphs\n */\nvar CgfStyleSheet = cytoscape.stylesheet()\n        .selector('node')\n        .css({\n            // 'border-width':'css(border-width)',\n            // 'border-color': 'css(border-color)',\n            //  'background-color':'white',\n            'shape': 'cgfNode',\n            'text-halign': 'center',\n            'text-valign':'center',\n            'background-color': 'white',\n\n            'width': function(ele){\n                var spacing =(ele.data('id').length +2) * 10;\n                return  Math.min(200,spacing);\n            },\n            'height':30,\n            'content': 'data(text)',\n\n        })\n        .selector('node:selected')\n        .css({\n            'overlay-color': 'FFCC66',\n            'opacity': 1\n        })\n        .selector('edge')\n        .css({\n            'width': 'css(width)',\n            'line-color': function(ele){\n                return attributeMap(ele.data('edgeType')).color;\n\n            },\n            'line-style': function(ele){\n                return attributeMap(ele.data('edgeType')).lineStyle;\n            },\n            'curve-style': 'bezier',\n\n            'target-arrow-color': function(ele){\n                return attributeMap(ele.data('edgeType')).color;\n            },\n            'target-arrow-shape':'triangle',\n            //     function(ele) {\n            //     if (ele.data('edgeType') == \"in-complex-with\" || ele.data('edgeType') == \"interacts-with\" || //nondirected\n            //         ele.data('edgeType') == \"neighbor-of\" || ele.data('edgeType') == \"reacts-with\")\n            //         return 'none';\n            //     return 'cgfArrow';\n            // },\n            'arrow-size':5,\n            'opacity': 0.8\n        })\n        .selector('edge:selected')\n        .css({\n            'line-color': 'black',\n            'target-arrow-color': 'black',\n            'source-arrow-color': 'black',\n            'opacity': 1\n        })\n\n        .selector(\"node:parent\")\n        .css({\n            'text-valign': 'bottom',\n            'content': 'data(edgeType)', //there is a label when there's a clique among the nodes inside the compound\n            'font-size': 8,\n\n\n        })\n        .selector(\"node:child\")\n        .css({\n\n            'padding-top': '10px',\n            'padding-bottom': '10px',\n            'padding-left': '10px',\n            'padding-right': '10px',\n\n\n        })\n    ;\n","/*\n *\tShared model handling operations.\n *  Clients call these commands to update the model\n *\tAuthor: Funda Durupinar Babur<f.durupinar@gmail.com>\n */\n\n\nmodule.exports =  function(model, docId, userId, userName) {\n\n    var user = model.at('users.' + userId);\n\n\n    model.ref('_page.doc', 'documents.' + docId);\n\n    return ModelManager = { //global reference for testing\n\n\n\n        getModel: function(){\n            return model;\n        },\n\n\n        setName: function(userName){\n\n            model.fetch('users', userId, function(err){\n                user.set('name', userName);\n            });\n        },\n\n        getName: function(){\n            return model.get('users.' + userId +'.name');\n        },\n\n        getModelNode: function(id){\n\n            var nodePath = model.at('_page.doc.cy.nodes.'  + id);\n\n            return nodePath.get();\n        },\n\n\n        /***\n         * Attributes are in the form of attr1.attr2.attr3\n         * @param id\n         * @param attributeName\n         * @returns {*}\n         */\n        getModelNodeAttribute: function(id, attributeName){\n            return model.get('_page.doc.cy.nodes.' + id + '.' + attributeName);\n\n        },\n\n\n        getModelEdge: function(id){\n\n            var edgePath = model.at('_page.doc.cy.edges.'  + id);\n\n            return edgePath.get();\n        },\n\n        getModelEdgeAttribute: function(id, attributeName){\n            return model.get('_page.doc.cy.edges.'  + id + '.' + attributeName);\n        },\n\n\n\n        /***\n         * Delete everything in the model\n         */\n        clearModel: function(){\n\n            model.del('_page.doc.cy.nodes');\n            model.del('_page.doc.cy.edges');\n            model.del('_page.doc.cy');\n\n        },\n\n\n        /***\n         * Initialize the model from json\n         * @param jsonObj\n         */\n        initModelFromJson: function(jsonObj){\n\n            //Keep a hash of nodes by their ids as keys\n            for(var i = 0; i < jsonObj.nodes.length; i++){\n\n                var node = jsonObj.nodes[i];\n\n                model.set('_page.doc.cy.nodes.' + node.data.id + '.id', node.data.id);\n                model.set('_page.doc.cy.nodes.' + node.data.id  + '.data' , node.data);\n                model.set('_page.doc.cy.nodes.' + node.data.id  + '.css' , node.css);\n\n            };\n\n\n\n            //Keep a hash of edges by their ids as keys\n            for(var i = 0; i < jsonObj.edges.length; i++){\n\n                var edge = jsonObj.edges[i];\n\n                //Edge.data.id may not have been explicitly defined in the json file\n                var edgeId = edge.data.id;\n                if(!edgeId)\n                    edgeId = edge.data.source + \"-\" + edge.data.target;\n\n                model.set('_page.doc.cy.edges.' + edgeId + '.id', edgeId);\n                model.set('_page.doc.cy.edges.' + edgeId + '.data', edge.data);\n                model.set('_page.doc.cy.edges.' + edgeId + '.css', edge.css);\n\n\n            };\n\n\n        },\n\n        initModelNodePositions:function(nodes){\n                for(var i = 0; i < nodes.length; i++){\n                    model.set('_page.doc.cy.nodes.' + nodes[i].id() +'.position', nodes[i].position());\n\n                }\n        },\n\n\n\n        getModelCy: function(){\n            return model.get('_page.doc.cy');\n        },\n\n\n\n    }\n}\n\n","QUnit = require('qunitjs');\nmodule.exports = function() {\n    QUnit.testStart(function( details ) {\n        console.log( \"Now running: \", details.module, details.name );\n    });\n\n    QUnit.log(function( details ) {\n        console.log( \"Log: \", details.result, details.message );\n    });\n\n\n    QUnit.done(function( details ) {\n        console.log( \"Total: \", details.total, \" Failed: \", details.failed, \" Passed: \", details.passed, \" Runtime: \", details.runtime );\n    });\n\n}","QUnit = require('qunitjs');\nmodule.exports = function(){\n\n\n    QUnit.module( \"modelManager Tests\" );\n\n    // QUnit.test('modelManager.setName()', function(assert) {\n    //     ModelManager.setName(\"abc\");\n    //       assert.equal(ModelManager.getName(), \"abc\", \"User name is correctly set.\");\n    // });\n    //\n\n    function clearModel(){\n        QUnit.test('modelManager.clearModel()', function(assert) {\n            ModelManager.clearModel();\n            assert.notOk(ModelManager.getModelCy(), \"Model successfully deleted.\");\n\n\n        });\n    }\n\n    function initModelFromJsonTest(jsonObj){\n        QUnit.test('modelManager.initModelFromJson()', function(assert) {\n\n\n            ModelManager.initModelFromJson(jsonObj);\n\n            for(var i = 0; i < jsonObj.nodes.length; i++){\n\n                var modelNode = ModelManager.getModelNode(jsonObj.nodes[i].data.id);\n                assert.ok(modelNode, \"Node exists. Id: \" + jsonObj.nodes[i].data.id);\n                assert.propEqual(modelNode.data, jsonObj.nodes[i].data, \"Node \" + i + \" data is correctly assigned.\");\n                assert.propEqual(modelNode.css, jsonObj.nodes[i].css, \"Node\" + i + \" css is correctly assigned.\");\n            }\n\n            for(var i = 0; i < jsonObj.edges.length; i++){\n\n                //edgeId is not explicitly specified in jsonObj\n                var edgeId =  jsonObj.edges[i].data.source + \"-\" + jsonObj.edges[i].data.target;\n                var modelEdge = ModelManager.getModelEdge(edgeId);\n                assert.ok(modelEdge, \"Edge exists. Id: \" + edgeId);\n                assert.propEqual(modelEdge.data, jsonObj.edges[i].data, \"Edge \" + i + \" data is correctly assigned.\");\n                assert.propEqual(modelEdge.css, jsonObj.edges[i].css, \"Edge\" + i + \" css is correctly assigned.\");\n            }\n\n        });\n    }\n\n    QUnit.module( \"Cytoscape Tests\" );\n    function createCyTest(callback){\n        QUnit.test('createCyContainer', function(assert){\n            var cgfCy = require('../public/src/cgf-visualizer/cgf-cy.js');\n            assert.ok(cgfCy,\"Cytoscape visualizer accessed.\");\n            var cont = new cgfCy.createContainer($('#graph-container'),  false, ModelManager, function () {\n                assert.ok(cy,\"Cytoscape container created successfully.\");\n                if(callback) callback(); //call cy-related tests after container is created\n            });\n\n\n        })\n    }\n\n\n    function selectNodeTest(){\n        QUnit.test('modelManager.selectNode()', function(assert){\n\n            var id = \"CDK1\";\n            var color = ModelManager.getModelNodeAttribute(id, 'css.backgroundColor');\n            assert.equal(color, \"rgb(255,196,183)\", \"Node background color is initially correct.\");\n\n            var nodeCy = cy.getElementById(id);\n            assert.ok(nodeCy, \"Node \" + id + \" exists.\");\n            cy.getElementById(id).select();\n\n            //\n            color = cy.getElementById(id).css('background-color');\n        //     console.log(color);\n        //    assert.equal(color, \"#FFCC66\", \"Node background color is correct when selected.\");\n            // cy.getElementById(id).unselect();\n            // color = ModelManager.getModelNodeAttribute(id, 'css.backgroundColor');\n            // assert.equal(color, \"rgb(255,149,125)\", \"Node background color is correct when unselected.\");\n        });\n    }\n\n\n    function topologyGroupingTest() {\n        QUnit.test('topologyGrouping', function (assert) {\n            var modelCy = ModelManager.getModelCy();\n            var cgfCy = require('../public/src/cgf-visualizer/cgf-cy.js');\n\n\n            //Before grouping\n            var edge1 = cy.getElementById(\"RBBP4-CCNB1\");\n            var edge2 = cy.getElementById(\"LIN9-CCNB1\");\n            var edge3 = cy.getElementById(\"KLF5-CCNB1\");\n\n\n            assert.equal(edge1._private.data.target, edge2._private.data.target, \"edge1 and edge2 have the same target.\");\n            assert.equal(edge1._private.data.target, edge3._private.data.target, \"edge1, edge2 and edge3 have the same target.\");\n\n\n            //After topology grouping\n            var cyElements = cgfCy.convertModelJsonToCyElements(modelCy, true);\n\n            var node1 = cy.getElementById(\"RBBP4\");\n            var node2 = cy.getElementById(\"LIN9\");\n            var node3 = cy.getElementById(\"KLF5\");\n\n            assert.equal(node1._private.data.parent, node2._private.data.parent, \"node1 and node2 grouped correctly.\");\n            assert.equal(node1._private.data.parent, node3._private.data.parent, \"node1, node2 and node3 are grouped correctly.\");\n\n            var parentId = node1._private.data.parent;\n\n\n            var newEdge = cy.getElementById(parentId + \"-\" + \"CCNB1\");\n\n            assert.ok(newEdge, \"New edge between parent and CCNB1 exists\");\n\n        });\n    }\n\n\n\n    clearModel();\n    initModelFromJsonTest(demoJson);\n\n    createCyTest(function() {\n        //call cy-related tests after container is created\n        selectNodeTest();\n\n        topologyGroupingTest();\n    });\n\n\n\n\n};"]}